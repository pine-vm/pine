module CompilationInterface.SourceFiles.Generated_SourceFiles exposing (..)


type FileTreeNode blobStructure
    = BlobNode blobStructure
    | TreeNode (List ( String, FileTreeNode blobStructure ))


file__src_Backend_VolatileProcess_csx =
    { utf8 = "#r \"netstandard\"\n#r \"System\"\n#r \"System.Collections.Immutable\"\n#r \"System.Net\"\n#r \"System.Net.Http\"\n#r \"System.Net.Primitives\"\n#r \"System.Private.Uri\"\n#r \"System.Linq\"\n#r \"System.Runtime.InteropServices.RuntimeInformation\"\n#r \"System.Text.Json\"\n\n#r \"Pine.Core\"\n#r \"pine\"\n\nusing Pine.Core;\nusing Pine;\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Linq;\n\n\nint loadCompositionLimitFileCount = 130;\nint loadCompositionLimitAggregateFileSize = 3_500_000;\nint loadCompositionLimitMaximumPathLength = 200;\n\n\npublic class RequestStructure\n{\n    public IReadOnlyList<ElmMakeRequestStructure> ElmMakeRequest { set; get; }\n\n    public IReadOnlyList<string> FormatElmModuleTextRequest { set; get; }\n\n    public IReadOnlyList<string> LoadCompositionRequest { set; get; }\n}\n\npublic class ResponseStructure\n{\n    [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]\n    public IReadOnlyList<ElmMakeResponseStructure> ElmMakeResponse { set; get; }\n\n    [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]\n    public IReadOnlyList<FormatElmModuleTextResponseStructure> FormatElmModuleTextResponse { set; get; }\n\n    [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]\n    public IReadOnlyList<LoadCompositionResponseStructure> LoadCompositionResponse { set; get; }\n\n    [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]\n    public IReadOnlyList<string> ErrorResponse { set; get; }\n}\n\npublic class ElmMakeRequestStructure\n{\n    public IReadOnlyList<FileWithPath> files { set; get; }\n\n    public IReadOnlyList<string> entryPointFilePathFromWorkingDirectory { set; get; }\n\n    public IReadOnlyList<string> workingDirectoryPath { set; get; }\n\n    public bool makeOptionDebug { set; get; }\n\n    public ElmMakeOutputType outputType { set; get; }\n}\n\npublic class ElmMakeOutputType\n{\n    public object ElmMakeOutputTypeHtml { set; get; }\n    public object ElmMakeOutputTypeJs { set; get; }\n}\n\npublic class FormatElmModuleTextResponseStructure\n{\n    public Maybe<string> formattedText { set; get; }\n\n    public ProcessOutput processOutput { set; get; }\n}\n\npublic class FileWithPath\n{\n    public IReadOnlyList<string> path { set; get; }\n\n    public string contentBase64 { set; get; }\n}\n\npublic class ElmMakeResponseStructure\n{\n    public ProcessOutput processOutput { set; get; }\n\n    public Maybe<string> outputFileContentBase64 { set; get; }\n\n    public ProcessOutput reportJsonProcessOutput { set; get; }\n}\n\npublic struct ProcessOutput\n{\n    public string standardError { set; get; }\n\n    public string standardOutput { set; get; }\n\n    public int exitCode { set; get; }\n}\n\npublic class LoadCompositionResponseStructure\n{\n    public string compositionId { set; get; }\n\n    public IReadOnlyList<FileWithPath> filesAsFlatList { set; get; }\n\n    public string urlInCommit { set; get; }\n}\n\n\nstring GetSerialResponseFromSerialRequest(string serializedRequest)\n{\n    var request = System.Text.Json.JsonSerializer.Deserialize<RequestStructure>(serializedRequest);\n\n    var response = GetResponseFromRequest(request);\n\n    return System.Text.Json.JsonSerializer.Serialize(response);\n}\n\nResponseStructure GetResponseFromRequest(RequestStructure request)\n{\n    var elmMakeRequest =\n        request.ElmMakeRequest?.FirstOrDefault();\n\n    if (elmMakeRequest != null)\n    {\n        return new ResponseStructure\n        {\n            ElmMakeResponse = ImmutableList.Create(ElmMake(elmMakeRequest))\n        };\n    }\n\n    var formatElmModuleTextRequest =\n        request.FormatElmModuleTextRequest?.FirstOrDefault();\n\n    if (formatElmModuleTextRequest != null)\n    {\n        return new ResponseStructure\n        {\n            FormatElmModuleTextResponse = ImmutableList.Create(ElmFormat.FormatElmModuleText(formatElmModuleTextRequest))\n        };\n    }\n\n    var loadCompositionRequest =\n        request.LoadCompositionRequest?.FirstOrDefault();\n\n    if (loadCompositionRequest != null)\n    {\n        var sourcePath = loadCompositionRequest;\n\n        if (!(Uri.TryCreate(sourcePath, UriKind.Absolute, out var uriResult)\n            && (uriResult.Scheme == Uri.UriSchemeHttp || uriResult.Scheme == Uri.UriSchemeHttps)))\n        {\n            return new ResponseStructure\n            {\n                ErrorResponse = ImmutableList.Create(\"This string is not a supported URL: '\" + sourcePath + \"'\")\n            };\n        }\n\n        var loadFromGitResult = LoadFromGitHubOrGitLab.LoadFromUrl(sourcePath);\n\n        return\n            loadFromGitResult\n            .Unpack(\n                fromErr:\n                err => new ResponseStructure\n                {\n                    ErrorResponse = ImmutableList.Create(\"Failed to load from path '\" + sourcePath + \"': \" + err)\n                },\n                fromOk:\n                loadFromGitOk =>\n                {\n                    if (loadFromGitOk?.tree == null)\n                    {\n                        return new ResponseStructure\n                        {\n                            ErrorResponse = ImmutableList.Create(\"Did not find a tree object at '\" + sourcePath + \"'\")\n                        };\n                    }\n\n                    var composition = PineValueComposition.FromTreeWithStringPath(loadFromGitOk.tree);\n\n                    var compositionId =\n                        Convert.ToHexStringLower(PineValueHashTree.ComputeHash(composition).Span);\n\n                    var blobs =\n                        loadFromGitOk.tree.EnumerateBlobsTransitive()\n                        .ToImmutableList();\n\n                    var urlInCommit = loadFromGitOk.urlInCommit;\n\n                    ResponseStructure responseErrorExceedingLimit(string limitName)\n                    {\n                        return new ResponseStructure\n                        {\n                            ErrorResponse = [\"Composition \" + compositionId + \" from \" + urlInCommit + \" exceeds supported limits: \" + limitName]\n                        };\n                    }\n\n                    var fileCount = blobs.Count();\n\n                    if (loadCompositionLimitFileCount < fileCount)\n                    {\n                        return responseErrorExceedingLimit(\"File count: \" + fileCount);\n                    }\n\n                    var aggregateFileSize =\n                        blobs.Sum(file => file.blobContent.Length);\n\n                    var filesBySize =\n                        blobs.OrderByDescending(file => file.blobContent.Length).ToImmutableList();\n\n                    var largestFilesToDisplay =\n                        filesBySize.Take(3).ToImmutableList();\n\n                    if (loadCompositionLimitAggregateFileSize < aggregateFileSize)\n                    {\n                        var largestFilesDescriptions =\n                            largestFilesToDisplay.Select(file => string.Join(\"/\", file.path) + \" (\" + file.blobContent.Length + \" bytes)\");\n\n                        return responseErrorExceedingLimit(\n                            \"Aggregate file size: \" + aggregateFileSize +\n                            \" bytes. Following are the largest \" + largestFilesToDisplay.Count +\n                            \" files:\\n\" + string.Join(\"\\n\", largestFilesDescriptions));\n                    }\n\n                    var maximumPathLength =\n                        blobs.Max(file => file.path.Sum(pathElement => pathElement.Length));\n\n                    if (loadCompositionLimitMaximumPathLength < maximumPathLength)\n                    {\n                        return responseErrorExceedingLimit(\"Maximum path length: \" + maximumPathLength);\n                    }\n\n                    var filesAsFlatList =\n                        blobs\n                        .Select(file => new FileWithPath\n                        {\n                            path = file.path,\n                            contentBase64 = Convert.ToBase64String(file.blobContent.ToArray()),\n                        })\n                        .ToImmutableList();\n\n                    return new ResponseStructure\n                    {\n                        LoadCompositionResponse = ImmutableList.Create(\n                            new LoadCompositionResponseStructure\n                            {\n                                compositionId = compositionId,\n                                filesAsFlatList = filesAsFlatList,\n                                urlInCommit = urlInCommit,\n                            })\n                    };\n                });\n    }\n\n    return new ResponseStructure\n    {\n        ErrorResponse = ImmutableList.Create(\"This request does not encode any supported case.\")\n    };\n}\n\nElmMakeResponseStructure ElmMake(ElmMakeRequestStructure elmMakeRequest)\n{\n    var elmCodeFiles =\n        elmMakeRequest.files\n        .ToImmutableDictionary(\n            file => file.path,\n            file => (ReadOnlyMemory<byte>)Convert.FromBase64String(file.contentBase64));\n\n    var environmentFiles = elmCodeFiles;\n\n    var entryPointFilePathFromWorkingDirectory =\n        MakePlatformSpecificPath(elmMakeRequest.entryPointFilePathFromWorkingDirectory);\n\n    var elmMakeOutputFileName = \"elm-make-output.\" + (elmMakeRequest.outputType.ElmMakeOutputTypeJs != null ? \"js\" : \"html\");\n\n    var commandLineCommonArguments = \"make \" + entryPointFilePathFromWorkingDirectory + \" \" + (elmMakeRequest.makeOptionDebug ? \"--debug\" : \"\");\n\n    var commandLineArguments = commandLineCommonArguments + \" --output=\" + elmMakeOutputFileName;\n    var reportJsonCommandLineArguments = commandLineCommonArguments + \" --report=json\";\n\n    (Pine.ExecutableFile.ProcessOutput processOutput, IReadOnlyCollection<(IReadOnlyList<string> path, ReadOnlyMemory<byte> content)> resultingFiles) commandResultsFromArguments(string arguments)\n    {\n        return\n            Pine.ExecutableFile.ExecuteFileWithArguments(\n                environmentFiles,\n                GetElmExecutableFile,\n                arguments,\n                new Dictionary<string, string>()\n                {\n                //  Avoid elm make failing on `getAppUserDataDirectory`.\n                /* Also, work around problems with elm make like this:\n                -- HTTP PROBLEM ----------------------------------------------------------------\n\n                The following HTTP request failed:\n                    <https://github.com/elm/core/zipball/1.0.0/>\n\n                Here is the error message I was able to extract:\n\n                HttpExceptionRequest Request { host = \"github.com\" port = 443 secure = True\n                requestHeaders = [(\"User-Agent\",\"elm/0.19.0\"),(\"Accept-Encoding\",\"gzip\")]\n                path = \"/elm/core/zipball/1.0.0/\" queryString = \"\" method = \"GET\" proxy =\n                Nothing rawBody = False redirectCount = 10 responseTimeout =\n                ResponseTimeoutDefault requestVersion = HTTP/1.1 } (StatusCodeException\n                (Response {responseStatus = Status {statusCode = 429, statusMessage = \"Too\n                Many Requests\"}, responseVersion = HTTP/1.1, responseHeaders =\n                [(\"Server\",\"GitHub.com\"),(\"Date\",\"Sun, 18 Nov 2018 16:53:18\n                GMT\"),(\"Content-Type\",\"text/html\"),(\"Transfer-Encoding\",\"chunked\"),(\"Status\",\"429\n                Too Many\n                Requests\"),(\"Retry-After\",\"120\")\n\n                To avoid elm make failing with this error, break isolation here and reuse elm home directory.\n                An alternative would be retrying when this error is parsed from `commandResults.processOutput.StandardError`.\n                */\n                {\"ELM_HOME\", GetElmHomeDirectory()},\n                },\n                workingDirectoryRelative: elmMakeRequest.workingDirectoryPath.ToImmutableList());\n    }\n\n    var commandResults = commandResultsFromArguments(commandLineArguments);\n\n    var newFiles =\n        commandResults.resultingFiles\n        .Where(file => !elmCodeFiles.ContainsKey(file.path))\n        .Select(file => new FileWithPath\n        {\n            path = file.path,\n            contentBase64 = Convert.ToBase64String(file.content.ToArray()),\n        })\n        .ToImmutableList();\n\n    var outputFile =\n        newFiles\n        .Where(file => file.path.LastOrDefault() == elmMakeOutputFileName)\n        .FirstOrDefault();\n\n    var outputFileContentBase64 = outputFile?.contentBase64;\n\n    var processOutput = new ProcessOutput\n    {\n        standardOutput = commandResults.processOutput.StandardOutput,\n        standardError = commandResults.processOutput.StandardError,\n        exitCode = commandResults.processOutput.ExitCode,\n    };\n\n    var reportJsonCommandResults = commandResultsFromArguments(reportJsonCommandLineArguments);\n\n    var reportJsonProcessOutput = new ProcessOutput\n    {\n        standardOutput = reportJsonCommandResults.processOutput.StandardOutput,\n        standardError = reportJsonCommandResults.processOutput.StandardError,\n        exitCode = reportJsonCommandResults.processOutput.ExitCode,\n    };\n\n    var responseStructure = new ElmMakeResponseStructure\n    {\n        processOutput = processOutput,\n        outputFileContentBase64 = Maybe.NothingFromNull(outputFileContentBase64),\n        reportJsonProcessOutput = reportJsonProcessOutput,\n    };\n\n    return responseStructure;\n}\n\nstring MakePlatformSpecificPath(IReadOnlyList<string> path) =>\n    string.Join(System.IO.Path.DirectorySeparatorChar.ToString(), path);\n\nstatic public byte[] GetElmExecutableFile =>\n    BytesConversions.DecompressGzip(GetElmExecutableFileCompressedGzip).ToArray();\n\nstatic public byte[] GetElmExecutableFileCompressedGzip =>\n    Pine.BlobLibrary.GetBlobWithSHA256(Convert.FromHexString(\n        System.Runtime.InteropServices.RuntimeInformation.IsOSPlatform(System.Runtime.InteropServices.OSPlatform.Linux)\n        ?\n        /*\n        Loaded 2019-10-29 from\n        https://github.com/elm/compiler/releases/download/0.19.1/binary-for-linux-64-bit.gz\n        */\n        \"e44af52bb27f725a973478e589d990a6428e115fe1bb14f03833134d6c0f155c\"\n        :\n        /*\n        Loaded 2019-10-29 from\n        https://github.com/elm/compiler/releases/download/0.19.1/binary-for-windows-64-bit.gz\n        */\n        \"d1bf666298cbe3c5447b9ca0ea608552d750e5d232f9845c2af11907b654903b\"))\n    ?.ToArray();\n\nstatic public string overrideElmMakeHomeDirectory = null;\n\nstatic string elmHomeDirectory;\n\nstatic public string GetElmHomeDirectory()\n{\n    elmHomeDirectory =\n        overrideElmMakeHomeDirectory ??\n        elmHomeDirectory ??\n        System.IO.Path.Combine(Pine.Filesystem.CreateRandomDirectoryInTempDirectory(), \"elm-home\");\n\n    System.IO.Directory.CreateDirectory(elmHomeDirectory);\n    return elmHomeDirectory;\n}\n\nstatic public class ElmFormat\n{\n    static public FormatElmModuleTextResponseStructure FormatElmModuleText(string originalModuleText)\n    {\n        var elmModuleFileName = \"ElmModuleToFormat.elm\";\n\n        var elmModuleFilePath = ImmutableList.Create(elmModuleFileName);\n\n        var elmFormatResult =\n            Pine.ExecutableFile.ExecuteFileWithArguments(\n                ImmutableDictionary.Create<IReadOnlyList<string>, ReadOnlyMemory<byte>>()\n                .SetItem(elmModuleFilePath, System.Text.Encoding.UTF8.GetBytes(originalModuleText)),\n                GetElmFormatExecutableFile,\n                \" \" + elmModuleFileName + \" --yes\",\n                environmentStrings: null);\n\n        var resultingFiles =\n            elmFormatResult.resultingFiles\n            .Where(file => file.path.SequenceEqual(elmModuleFilePath))\n            .ToImmutableList();\n\n        var formattedText =\n            resultingFiles.Any() ?\n            System.Text.Encoding.UTF8.GetString(resultingFiles.First().content.Span)\n            :\n            null;\n\n        var processOutput = new ProcessOutput\n        {\n            standardOutput = elmFormatResult.processOutput.StandardOutput,\n            standardError = elmFormatResult.processOutput.StandardError,\n            exitCode = elmFormatResult.processOutput.ExitCode,\n        };\n\n        return new FormatElmModuleTextResponseStructure\n        {\n            processOutput = processOutput,\n            formattedText = Maybe.NothingFromNull(formattedText),\n        };\n    }\n\n    static public byte[] GetElmFormatExecutableFile =>\n        Pine.BlobLibrary.LoadFileForCurrentOs(ElmFormatExecutableFileByOs)\n        ?.content.ToArray();\n\n    static public IReadOnlyDictionary<System.Runtime.InteropServices.OSPlatform, (string hash, string remoteSource)> ElmFormatExecutableFileByOs =\n        ImmutableDictionary<System.Runtime.InteropServices.OSPlatform, (string hash, string remoteSource)>.Empty\n        .Add(\n            System.Runtime.InteropServices.OSPlatform.Linux,\n            (\"9acdd1006b9e4720f48cdbbb12f16262625c2a56145d56239f9c7b9a50ed0db4\",\n            @\"https://github.com/avh4/elm-format/releases/download/0.8.7/elm-format-0.8.7-linux-x64.tgz\"))\n        .Add(\n            System.Runtime.InteropServices.OSPlatform.Windows,\n            (\"57b8f899f16e879338a6f0d898a13e28c440ab3947b173197de82048e3b520d6\",\n            @\"https://github.com/avh4/elm-format/releases/download/0.8.7/elm-format-0.8.7-win-x64.zip\"))\n        .Add(\n            System.Runtime.InteropServices.OSPlatform.OSX,\n            (\"364469d9b64866e0595c9c2837eb330eeb1c58269d31567085fa24886b5a46d7\",\n            @\"https://github.com/avh4/elm-format/releases/download/0.8.7/elm-format-0.8.7-mac-x64.tgz\"));\n\n}\n\nstring InterfaceToHost_Request(string request)\n{\n    return GetSerialResponseFromSerialRequest(request);\n}\n" }

file_tree_node_elm_core_modules_explicit_import =
    TreeNode
        [( "Array.elm"
        , BlobNode ({ utf8 = "module Array\n    exposing\n        ( Array\n        , empty\n        , isEmpty\n        , length\n        , initialize\n        , repeat\n        , fromList\n        , get\n        , set\n        , push\n        , toList\n        , toIndexedList\n        , foldr\n        , foldl\n        , filter\n        , map\n        , indexedMap\n        , append\n        , slice\n        )\n\n{-| Fast immutable arrays. The elements in an array must have the same type.\n\n# Arrays\n@docs Array\n\n# Creation\n@docs empty, initialize, repeat, fromList\n\n# Query\n@docs isEmpty, length, get\n\n# Manipulate\n@docs set, push, append, slice\n\n# Lists\n@docs toList, toIndexedList\n\n# Transform\n@docs map, indexedMap, foldl, foldr, filter\n-}\n\n\nimport Basics exposing (..)\nimport Bitwise\nimport Elm.JsArray as JsArray exposing (JsArray)\nimport List exposing ((::))\nimport Maybe exposing (..)\nimport Tuple\n\n\n{-| The array in this module is implemented as a tree with a high branching\nfactor (number of elements at each level). In comparision, the `Dict` has\na branching factor of 2 (left or right).\n\nThe higher the branching factor, the more elements are stored at each level.\nThis makes writes slower (more to copy per level), but reads faster\n(fewer traversals). In practice, 32 is a good compromise.\n\nThe branching factor has to be a power of two (8, 16, 32, 64...). This is\nbecause we use the index to tell us which path to take when navigating the\ntree, and we do this by dividing it into several smaller numbers (see\n`shiftStep` documentation). By dividing the index into smaller numbers, we\nwill always get a range which is a power of two (2 bits gives 0-3, 3 gives\n0-7, 4 gives 0-15...).\n-}\nbranchFactor : Int\nbranchFactor =\n    32\n\n\n{-| A number is made up of several bits. For bitwise operations in javascript,\nnumbers are treated as 32-bits integers. The number 1 is represented by 31\nzeros, and a one. The important thing to take from this, is that a 32-bit\ninteger has enough information to represent several smaller numbers.\n\nFor a branching factor of 32, a 32-bit index has enough information to store 6\ndifferent numbers in the range of 0-31 (5 bits), and one number in the range of\n0-3 (2 bits). This means that the tree of an array can have, at most, a depth\nof 7.\n\nAn index essentially functions as a map. To figure out which branch to take at\nany given level of the tree, we need to shift (or move) the correct amount of\nbits so that those bits are at the front. We can then perform a bitwise and to\nread which of the 32 branches to take.\n\nThe `shiftStep` specifices how many bits are required to represent the branching\nfactor.\n-}\nshiftStep : Int\nshiftStep =\n    ceiling (logBase 2 (toFloat branchFactor))\n\n\n{-| A mask which, when used in a bitwise and, reads the first `shiftStep` bits\nin a number as a number of its own.\n-}\nbitMask : Int\nbitMask =\n    Bitwise.shiftRightZfBy (32 - shiftStep) 0xFFFFFFFF\n\n\n{-| Representation of fast immutable arrays. You can create arrays of integers\n(`Array Int`) or strings (`Array String`) or any other type of value you can\ndream up.\n-}\ntype Array a\n    = {-\n         * length : Int = The length of the array.\n         * startShift : Int = How many bits to shift the index to get the\n         slot for the first level of the tree.\n         * tree : Tree a = The actual tree.\n         * tail : JsArray a = The tail of the array. Inserted into tree when\n         number of elements is equal to the branching factor. This is an\n         optimization. It makes operations at the end (push, pop, read, write)\n         fast.\n      -}\n      Array_elm_builtin Int Int (Tree a) (JsArray a)\n\n\n{-| Each level in the tree is represented by a `JsArray` of `Node`s.\nA `Node` can either be a subtree (the next level of the tree) or, if\nwe're at the bottom, a `JsArray` of values (also known as a leaf).\n-}\ntype Node a\n    = SubTree (Tree a)\n    | Leaf (JsArray a)\n\n\ntype alias Tree a =\n    JsArray (Node a)\n\n\n{-| Return an empty array.\n\n    length empty == 0\n-}\nempty : Array a\nempty =\n    {-\n       `startShift` is only used when there is at least one `Node` in the\n       `tree`. The minimal value is therefore equal to the `shiftStep`.\n    -}\n    Array_elm_builtin 0 shiftStep JsArray.empty JsArray.empty\n\n\n{-| Determine if an array is empty.\n\n    isEmpty empty == True\n-}\nisEmpty : Array a -> Bool\nisEmpty (Array_elm_builtin len _ _ _) =\n    len == 0\n\n\n{-| Return the length of an array.\n\n    length (fromList [1,2,3]) == 3\n-}\nlength : Array a -> Int\nlength (Array_elm_builtin len _ _ _) =\n    len\n\n\n{-| Initialize an array. `initialize n f` creates an array of length `n` with\nthe element at index `i` initialized to the result of `(f i)`.\n\n    initialize 4 identity    == fromList [0,1,2,3]\n    initialize 4 (\\n -> n*n) == fromList [0,1,4,9]\n    initialize 4 (always 0)  == fromList [0,0,0,0]\n-}\ninitialize : Int -> (Int -> a) -> Array a\ninitialize len fn =\n    if len <= 0 then\n        empty\n    else\n        let\n            tailLen =\n                remainderBy branchFactor len\n\n            tail =\n                JsArray.initialize tailLen (len - tailLen) fn\n\n            initialFromIndex =\n                len - tailLen - branchFactor\n        in\n            initializeHelp fn initialFromIndex len [] tail\n\n\ninitializeHelp : (Int -> a) -> Int -> Int -> List (Node a) -> JsArray a -> Array a\ninitializeHelp fn fromIndex len nodeList tail =\n    if fromIndex < 0 then\n        builderToArray False\n            { tail = tail\n            , nodeList = nodeList\n            , nodeListSize = len // branchFactor\n            }\n    else\n        let\n            leaf =\n                Leaf <| JsArray.initialize branchFactor fromIndex fn\n        in\n            initializeHelp\n                fn\n                (fromIndex - branchFactor)\n                len\n                (leaf :: nodeList)\n                tail\n\n\n{-| Creates an array with a given length, filled with a default element.\n\n    repeat 5 0     == fromList [0,0,0,0,0]\n    repeat 3 \"cat\" == fromList [\"cat\",\"cat\",\"cat\"]\n\nNotice that `repeat 3 x` is the same as `initialize 3 (always x)`.\n-}\nrepeat : Int -> a -> Array a\nrepeat n e =\n    initialize n (\\_ -> e)\n\n\n{-| Create an array from a `List`.\n-}\nfromList : List a -> Array a\nfromList list =\n    case list of\n        [] ->\n            empty\n\n        _ ->\n            fromListHelp list [] 0\n\n\nfromListHelp : List a -> List (Node a) -> Int -> Array a\nfromListHelp list nodeList nodeListSize =\n    let\n        ( jsArray, remainingItems ) =\n            JsArray.initializeFromList branchFactor list\n    in\n        if JsArray.length jsArray < branchFactor then\n            builderToArray True\n                { tail = jsArray\n                , nodeList = nodeList\n                , nodeListSize = nodeListSize\n                }\n        else\n            fromListHelp\n                remainingItems\n                (Leaf jsArray :: nodeList)\n                (nodeListSize + 1)\n\n\n{-| Return `Just` the element at the index or `Nothing` if the index is out of\nrange.\n\n    get  0 (fromList [0,1,2]) == Just 0\n    get  2 (fromList [0,1,2]) == Just 2\n    get  5 (fromList [0,1,2]) == Nothing\n    get -1 (fromList [0,1,2]) == Nothing\n-}\nget : Int -> Array a -> Maybe a\nget index (Array_elm_builtin len startShift tree tail) =\n    if index < 0 || index >= len then\n        Nothing\n    else if index >= tailIndex len then\n        Just <| JsArray.unsafeGet (Bitwise.and bitMask index) tail\n    else\n        Just <| getHelp startShift index tree\n\n\ngetHelp : Int -> Int -> Tree a -> a\ngetHelp shift index tree =\n    let\n        pos =\n            Bitwise.and bitMask <| Bitwise.shiftRightZfBy shift index\n    in\n        case JsArray.unsafeGet pos tree of\n            SubTree subTree ->\n                getHelp (shift - shiftStep) index subTree\n\n            Leaf values ->\n                JsArray.unsafeGet (Bitwise.and bitMask index) values\n\n\n{-| Given an array length, return the index of the first element in the tail.\nCommonly used to check if a given index references something in the tail.\n-}\ntailIndex : Int -> Int\ntailIndex len =\n    len\n        |> Bitwise.shiftRightZfBy 5\n        |> Bitwise.shiftLeftBy 5\n\n\n{-| Set the element at a particular index. Returns an updated array.\nIf the index is out of range, the array is unaltered.\n\n    set 1 7 (fromList [1,2,3]) == fromList [1,7,3]\n-}\nset : Int -> a -> Array a -> Array a\nset index value ((Array_elm_builtin len startShift tree tail) as array) =\n    if index < 0 || index >= len then\n        array\n    else if index >= tailIndex len then\n        Array_elm_builtin len startShift tree <|\n            JsArray.unsafeSet (Bitwise.and bitMask index) value tail\n    else\n        Array_elm_builtin\n            len\n            startShift\n            (setHelp startShift index value tree)\n            tail\n\n\nsetHelp : Int -> Int -> a -> Tree a -> Tree a\nsetHelp shift index value tree =\n    let\n        pos =\n            Bitwise.and bitMask <| Bitwise.shiftRightZfBy shift index\n    in\n        case JsArray.unsafeGet pos tree of\n            SubTree subTree ->\n                let\n                    newSub =\n                        setHelp (shift - shiftStep) index value subTree\n                in\n                    JsArray.unsafeSet pos (SubTree newSub) tree\n\n            Leaf values ->\n                let\n                    newLeaf =\n                        JsArray.unsafeSet (Bitwise.and bitMask index) value values\n                in\n                    JsArray.unsafeSet pos (Leaf newLeaf) tree\n\n\n{-| Push an element onto the end of an array.\n\n    push 3 (fromList [1,2]) == fromList [1,2,3]\n-}\npush : a -> Array a -> Array a\npush a ((Array_elm_builtin _ _ _ tail) as array) =\n    unsafeReplaceTail (JsArray.push a tail) array\n\n\n{-| Replaces the tail of an array. If the length of the tail equals the\n`branchFactor`, it is inserted into the tree, and the tail cleared.\n\nWARNING: For performance reasons, this function does not check if the new tail\nhas a length equal to or beneath the `branchFactor`. Make sure this is the case\nbefore using this function.\n-}\nunsafeReplaceTail : JsArray a -> Array a -> Array a\nunsafeReplaceTail newTail (Array_elm_builtin len startShift tree tail) =\n    let\n        originalTailLen =\n            JsArray.length tail\n\n        newTailLen =\n            JsArray.length newTail\n\n        newArrayLen =\n            len + (newTailLen - originalTailLen)\n    in\n        if newTailLen == branchFactor then\n            let\n                overflow =\n                    Bitwise.shiftRightZfBy shiftStep newArrayLen > Bitwise.shiftLeftBy startShift 1\n            in\n                if overflow then\n                    let\n                        newShift =\n                            startShift + shiftStep\n\n                        newTree =\n                            JsArray.singleton (SubTree tree)\n                                |> insertTailInTree newShift len newTail\n                    in\n                        Array_elm_builtin\n                            newArrayLen\n                            newShift\n                            newTree\n                            JsArray.empty\n                else\n                    Array_elm_builtin\n                        newArrayLen\n                        startShift\n                        (insertTailInTree startShift len newTail tree)\n                        JsArray.empty\n        else\n            Array_elm_builtin\n                newArrayLen\n                startShift\n                tree\n                newTail\n\n\ninsertTailInTree : Int -> Int -> JsArray a -> Tree a -> Tree a\ninsertTailInTree shift index tail tree =\n    let\n        pos =\n            Bitwise.and bitMask <| Bitwise.shiftRightZfBy shift index\n    in\n        if pos >= JsArray.length tree then\n            if shift == 5 then\n                JsArray.push (Leaf tail) tree\n            else\n                let\n                    newSub =\n                        JsArray.empty\n                            |> insertTailInTree (shift - shiftStep) index tail\n                            |> SubTree\n                in\n                    JsArray.push newSub tree\n        else\n            let\n                value =\n                    JsArray.unsafeGet pos tree\n            in\n                case value of\n                    SubTree subTree ->\n                        let\n                            newSub =\n                                subTree\n                                    |> insertTailInTree (shift - shiftStep) index tail\n                                    |> SubTree\n                        in\n                            JsArray.unsafeSet pos newSub tree\n\n                    Leaf _ ->\n                        let\n                            newSub =\n                                JsArray.singleton value\n                                    |> insertTailInTree (shift - shiftStep) index tail\n                                    |> SubTree\n                        in\n                            JsArray.unsafeSet pos newSub tree\n\n\n{-| Create a list of elements from an array.\n\n    toList (fromList [3,5,8]) == [3,5,8]\n-}\ntoList : Array a -> List a\ntoList array =\n    foldr (::) [] array\n\n\n{-| Create an indexed list from an array. Each element of the array will be\npaired with its index.\n\n    toIndexedList (fromList [\"cat\",\"dog\"]) == [(0,\"cat\"), (1,\"dog\")]\n-}\ntoIndexedList : Array a -> List ( Int, a )\ntoIndexedList ((Array_elm_builtin len _ _ _) as array) =\n    let\n        helper entry ( index, list ) =\n            ( index - 1, (index,entry) :: list )\n    in\n        Tuple.second (foldr helper ( len - 1, [] ) array)\n\n\n{-| Reduce an array from the right. Read `foldr` as fold from the right.\n\n    foldr (+) 0 (repeat 3 5) == 15\n-}\nfoldr : (a -> b -> b) -> b -> Array a -> b\nfoldr func baseCase (Array_elm_builtin _ _ tree tail) =\n    let\n        helper node acc =\n            case node of\n                SubTree subTree ->\n                    JsArray.foldr helper acc subTree\n\n                Leaf values ->\n                    JsArray.foldr func acc values\n    in\n        JsArray.foldr helper (JsArray.foldr func baseCase tail) tree\n\n\n{-| Reduce an array from the left. Read `foldl` as fold from the left.\n\n    foldl (::) [] (fromList [1,2,3]) == [3,2,1]\n-}\nfoldl : (a -> b -> b) -> b -> Array a -> b\nfoldl func baseCase (Array_elm_builtin _ _ tree tail) =\n    let\n        helper node acc =\n            case node of\n                SubTree subTree ->\n                    JsArray.foldl helper acc subTree\n\n                Leaf values ->\n                    JsArray.foldl func acc values\n    in\n        JsArray.foldl func (JsArray.foldl helper baseCase tree) tail\n\n\n{-| Keep elements that pass the test.\n\n    filter isEven (fromList [1,2,3,4,5,6]) == (fromList [2,4,6])\n-}\nfilter : (a -> Bool) -> Array a -> Array a\nfilter isGood array =\n    fromList (foldr (\\x xs -> if isGood x then x :: xs else xs) [] array)\n\n\n{-| Apply a function on every element in an array.\n\n    map sqrt (fromList [1,4,9]) == fromList [1,2,3]\n-}\nmap : (a -> b) -> Array a -> Array b\nmap func (Array_elm_builtin len startShift tree tail) =\n    let\n        helper node =\n            case node of\n                SubTree subTree ->\n                    SubTree <| JsArray.map helper subTree\n\n                Leaf values ->\n                    Leaf <| JsArray.map func values\n    in\n        Array_elm_builtin\n            len\n            startShift\n            (JsArray.map helper tree)\n            (JsArray.map func tail)\n\n\n{-| Apply a function on every element with its index as first argument.\n\n    indexedMap (*) (fromList [5,5,5]) == fromList [0,5,10]\n-}\nindexedMap : (Int -> a -> b) -> Array a -> Array b\nindexedMap func (Array_elm_builtin len _ tree tail) =\n    let\n        helper node builder =\n            case node of\n                SubTree subTree ->\n                    JsArray.foldl helper builder subTree\n\n                Leaf leaf ->\n                    let\n                        offset =\n                            builder.nodeListSize * branchFactor\n\n                        mappedLeaf =\n                            Leaf <| JsArray.indexedMap func offset leaf\n                    in\n                        { tail = builder.tail\n                        , nodeList = mappedLeaf :: builder.nodeList\n                        , nodeListSize = builder.nodeListSize + 1\n                        }\n\n        initialBuilder =\n            { tail = JsArray.indexedMap func (tailIndex len) tail\n            , nodeList = []\n            , nodeListSize = 0\n            }\n    in\n        builderToArray True (JsArray.foldl helper initialBuilder tree)\n\n\n{-| Append two arrays to a new one.\n\n    append (repeat 2 42) (repeat 3 81) == fromList [42,42,81,81,81]\n-}\nappend : Array a -> Array a -> Array a\nappend ((Array_elm_builtin _ _ _ aTail) as a) (Array_elm_builtin bLen _ bTree bTail) =\n    -- The magic number 4 has been found with benchmarks\n    if bLen <= (branchFactor * 4) then\n        let\n            foldHelper node array =\n                case node of\n                    SubTree tree ->\n                        JsArray.foldl foldHelper array tree\n\n                    Leaf leaf ->\n                        appendHelpTree leaf array\n        in\n            JsArray.foldl foldHelper a bTree\n                |> appendHelpTree bTail\n    else\n        let\n            foldHelper node builder =\n                case node of\n                    SubTree tree ->\n                        JsArray.foldl foldHelper builder tree\n\n                    Leaf leaf ->\n                        appendHelpBuilder leaf builder\n        in\n            JsArray.foldl foldHelper (builderFromArray a) bTree\n                |> appendHelpBuilder bTail\n                |> builderToArray True\n\n\nappendHelpTree : JsArray a -> Array a -> Array a\nappendHelpTree toAppend ((Array_elm_builtin len _ tree tail) as array) =\n    let\n        appended =\n            JsArray.appendN branchFactor tail toAppend\n\n        itemsToAppend =\n            JsArray.length toAppend\n\n        notAppended =\n            branchFactor - (JsArray.length tail) - itemsToAppend\n\n        newArray =\n            unsafeReplaceTail appended array\n    in\n        if notAppended < 0 then\n            let\n                nextTail =\n                    JsArray.slice notAppended itemsToAppend toAppend\n            in\n                unsafeReplaceTail nextTail newArray\n        else\n            newArray\n\n\nappendHelpBuilder : JsArray a -> Builder a -> Builder a\nappendHelpBuilder tail builder =\n    let\n        appended =\n            JsArray.appendN branchFactor builder.tail tail\n\n        tailLen =\n            JsArray.length tail\n\n        notAppended =\n            branchFactor - (JsArray.length builder.tail) - tailLen\n    in\n        if notAppended < 0 then\n            { tail = JsArray.slice notAppended tailLen tail\n            , nodeList = Leaf appended :: builder.nodeList\n            , nodeListSize = builder.nodeListSize + 1\n            }\n        else if notAppended == 0 then\n            { tail = JsArray.empty\n            , nodeList = Leaf appended :: builder.nodeList\n            , nodeListSize = builder.nodeListSize + 1\n            }\n        else\n            { tail = appended\n            , nodeList = builder.nodeList\n            , nodeListSize = builder.nodeListSize\n            }\n\n\n{-| Get a sub-section of an array: `(slice start end array)`. The `start` is a\nzero-based index where we will start our slice. The `end` is a zero-based index\nthat indicates the end of the slice. The slice extracts up to but not including\n`end`.\n\n    slice  0  3 (fromList [0,1,2,3,4]) == fromList [0,1,2]\n    slice  1  4 (fromList [0,1,2,3,4]) == fromList [1,2,3]\n\nBoth the `start` and `end` indexes can be negative, indicating an offset from\nthe end of the array.\n\n    slice  1 -1 (fromList [0,1,2,3,4]) == fromList [1,2,3]\n    slice -2  5 (fromList [0,1,2,3,4]) == fromList [3,4]\n\nThis makes it pretty easy to `pop` the last element off of an array:\n`slice 0 -1 array`\n-}\nslice : Int -> Int -> Array a -> Array a\nslice from to array =\n    let\n        correctFrom =\n            translateIndex from array\n\n        correctTo =\n            translateIndex to array\n    in\n        if correctFrom > correctTo then\n            empty\n        else\n            array\n                |> sliceRight correctTo\n                |> sliceLeft correctFrom\n\n\n{-| Given a relative array index, convert it into an absolute one.\n\n    translateIndex -1 someArray == someArray.length - 1\n    translateIndex -10 someArray == someArray.length - 10\n    translateIndex 5 someArray == 5\n-}\ntranslateIndex : Int -> Array a -> Int\ntranslateIndex index (Array_elm_builtin len _ _ _) =\n    let\n        posIndex =\n            if index < 0 then\n                len + index\n            else\n                index\n    in\n        if posIndex < 0 then\n            0\n        else if posIndex > len then\n            len\n        else\n            posIndex\n\n\n{-| This function slices the tree from the right.\n\nFirst, two things are tested:\n1. If the array does not need slicing, return the original array.\n2. If the array can be sliced by only slicing the tail, slice the tail.\n\nOtherwise, we do the following:\n1. Find the new tail in the tree, promote it to the root tail position and\nslice it.\n2. Slice every sub tree.\n3. Promote subTrees until the tree has the correct height.\n-}\nsliceRight : Int -> Array a -> Array a\nsliceRight end ((Array_elm_builtin len startShift tree tail) as array) =\n    if end == len then\n        array\n    else if end >= tailIndex len then\n        Array_elm_builtin end startShift tree <|\n            JsArray.slice 0 (Bitwise.and bitMask end) tail\n    else\n        let\n            endIdx =\n                tailIndex end\n\n            depth =\n                (endIdx - 1)\n                    |> max 1\n                    |> toFloat\n                    |> logBase (toFloat branchFactor)\n                    |> floor\n\n            newShift =\n                max 5 <| depth * shiftStep\n        in\n            Array_elm_builtin\n                end\n                newShift\n                (tree\n                    |> sliceTree startShift endIdx\n                    |> hoistTree startShift newShift\n                )\n                (fetchNewTail startShift end endIdx tree)\n\n\n{-| Slice and return the `Leaf` node after what is to be the last node\nin the sliced tree.\n-}\nfetchNewTail : Int -> Int -> Int -> Tree a -> JsArray a\nfetchNewTail shift end treeEnd tree =\n    let\n        pos =\n            Bitwise.and bitMask <| Bitwise.shiftRightZfBy shift treeEnd\n    in\n        case JsArray.unsafeGet pos tree of\n            SubTree sub ->\n                fetchNewTail (shift - shiftStep) end treeEnd sub\n\n            Leaf values ->\n                JsArray.slice 0 (Bitwise.and bitMask end) values\n\n\n{-| Shorten the root `Node` of the tree so it is long enough to contain\nthe `Node` indicated by `endIdx`. Then recursively perform the same operation\nto the last node of each `SubTree`.\n-}\nsliceTree : Int -> Int -> Tree a -> Tree a\nsliceTree shift endIdx tree =\n    let\n        lastPos =\n            Bitwise.and bitMask <| Bitwise.shiftRightZfBy shift endIdx\n    in\n        case JsArray.unsafeGet lastPos tree of\n            SubTree sub ->\n                let\n                    newSub =\n                        sliceTree (shift - shiftStep) endIdx sub\n                in\n                    if JsArray.length newSub == 0 then\n                        -- The sub is empty, slice it away\n                        JsArray.slice 0 lastPos tree\n                    else\n                        tree\n                            |> JsArray.slice 0 (lastPos + 1)\n                            |> JsArray.unsafeSet lastPos (SubTree newSub)\n\n            -- This is supposed to be the new tail. Fetched by `fetchNewTail`.\n            -- Slice up to, but not including, this point.\n            Leaf _ ->\n                JsArray.slice 0 lastPos tree\n\n\n{-| The tree is supposed to be of a certain depth. Since slicing removes\nelements, it could be that the tree should have a smaller depth\nthan it had originally. This function shortens the height if it is necessary\nto do so.\n-}\nhoistTree : Int -> Int -> Tree a -> Tree a\nhoistTree oldShift newShift tree =\n    if oldShift <= newShift || JsArray.length tree == 0 then\n        tree\n    else\n        case JsArray.unsafeGet 0 tree of\n            SubTree sub ->\n                hoistTree (oldShift - shiftStep) newShift sub\n\n            Leaf _ ->\n                tree\n\n\n{-| This function slices the tree from the left. Such an operation will change\nthe index of every element after the slice. Which means that we will have to\nrebuild the array.\n\nFirst, two things are tested:\n1. If the array does not need slicing, return the original array.\n2. If the slice removes every element but those in the tail, slice the tail and\nset the tree to the empty array.\n\nOtherwise, we do the following:\n1. Add every leaf node in the tree to a list.\n2. Drop the nodes which are supposed to be sliced away.\n3. Slice the head node of the list, which represents the start of the new array.\n4. Create a builder with the tail set as the node from the previous step.\n5. Append the remaining nodes into this builder, and create the array.\n-}\nsliceLeft : Int -> Array a -> Array a\nsliceLeft from ((Array_elm_builtin len _ tree tail) as array) =\n    if from == 0 then\n        array\n    else if from >= tailIndex len then\n        Array_elm_builtin (len - from) shiftStep JsArray.empty <|\n            JsArray.slice (from - tailIndex len) (JsArray.length tail) tail\n    else\n        let\n            helper node acc =\n                case node of\n                    SubTree subTree ->\n                        JsArray.foldr helper acc subTree\n\n                    Leaf leaf ->\n                        leaf :: acc\n\n            leafNodes =\n                JsArray.foldr helper [ tail ] tree\n\n            skipNodes =\n                from // branchFactor\n\n            nodesToInsert =\n                List.drop skipNodes leafNodes\n        in\n            case nodesToInsert of\n                [] ->\n                    empty\n\n                head :: rest ->\n                    let\n                        firstSlice =\n                            from - (skipNodes * branchFactor)\n\n                        initialBuilder =\n                            { tail =\n                                JsArray.slice\n                                    firstSlice\n                                    (JsArray.length head)\n                                    head\n                            , nodeList = []\n                            , nodeListSize = 0\n                            }\n                    in\n                        List.foldl appendHelpBuilder initialBuilder rest\n                            |> builderToArray True\n\n\n{-| A builder contains all information necessary to build an array. Adding\ninformation to the builder is fast. A builder is therefore a suitable\nintermediary for constructing arrays.\n-}\ntype alias Builder a =\n    { tail : JsArray a\n    , nodeList : List (Node a)\n    , nodeListSize : Int\n    }\n\n\n{-| The empty builder.\n-}\nemptyBuilder : Builder a\nemptyBuilder =\n    { tail = JsArray.empty\n    , nodeList = []\n    , nodeListSize = 0\n    }\n\n\n{-| Converts an array to a builder.\n-}\nbuilderFromArray : Array a -> Builder a\nbuilderFromArray (Array_elm_builtin len _ tree tail) =\n    let\n        helper node acc =\n            case node of\n                SubTree subTree ->\n                    JsArray.foldl helper acc subTree\n\n                Leaf _ ->\n                    node :: acc\n    in\n        { tail = tail\n        , nodeList = JsArray.foldl helper [] tree\n        , nodeListSize = len // branchFactor\n        }\n\n\n{-| Construct an array with the information in a given builder.\n\nDue to the nature of `List` the list of nodes in a builder will often\nbe in reverse order (that is, the first leaf of the array is the last\nnode in the node list). This function therefore allows the caller to\nspecify if the node list should be reversed before building the array.\n-}\nbuilderToArray : Bool -> Builder a -> Array a\nbuilderToArray reverseNodeList builder =\n    if builder.nodeListSize == 0 then\n        Array_elm_builtin\n            (JsArray.length builder.tail)\n            shiftStep\n            JsArray.empty\n            builder.tail\n    else\n        let\n            treeLen =\n                builder.nodeListSize * branchFactor\n\n            depth =\n                (treeLen - 1)\n                    |> toFloat\n                    |> logBase (toFloat branchFactor)\n                    |> floor\n\n            correctNodeList =\n                if reverseNodeList then\n                    List.reverse builder.nodeList\n                else\n                    builder.nodeList\n\n            tree =\n                treeFromBuilder correctNodeList builder.nodeListSize\n        in\n            Array_elm_builtin\n                (JsArray.length builder.tail + treeLen)\n                (max 5 <| depth * shiftStep)\n                tree\n                builder.tail\n\n\n{-| Takes a list of leaves and an `Int` specifying how many leaves there are,\nand builds a tree structure to be used in an `Array`.\n-}\ntreeFromBuilder : List (Node a) -> Int -> Tree a\ntreeFromBuilder nodeList nodeListSize =\n    let\n        newNodeSize =\n            ((toFloat nodeListSize) / (toFloat branchFactor))\n                |> ceiling\n    in\n        if newNodeSize == 1 then\n            JsArray.initializeFromList branchFactor nodeList\n                |> Tuple.first\n        else\n            treeFromBuilder\n                (compressNodes nodeList [])\n                newNodeSize\n\n\n{-| Takes a list of nodes and return a list of `SubTree`s containing those\nnodes.\n-}\ncompressNodes : List (Node a) -> List (Node a) -> List (Node a)\ncompressNodes nodes acc =\n    let\n        ( node, remainingNodes ) =\n            JsArray.initializeFromList branchFactor nodes\n\n        newAcc =\n            (SubTree node) :: acc\n    in\n        case remainingNodes of\n            [] ->\n                List.reverse newAcc\n\n            _ ->\n                compressNodes remainingNodes newAcc\n" })
        )
        ,( "Bitwise.elm"
        , BlobNode ({ utf8 = "module Bitwise exposing\n  ( and, or, xor, complement\n  , shiftLeftBy, shiftRightBy, shiftRightZfBy\n  )\n\n{-| Library for [bitwise operations](https://en.wikipedia.org/wiki/Bitwise_operation).\n\n# Basic Operations\n@docs and, or, xor, complement\n\n# Bit Shifts\n@docs shiftLeftBy, shiftRightBy, shiftRightZfBy\n-}\n\n\nimport Basics exposing (Int)\nimport Elm.Kernel.Bitwise\n\n\n\n{-| Bitwise AND\n-}\nand : Int -> Int -> Int\nand =\n  Elm.Kernel.Bitwise.and\n\n\n{-| Bitwise OR\n-}\nor : Int -> Int -> Int\nor =\n  Elm.Kernel.Bitwise.or\n\n\n{-| Bitwise XOR\n-}\nxor : Int -> Int -> Int\nxor =\n  Elm.Kernel.Bitwise.xor\n\n\n{-| Flip each bit individually, often called bitwise NOT\n-}\ncomplement : Int -> Int\ncomplement =\n  Elm.Kernel.Bitwise.complement\n\n\n{-| Shift bits to the left by a given offset, filling new bits with zeros.\nThis can be used to multiply numbers by powers of two.\n\n    shiftLeftBy 1 5 == 10\n    shiftLeftBy 5 1 == 32\n-}\nshiftLeftBy : Int -> Int -> Int\nshiftLeftBy =\n  Elm.Kernel.Bitwise.shiftLeftBy\n\n\n{-| Shift bits to the right by a given offset, filling new bits with\nwhatever is the topmost bit. This can be used to divide numbers by powers of two.\n\n    shiftRightBy 1  32 == 16\n    shiftRightBy 2  32 == 8\n    shiftRightBy 1 -32 == -16\n\nThis is called an [arithmetic right shift][ars], often written `>>`, and\nsometimes called a sign-propagating right shift because it fills empty spots\nwith copies of the highest bit.\n\n[ars]: https://en.wikipedia.org/wiki/Bitwise_operation#Arithmetic_shift\n-}\nshiftRightBy : Int -> Int -> Int\nshiftRightBy =\n  Elm.Kernel.Bitwise.shiftRightBy\n\n\n{-| Shift bits to the right by a given offset, filling new bits with zeros.\n\n    shiftRightZfBy 1  32 == 16\n    shiftRightZfBy 2  32 == 8\n    shiftRightZfBy 1 -32 == 2147483632\n\nThis is called an [logical right shift][lrs], often written `>>>`, and\nsometimes called a zero-fill right shift because it fills empty spots with\nzeros.\n\n[lrs]: https://en.wikipedia.org/wiki/Bitwise_operation#Logical_shift\n-}\nshiftRightZfBy : Int -> Int -> Int\nshiftRightZfBy =\n  Elm.Kernel.Bitwise.shiftRightZfBy\n\n" })
        )
        ,( "Dict.elm"
        , BlobNode ({ utf8 = "module Dict exposing\n  ( Dict\n  , empty, singleton, insert, update, remove\n  , isEmpty, member, get, size\n  , keys, values, toList, fromList\n  , map, foldl, foldr, filter, partition\n  , union, intersect, diff, merge\n  )\n\n{-| A dictionary mapping unique keys to values. The keys can be any comparable\ntype. This includes `Int`, `Float`, `Time`, `Char`, `String`, and tuples or\nlists of comparable types.\n\nInsert, remove, and query operations all take *O(log n)* time.\n\n# Dictionaries\n@docs Dict\n\n# Build\n@docs empty, singleton, insert, update, remove\n\n# Query\n@docs isEmpty, member, get, size\n\n# Lists\n@docs keys, values, toList, fromList\n\n# Transform\n@docs map, foldl, foldr, filter, partition\n\n# Combine\n@docs union, intersect, diff, merge\n\n-}\n\n\nimport Basics exposing (..)\nimport Maybe exposing (..)\nimport List exposing (..)\n\n\n\n-- DICTIONARIES\n\n\n-- The color of a node. Leaves are considered Black.\ntype NColor\n    = Red\n    | Black\n\n\n{-| A dictionary of keys and values. So a `Dict String User` is a dictionary\nthat lets you look up a `String` (such as user names) and find the associated\n`User`.\n\n    import Dict exposing (Dict)\n\n    users : Dict String User\n    users =\n      Dict.fromList\n        [ (\"Alice\", User \"Alice\" 28 1.65)\n        , (\"Bob\"  , User \"Bob\"   19 1.82)\n        , (\"Chuck\", User \"Chuck\" 33 1.75)\n        ]\n\n    type alias User =\n      { name : String\n      , age : Int\n      , height : Float\n      }\n-}\ntype Dict k v\n    = RBNode_elm_builtin NColor k v (Dict k v) (Dict k v)\n    | RBEmpty_elm_builtin\n\n\n{-| Create an empty dictionary. -}\nempty : Dict k v\nempty =\n  RBEmpty_elm_builtin\n\n\n{-| Get the value associated with a key. If the key is not found, return\n`Nothing`. This is useful when you are not sure if a key will be in the\ndictionary.\n\n    animals = fromList [ (\"Tom\", Cat), (\"Jerry\", Mouse) ]\n\n    get \"Tom\"   animals == Just Cat\n    get \"Jerry\" animals == Just Mouse\n    get \"Spike\" animals == Nothing\n\n-}\nget : comparable -> Dict comparable v -> Maybe v\nget targetKey dict =\n  case dict of\n    RBEmpty_elm_builtin ->\n      Nothing\n\n    RBNode_elm_builtin _ key value left right ->\n      case compare targetKey key of\n        LT ->\n          get targetKey left\n\n        EQ ->\n          Just value\n\n        GT ->\n          get targetKey right\n\n\n{-| Determine if a key is in a dictionary. -}\nmember : comparable -> Dict comparable v -> Bool\nmember key dict =\n  case get key dict of\n    Just _ ->\n      True\n\n    Nothing ->\n      False\n\n\n{-| Determine the number of key-value pairs in the dictionary. -}\nsize : Dict k v -> Int\nsize dict =\n  sizeHelp 0 dict\n\n\nsizeHelp : Int -> Dict k v -> Int\nsizeHelp n dict =\n  case dict of\n    RBEmpty_elm_builtin ->\n      n\n\n    RBNode_elm_builtin _ _ _ left right ->\n      sizeHelp (sizeHelp (n+1) right) left\n\n\n{-| Determine if a dictionary is empty.\n\n    isEmpty empty == True\n-}\nisEmpty : Dict k v -> Bool\nisEmpty dict =\n  case dict of\n    RBEmpty_elm_builtin ->\n      True\n\n    RBNode_elm_builtin _ _ _ _ _ ->\n      False\n\n\n{-| Insert a key-value pair into a dictionary. Replaces value when there is\na collision. -}\ninsert : comparable -> v -> Dict comparable v -> Dict comparable v\ninsert key value dict =\n  -- Root node is always Black\n  case insertHelp key value dict of\n    RBNode_elm_builtin Red k v l r ->\n      RBNode_elm_builtin Black k v l r\n\n    x ->\n      x\n\n\ninsertHelp : comparable -> v -> Dict comparable v -> Dict comparable v\ninsertHelp key value dict =\n  case dict of\n    RBEmpty_elm_builtin ->\n      -- New nodes are always red. If it violates the rules, it will be fixed\n      -- when balancing.\n      RBNode_elm_builtin Red key value RBEmpty_elm_builtin RBEmpty_elm_builtin\n\n    RBNode_elm_builtin nColor nKey nValue nLeft nRight ->\n      case compare key nKey of\n        LT ->\n          balance nColor nKey nValue (insertHelp key value nLeft) nRight\n\n        EQ ->\n          RBNode_elm_builtin nColor nKey value nLeft nRight\n\n        GT ->\n          balance nColor nKey nValue nLeft (insertHelp key value nRight)\n\n\nbalance : NColor -> k -> v -> Dict k v -> Dict k v -> Dict k v\nbalance color key value left right =\n  case right of\n    RBNode_elm_builtin Red rK rV rLeft rRight ->\n      case left of\n        RBNode_elm_builtin Red lK lV lLeft lRight ->\n          RBNode_elm_builtin\n            Red\n            key\n            value\n            (RBNode_elm_builtin Black lK lV lLeft lRight)\n            (RBNode_elm_builtin Black rK rV rLeft rRight)\n\n        _ ->\n          RBNode_elm_builtin color rK rV (RBNode_elm_builtin Red key value left rLeft) rRight\n\n    _ ->\n      case left of\n        RBNode_elm_builtin Red lK lV (RBNode_elm_builtin Red llK llV llLeft llRight) lRight ->\n          RBNode_elm_builtin\n            Red\n            lK\n            lV\n            (RBNode_elm_builtin Black llK llV llLeft llRight)\n            (RBNode_elm_builtin Black key value lRight right)\n\n        _ ->\n          RBNode_elm_builtin color key value left right\n\n\n{-| Remove a key-value pair from a dictionary. If the key is not found,\nno changes are made. -}\nremove : comparable -> Dict comparable v -> Dict comparable v\nremove key dict =\n  -- Root node is always Black\n  case removeHelp key dict of\n    RBNode_elm_builtin Red k v l r ->\n      RBNode_elm_builtin Black k v l r\n\n    x ->\n      x\n\n\n{-| The easiest thing to remove from the tree, is a red node. However, when searching for the\nnode to remove, we have no way of knowing if it will be red or not. This remove implementation\nmakes sure that the bottom node is red by moving red colors down the tree through rotation\nand color flips. Any violations this will cause, can easily be fixed by balancing on the way\nup again.\n-}\nremoveHelp : comparable -> Dict comparable v -> Dict comparable v\nremoveHelp targetKey dict =\n  case dict of\n    RBEmpty_elm_builtin ->\n      RBEmpty_elm_builtin\n\n    RBNode_elm_builtin color key value left right ->\n      if targetKey < key then\n        case left of\n          RBNode_elm_builtin Black _ _ lLeft _ ->\n            case lLeft of\n              RBNode_elm_builtin Red _ _ _ _ ->\n                RBNode_elm_builtin color key value (removeHelp targetKey left) right\n\n              _ ->\n                case moveRedLeft dict of\n                  RBNode_elm_builtin nColor nKey nValue nLeft nRight ->\n                    balance nColor nKey nValue (removeHelp targetKey nLeft) nRight\n\n                  RBEmpty_elm_builtin ->\n                    RBEmpty_elm_builtin\n\n          _ ->\n            RBNode_elm_builtin color key value (removeHelp targetKey left) right\n      else\n        removeHelpEQGT targetKey (removeHelpPrepEQGT targetKey dict color key value left right)\n\n\nremoveHelpPrepEQGT : comparable -> Dict comparable v -> NColor -> comparable -> v -> Dict comparable v -> Dict comparable v -> Dict comparable v\nremoveHelpPrepEQGT targetKey dict color key value left right =\n  case left of\n    RBNode_elm_builtin Red lK lV lLeft lRight ->\n      RBNode_elm_builtin\n        color\n        lK\n        lV\n        lLeft\n        (RBNode_elm_builtin Red key value lRight right)\n\n    _ ->\n      case right of\n        RBNode_elm_builtin Black _ _ (RBNode_elm_builtin Black _ _ _ _) _ ->\n          moveRedRight dict\n\n        RBNode_elm_builtin Black _ _ RBEmpty_elm_builtin _ ->\n          moveRedRight dict\n\n        _ ->\n          dict\n\n\n{-| When we find the node we are looking for, we can remove by replacing the key-value\npair with the key-value pair of the left-most node on the right side (the closest pair).\n-}\nremoveHelpEQGT : comparable -> Dict comparable v -> Dict comparable v\nremoveHelpEQGT targetKey dict =\n  case dict of\n    RBNode_elm_builtin color key value left right ->\n      if targetKey == key then\n        case getMin right of\n          RBNode_elm_builtin _ minKey minValue _ _ ->\n            balance color minKey minValue left (removeMin right)\n\n          RBEmpty_elm_builtin ->\n            RBEmpty_elm_builtin\n      else\n        balance color key value left (removeHelp targetKey right)\n\n    RBEmpty_elm_builtin ->\n      RBEmpty_elm_builtin\n\n\ngetMin : Dict k v -> Dict k v\ngetMin dict =\n  case dict of\n    RBNode_elm_builtin _ _ _ ((RBNode_elm_builtin _ _ _ _ _) as left) _ ->\n      getMin left\n\n    _ ->\n      dict\n\n\nremoveMin : Dict k v -> Dict k v\nremoveMin dict =\n  case dict of\n    RBNode_elm_builtin color key value ((RBNode_elm_builtin lColor _ _ lLeft _) as left) right ->\n      case lColor of\n        Black ->\n          case lLeft of\n            RBNode_elm_builtin Red _ _ _ _ ->\n              RBNode_elm_builtin color key value (removeMin left) right\n\n            _ ->\n              case moveRedLeft dict of\n                RBNode_elm_builtin nColor nKey nValue nLeft nRight ->\n                  balance nColor nKey nValue (removeMin nLeft) nRight\n\n                RBEmpty_elm_builtin ->\n                  RBEmpty_elm_builtin\n\n        _ ->\n          RBNode_elm_builtin color key value (removeMin left) right\n\n    _ ->\n      RBEmpty_elm_builtin\n\n\nmoveRedLeft : Dict k v -> Dict k v\nmoveRedLeft dict =\n  case dict of\n    RBNode_elm_builtin clr k v (RBNode_elm_builtin lClr lK lV lLeft lRight) (RBNode_elm_builtin rClr rK rV ((RBNode_elm_builtin Red rlK rlV rlL rlR) as rLeft) rRight) ->\n      RBNode_elm_builtin\n        Red\n        rlK\n        rlV\n        (RBNode_elm_builtin Black k v (RBNode_elm_builtin Red lK lV lLeft lRight) rlL)\n        (RBNode_elm_builtin Black rK rV rlR rRight)\n\n    RBNode_elm_builtin clr k v (RBNode_elm_builtin lClr lK lV lLeft lRight) (RBNode_elm_builtin rClr rK rV rLeft rRight) ->\n      case clr of\n        Black ->\n          RBNode_elm_builtin\n            Black\n            k\n            v\n            (RBNode_elm_builtin Red lK lV lLeft lRight)\n            (RBNode_elm_builtin Red rK rV rLeft rRight)\n\n        Red ->\n          RBNode_elm_builtin\n            Black\n            k\n            v\n            (RBNode_elm_builtin Red lK lV lLeft lRight)\n            (RBNode_elm_builtin Red rK rV rLeft rRight)\n\n    _ ->\n      dict\n\n\nmoveRedRight : Dict k v -> Dict k v\nmoveRedRight dict =\n  case dict of\n    RBNode_elm_builtin clr k v (RBNode_elm_builtin lClr lK lV (RBNode_elm_builtin Red llK llV llLeft llRight) lRight) (RBNode_elm_builtin rClr rK rV rLeft rRight) ->\n      RBNode_elm_builtin\n        Red\n        lK\n        lV\n        (RBNode_elm_builtin Black llK llV llLeft llRight)\n        (RBNode_elm_builtin Black k v lRight (RBNode_elm_builtin Red rK rV rLeft rRight))\n\n    RBNode_elm_builtin clr k v (RBNode_elm_builtin lClr lK lV lLeft lRight) (RBNode_elm_builtin rClr rK rV rLeft rRight) ->\n      case clr of\n        Black ->\n          RBNode_elm_builtin\n            Black\n            k\n            v\n            (RBNode_elm_builtin Red lK lV lLeft lRight)\n            (RBNode_elm_builtin Red rK rV rLeft rRight)\n\n        Red ->\n          RBNode_elm_builtin\n            Black\n            k\n            v\n            (RBNode_elm_builtin Red lK lV lLeft lRight)\n            (RBNode_elm_builtin Red rK rV rLeft rRight)\n\n    _ ->\n      dict\n\n\n{-| Update the value of a dictionary for a specific key with a given function. -}\nupdate : comparable -> (Maybe v -> Maybe v) -> Dict comparable v -> Dict comparable v\nupdate targetKey alter dictionary =\n  case alter (get targetKey dictionary) of\n    Just value ->\n      insert targetKey value dictionary\n\n    Nothing ->\n      remove targetKey dictionary\n\n\n{-| Create a dictionary with one key-value pair. -}\nsingleton : comparable -> v -> Dict comparable v\nsingleton key value =\n  -- Root node is always Black\n  RBNode_elm_builtin Black key value RBEmpty_elm_builtin RBEmpty_elm_builtin\n\n\n-- COMBINE\n\n\n{-| Combine two dictionaries. If there is a collision, preference is given\nto the first dictionary.\n-}\nunion : Dict comparable v -> Dict comparable v -> Dict comparable v\nunion t1 t2 =\n  foldl insert t2 t1\n\n\n{-| Keep a key-value pair when its key appears in the second dictionary.\nPreference is given to values in the first dictionary.\n-}\nintersect : Dict comparable v -> Dict comparable v -> Dict comparable v\nintersect t1 t2 =\n  filter (\\k _ -> member k t2) t1\n\n\n{-| Keep a key-value pair when its key does not appear in the second dictionary.\n-}\ndiff : Dict comparable a -> Dict comparable b -> Dict comparable a\ndiff t1 t2 =\n  foldl (\\k v t -> remove k t) t1 t2\n\n\n{-| The most general way of combining two dictionaries. You provide three\naccumulators for when a given key appears:\n\n  1. Only in the left dictionary.\n  2. In both dictionaries.\n  3. Only in the right dictionary.\n\nYou then traverse all the keys from lowest to highest, building up whatever\nyou want.\n-}\nmerge\n  :  (comparable -> a -> result -> result)\n  -> (comparable -> a -> b -> result -> result)\n  -> (comparable -> b -> result -> result)\n  -> Dict comparable a\n  -> Dict comparable b\n  -> result\n  -> result\nmerge leftStep bothStep rightStep leftDict rightDict initialResult =\n  let\n    stepState rKey rValue (list, result) =\n      case list of\n        [] ->\n          (list, rightStep rKey rValue result)\n\n        (lKey, lValue) :: rest ->\n          if lKey < rKey then\n            stepState rKey rValue (rest, leftStep lKey lValue result)\n\n          else if lKey > rKey then\n            (list, rightStep rKey rValue result)\n\n          else\n            (rest, bothStep lKey lValue rValue result)\n\n    (leftovers, intermediateResult) =\n      foldl stepState (toList leftDict, initialResult) rightDict\n  in\n    List.foldl (\\(k,v) result -> leftStep k v result) intermediateResult leftovers\n\n\n\n-- TRANSFORM\n\n\n{-| Apply a function to all values in a dictionary.\n-}\nmap : (k -> a -> b) -> Dict k a -> Dict k b\nmap func dict =\n  case dict of\n    RBEmpty_elm_builtin ->\n      RBEmpty_elm_builtin\n\n    RBNode_elm_builtin color key value left right ->\n      RBNode_elm_builtin color key (func key value) (map func left) (map func right)\n\n\n{-| Fold over the key-value pairs in a dictionary from lowest key to highest key.\n\n    import Dict exposing (Dict)\n\n    getAges : Dict String User -> List String\n    getAges users =\n      Dict.foldl addAge [] users\n\n    addAge : String -> User -> List String -> List String\n    addAge _ user ages =\n      user.age :: ages\n\n    -- getAges users == [33,19,28]\n-}\nfoldl : (k -> v -> b -> b) -> b -> Dict k v -> b\nfoldl func acc dict =\n  case dict of\n    RBEmpty_elm_builtin ->\n      acc\n\n    RBNode_elm_builtin _ key value left right ->\n      foldl func (func key value (foldl func acc left)) right\n\n\n{-| Fold over the key-value pairs in a dictionary from highest key to lowest key.\n\n    import Dict exposing (Dict)\n\n    getAges : Dict String User -> List String\n    getAges users =\n      Dict.foldr addAge [] users\n\n    addAge : String -> User -> List String -> List String\n    addAge _ user ages =\n      user.age :: ages\n\n    -- getAges users == [28,19,33]\n-}\nfoldr : (k -> v -> b -> b) -> b -> Dict k v -> b\nfoldr func acc t =\n  case t of\n    RBEmpty_elm_builtin ->\n      acc\n\n    RBNode_elm_builtin _ key value left right ->\n      foldr func (func key value (foldr func acc right)) left\n\n\n{-| Keep only the key-value pairs that pass the given test. -}\nfilter : (comparable -> v -> Bool) -> Dict comparable v -> Dict comparable v\nfilter isGood dict =\n  foldl (\\k v d -> if isGood k v then insert k v d else d) empty dict\n\n\n{-| Partition a dictionary according to some test. The first dictionary\ncontains all key-value pairs which passed the test, and the second contains\nthe pairs that did not.\n-}\npartition : (comparable -> v -> Bool) -> Dict comparable v -> (Dict comparable v, Dict comparable v)\npartition isGood dict =\n  let\n    add key value (t1, t2) =\n      if isGood key value then\n        (insert key value t1, t2)\n\n      else\n        (t1, insert key value t2)\n  in\n    foldl add (empty, empty) dict\n\n\n-- LISTS\n\n\n{-| Get all of the keys in a dictionary, sorted from lowest to highest.\n\n    keys (fromList [(0,\"Alice\"),(1,\"Bob\")]) == [0,1]\n-}\nkeys : Dict k v -> List k\nkeys dict =\n  foldr (\\key value keyList -> key :: keyList) [] dict\n\n\n{-| Get all of the values in a dictionary, in the order of their keys.\n\n    values (fromList [(0,\"Alice\"),(1,\"Bob\")]) == [\"Alice\", \"Bob\"]\n-}\nvalues : Dict k v -> List v\nvalues dict =\n  foldr (\\key value valueList -> value :: valueList) [] dict\n\n\n{-| Convert a dictionary into an association list of key-value pairs, sorted by keys. -}\ntoList : Dict k v -> List (k,v)\ntoList dict =\n  foldr (\\key value list -> (key,value) :: list) [] dict\n\n\n{-| Convert an association list into a dictionary. -}\nfromList : List (comparable,v) -> Dict comparable v\nfromList assocs =\n  List.foldl (\\(key,value) dict -> insert key value dict) empty assocs\n" })
        )
        ,( "Set.elm"
        , BlobNode ({ utf8 = "module Set exposing\n  ( Set\n  , empty, singleton, insert, remove\n  , isEmpty, member, size\n  , union, intersect, diff\n  , toList, fromList\n  , map, foldl, foldr, filter, partition\n  )\n\n{-| A set of unique values. The values can be any comparable type. This\nincludes `Int`, `Float`, `Time`, `Char`, `String`, and tuples or lists\nof comparable types.\n\nInsert, remove, and query operations all take *O(log n)* time.\n\n# Sets\n@docs Set\n\n# Build\n@docs empty, singleton, insert, remove\n\n# Query\n@docs isEmpty, member, size\n\n# Combine\n@docs union, intersect, diff\n\n# Lists\n@docs toList, fromList\n\n# Transform\n@docs map, foldl, foldr, filter, partition\n\n-}\n\nimport Basics exposing (Bool, Int)\nimport Dict\nimport List exposing ((::))\nimport Maybe exposing (Maybe(..))\n\n\n{-| Represents a set of unique values. So `(Set Int)` is a set of integers and\n`(Set String)` is a set of strings.\n-}\ntype Set t =\n  Set_elm_builtin (Dict.Dict t ())\n\n\n{-| Create an empty set.\n-}\nempty : Set a\nempty =\n  Set_elm_builtin Dict.empty\n\n\n{-| Create a set with one value.\n-}\nsingleton : comparable -> Set comparable\nsingleton key =\n  Set_elm_builtin (Dict.singleton key ())\n\n\n{-| Insert a value into a set.\n-}\ninsert : comparable -> Set comparable -> Set comparable\ninsert key (Set_elm_builtin dict) =\n  Set_elm_builtin (Dict.insert key () dict)\n\n\n{-| Remove a value from a set. If the value is not found, no changes are made.\n-}\nremove : comparable -> Set comparable -> Set comparable\nremove key (Set_elm_builtin dict) =\n  Set_elm_builtin (Dict.remove key dict)\n\n\n{-| Determine if a set is empty.\n-}\nisEmpty : Set a -> Bool\nisEmpty (Set_elm_builtin dict) =\n  Dict.isEmpty dict\n\n\n{-| Determine if a value is in a set.\n-}\nmember : comparable -> Set comparable -> Bool\nmember key (Set_elm_builtin dict) =\n  Dict.member key dict\n\n\n{-| Determine the number of elements in a set.\n-}\nsize : Set a -> Int\nsize (Set_elm_builtin dict) =\n  Dict.size dict\n\n\n{-| Get the union of two sets. Keep all values.\n-}\nunion : Set comparable -> Set comparable -> Set comparable\nunion (Set_elm_builtin dict1) (Set_elm_builtin dict2) =\n  Set_elm_builtin (Dict.union dict1 dict2)\n\n\n{-| Get the intersection of two sets. Keeps values that appear in both sets.\n-}\nintersect : Set comparable -> Set comparable -> Set comparable\nintersect (Set_elm_builtin dict1) (Set_elm_builtin dict2) =\n  Set_elm_builtin (Dict.intersect dict1 dict2)\n\n\n{-| Get the difference between the first set and the second. Keeps values\nthat do not appear in the second set.\n-}\ndiff : Set comparable -> Set comparable -> Set comparable\ndiff (Set_elm_builtin dict1) (Set_elm_builtin dict2) =\n  Set_elm_builtin (Dict.diff dict1 dict2)\n\n\n{-| Convert a set into a list, sorted from lowest to highest.\n-}\ntoList : Set a -> List a\ntoList (Set_elm_builtin dict) =\n  Dict.keys dict\n\n\n{-| Convert a list into a set, removing any duplicates.\n-}\nfromList : List comparable -> Set comparable\nfromList list =\n  List.foldl insert empty list\n\n\n{-| Fold over the values in a set, in order from lowest to highest.\n-}\nfoldl : (a -> b -> b) -> b -> Set a -> b\nfoldl func initialState (Set_elm_builtin dict) =\n  Dict.foldl (\\key _ state -> func key state) initialState dict\n\n\n{-| Fold over the values in a set, in order from highest to lowest.\n-}\nfoldr : (a -> b -> b) -> b -> Set a -> b\nfoldr func initialState (Set_elm_builtin dict) =\n  Dict.foldr (\\key _ state -> func key state) initialState dict\n\n\n{-| Map a function onto a set, creating a new set with no duplicates.\n-}\nmap : (comparable -> comparable2) -> Set comparable -> Set comparable2\nmap func set =\n  fromList (foldl (\\x xs -> func x :: xs) [] set)\n\n\n{-| Only keep elements that pass the given test.\n\n    import Set exposing (Set)\n\n    numbers : Set Int\n    numbers =\n      Set.fromList [-2,-1,0,1,2]\n\n    positives : Set Int\n    positives =\n      Set.filter (\\x -> x > 0) numbers\n\n    -- positives == Set.fromList [1,2]\n-}\nfilter : (comparable -> Bool) -> Set comparable -> Set comparable\nfilter isGood (Set_elm_builtin dict) =\n  Set_elm_builtin (Dict.filter (\\key _ -> isGood key) dict)\n\n\n{-| Create two new sets. The first contains all the elements that passed the\ngiven test, and the second contains all the elements that did not.\n-}\npartition : (comparable -> Bool) -> Set comparable -> (Set comparable, Set comparable)\npartition isGood (Set_elm_builtin dict) =\n  let\n    (dict1, dict2) =\n      Dict.partition (\\key _ -> isGood key) dict\n  in\n    (Set_elm_builtin dict1, Set_elm_builtin dict2)\n" })
        )
        ,( "Task.elm"
        , BlobNode ({ utf8 = "effect module Task where { command = MyCmd } exposing\n  ( Task\n  , succeed, fail\n  , map, map2, map3, map4, map5\n  , sequence\n  , andThen\n  , onError, mapError\n  , perform, attempt\n  )\n\n{-| Tasks make it easy to describe asynchronous operations that may fail, like\nHTTP requests or writing to a database.\n\n# Tasks\n@docs Task, perform, attempt\n\n# Chains\n@docs andThen, succeed, fail, sequence\n\n# Maps\n@docs map, map2, map3, map4, map5\n\n# Errors\n@docs onError, mapError\n\n-}\n\nimport Basics exposing (Never, (|>), (<<))\nimport Elm.Kernel.Scheduler\nimport List exposing ((::))\nimport Maybe exposing (Maybe(..))\nimport Platform\nimport Platform.Cmd exposing (Cmd)\nimport Result exposing (Result(..))\n\n\n\n{-| Here are some common tasks:\n\n- [`now : Task x Posix`][now]\n- [`focus : String -> Task Error ()`][focus]\n- [`sleep : Float -> Task x ()`][sleep]\n\n[now]: /packages/elm/time/latest/Time#now\n[focus]: /packages/elm/browser/latest/Browser-Dom#focus\n[sleep]: /packages/elm/core/latest/Process#sleep\n\nIn each case we have a `Task` that will resolve successfully with an `a` value\nor unsuccessfully with an `x` value. So `Browser.Dom.focus` we may fail with an\n`Error` if the given ID does not exist. Whereas `Time.now` never fails so\nI cannot be more specific than `x`. No such value will ever exist! Instead it\nalways succeeds with the current POSIX time.\n\nMore generally a task is a _description_ of what you need to do. Like a todo\nlist. Or like a grocery list. Or like GitHub issues. So saying \"the task is\nto tell me the current POSIX time\" does not complete the task! You need\n[`perform`](#perform) tasks or [`attempt`](#attempt) tasks.\n-}\ntype alias Task x a =\n  Platform.Task x a\n\n\n\n-- BASICS\n\n\n{-| A task that succeeds immediately when run. It is usually used with\n[`andThen`](#andThen). You can use it like `map` if you want:\n\n    import Time -- elm install elm/time\n\n    timeInMillis : Task x Int\n    timeInMillis =\n      Time.now\n        |> andThen (\\t -> succeed (Time.posixToMillis t))\n\n-}\nsucceed : a -> Task x a\nsucceed =\n  Elm.Kernel.Scheduler.succeed\n\n\n{-| A task that fails immediately when run. Like with `succeed`, this can be\nused with `andThen` to check on the outcome of another task.\n\n    type Error = NotFound\n\n    notFound : Task Error a\n    notFound =\n      fail NotFound\n-}\nfail : x -> Task x a\nfail =\n  Elm.Kernel.Scheduler.fail\n\n\n\n-- MAPPING\n\n\n{-| Transform a task. Maybe you want to use [`elm/time`][time] to figure\nout what time it will be in one hour:\n\n    import Task exposing (Task)\n    import Time -- elm install elm/time\n\n    timeInOneHour : Task x Time.Posix\n    timeInOneHour =\n      Task.map addAnHour Time.now\n\n    addAnHour : Time.Posix -> Time.Posix\n    addAnHour time =\n      Time.millisToPosix (Time.posixToMillis time + 60 * 60 * 1000)\n\n[time]: /packages/elm/time/latest/\n-}\nmap : (a -> b) -> Task x a -> Task x b\nmap func taskA =\n  taskA\n    |> andThen (\\a -> succeed (func a))\n\n\n{-| Put the results of two tasks together. For example, if we wanted to know\nthe current month, we could use [`elm/time`][time] to ask:\n\n    import Task exposing (Task)\n    import Time -- elm install elm/time\n\n    getMonth : Task x Int\n    getMonth =\n      Task.map2 Time.toMonth Time.here Time.now\n\n**Note:** Say we were doing HTTP requests instead. `map2` does each task in\norder, so it would try the first request and only continue after it succeeds.\nIf it fails, the whole thing fails!\n\n[time]: /packages/elm/time/latest/\n-}\nmap2 : (a -> b -> result) -> Task x a -> Task x b -> Task x result\nmap2 func taskA taskB =\n  taskA\n    |> andThen (\\a -> taskB\n    |> andThen (\\b -> succeed (func a b)))\n\n\n{-|-}\nmap3 : (a -> b -> c -> result) -> Task x a -> Task x b -> Task x c -> Task x result\nmap3 func taskA taskB taskC =\n  taskA\n    |> andThen (\\a -> taskB\n    |> andThen (\\b -> taskC\n    |> andThen (\\c -> succeed (func a b c))))\n\n\n{-|-}\nmap4 : (a -> b -> c -> d -> result) -> Task x a -> Task x b -> Task x c -> Task x d -> Task x result\nmap4 func taskA taskB taskC taskD =\n  taskA\n    |> andThen (\\a -> taskB\n    |> andThen (\\b -> taskC\n    |> andThen (\\c -> taskD\n    |> andThen (\\d -> succeed (func a b c d)))))\n\n\n{-|-}\nmap5 : (a -> b -> c -> d -> e -> result) -> Task x a -> Task x b -> Task x c -> Task x d -> Task x e -> Task x result\nmap5 func taskA taskB taskC taskD taskE =\n  taskA\n    |> andThen (\\a -> taskB\n    |> andThen (\\b -> taskC\n    |> andThen (\\c -> taskD\n    |> andThen (\\d -> taskE\n    |> andThen (\\e -> succeed (func a b c d e))))))\n\n\n{-| Start with a list of tasks, and turn them into a single task that returns a\nlist. The tasks will be run in order one-by-one and if any task fails the whole\nsequence fails.\n\n    sequence [ succeed 1, succeed 2 ] == succeed [ 1, 2 ]\n\n-}\nsequence : List (Task x a) -> Task x (List a)\nsequence tasks =\n  List.foldr (map2 (::)) (succeed []) tasks\n\n\n\n-- CHAINING\n\n\n{-| Chain together a task and a callback. The first task will run, and if it is\nsuccessful, you give the result to the callback resulting in another task. This\ntask then gets run. We could use this to make a task that resolves an hour from\nnow:\n\n    import Time -- elm install elm/time\n    import Process\n\n    timeInOneHour : Task x Time.Posix\n    timeInOneHour =\n      Process.sleep (60 * 60 * 1000)\n        |> andThen (\\_ -> Time.now)\n\nFirst the process sleeps for an hour **and then** it tells us what time it is.\n-}\nandThen : (a -> Task x b) -> Task x a -> Task x b\nandThen =\n  Elm.Kernel.Scheduler.andThen\n\n\n\n-- ERRORS\n\n\n{-| Recover from a failure in a task. If the given task fails, we use the\ncallback to recover.\n\n    fail \"file not found\"\n      |> onError (\\msg -> succeed 42)\n      -- succeed 42\n\n    succeed 9\n      |> onError (\\msg -> succeed 42)\n      -- succeed 9\n-}\nonError : (x -> Task y a) -> Task x a -> Task y a\nonError =\n  Elm.Kernel.Scheduler.onError\n\n\n{-| Transform the error value. This can be useful if you need a bunch of error\ntypes to match up.\n\n    type Error\n      = Http Http.Error\n      | WebGL WebGL.Error\n\n    getResources : Task Error Resource\n    getResources =\n      sequence\n        [ mapError Http serverTask\n        , mapError WebGL textureTask\n        ]\n-}\nmapError : (x -> y) -> Task x a -> Task y a\nmapError convert task =\n  task\n    |> onError (fail << convert)\n\n\n\n-- COMMANDS\n\n\ntype MyCmd msg =\n  Perform (Task Never msg)\n\n\n{-| Like I was saying in the [`Task`](#Task) documentation, just having a\n`Task` does not mean it is done. We must command Elm to `perform` the task:\n\n    import Time  -- elm install elm/time\n    import Task\n\n    type Msg\n      = Click\n      | Search String\n      | NewTime Time.Posix\n\n    getNewTime : Cmd Msg\n    getNewTime =\n      Task.perform NewTime Time.now\n\nIf you have worked through [`guide.elm-lang.org`][guide] (highly recommended!)\nyou will recognize `Cmd` from the section on The Elm Architecture. So we have\nchanged a task like \"make delicious lasagna\" into a command like \"Hey Elm, make\ndelicious lasagna and give it to my `update` function as a `Msg` value.\"\n\n[guide]: https://guide.elm-lang.org/\n-}\nperform : (a -> msg) -> Task Never a -> Cmd msg\nperform toMessage task =\n  command (Perform (map toMessage task))\n\n\n{-| This is very similar to [`perform`](#perform) except it can handle failures!\nSo we could _attempt_ to focus on a certain DOM node like this:\n\n    import Browser.Dom  -- elm install elm/browser\n    import Task\n\n    type Msg\n      = Click\n      | Search String\n      | Focus (Result Browser.DomError ())\n\n    focus : Cmd Msg\n    focus =\n      Task.attempt Focus (Browser.Dom.focus \"my-app-search-box\")\n\nSo the task is \"focus on this DOM node\" and we are turning it into the command\n\"Hey Elm, attempt to focus on this DOM node and give me a `Msg` about whether\nyou succeeded or failed.\"\n\n**Note:** Definitely work through [`guide.elm-lang.org`][guide] to get a\nfeeling for how commands fit into The Elm Architecture.\n\n[guide]: https://guide.elm-lang.org/\n-}\nattempt : (Result x a -> msg) -> Task x a -> Cmd msg\nattempt resultToMessage task =\n  command (Perform (\n    task\n      |> andThen (succeed << resultToMessage << Ok)\n      |> onError (succeed << resultToMessage << Err)\n  ))\n\n\ncmdMap : (a -> b) -> MyCmd a -> MyCmd b\ncmdMap tagger (Perform task) =\n  Perform (map tagger task)\n\n\n\n-- MANAGER\n\n\ninit : Task Never ()\ninit =\n  succeed ()\n\n\nonEffects : Platform.Router msg Never -> List (MyCmd msg) -> () -> Task Never ()\nonEffects router commands state =\n  map\n    (\\_ -> ())\n    (sequence (List.map (spawnCmd router) commands))\n\n\nonSelfMsg : Platform.Router msg Never -> Never -> () -> Task Never ()\nonSelfMsg _ _ _ =\n  succeed ()\n\n\nspawnCmd : Platform.Router msg Never -> MyCmd msg -> Task x ()\nspawnCmd router (Perform task) =\n  Elm.Kernel.Scheduler.spawn (\n    task\n      |> andThen (Platform.sendToApp router)\n  )\n" })
        )]

file_tree_node_elm_core_modules_implicit_import =
    TreeNode
        [( "Basics.elm"
        , BlobNode ({ utf8 = "module Basics exposing\n  ( Int, Float\n  , (+), (-), (*), (/), (//), (^)\n  , toFloat, round, floor, ceiling, truncate\n  , (==), (/=)\n  , (<), (>), (<=), (>=), max, min, compare, Order(..)\n  , Bool(..), not, (&&), (||), xor\n  , (++)\n  , modBy, remainderBy, negate, abs, clamp, sqrt, logBase, e\n  , pi, cos, sin, tan, acos, asin, atan, atan2\n  , degrees, radians, turns\n  , toPolar, fromPolar\n  , isNaN, isInfinite\n  , identity, always, (<|), (|>), (<<), (>>), Never, never\n  )\n\n{-| Tons of useful functions that get imported by default.\n\n# Math\n@docs Int, Float, (+), (-), (*), (/), (//), (^)\n\n# Int to Float / Float to Int\n@docs toFloat, round, floor, ceiling, truncate\n\n# Equality\n@docs (==), (/=)\n\n# Comparison\n\nThese functions only work on `comparable` types. This includes numbers,\ncharacters, strings, lists of comparable things, and tuples of comparable\nthings.\n\n@docs (<), (>), (<=), (>=), max, min, compare, Order\n\n# Booleans\n@docs Bool, not, (&&), (||), xor\n\n# Append Strings and Lists\n@docs (++)\n\n# Fancier Math\n@docs modBy, remainderBy, negate, abs, clamp, sqrt, logBase, e\n\n# Angles\n@docs degrees, radians, turns\n\n# Trigonometry\n@docs pi, cos, sin, tan, acos, asin, atan, atan2\n\n# Polar Coordinates\n@docs toPolar, fromPolar\n\n# Floating Point Checks\n@docs isNaN, isInfinite\n\n# Function Helpers\n@docs identity, always, (<|), (|>), (<<), (>>), Never, never\n\n-}\n\n\nimport Elm.Kernel.Basics\nimport Elm.Kernel.Utils\n\n\n\n-- INFIX OPERATORS\n\n\ninfix right 0 (<|) = apL\ninfix left  0 (|>) = apR\ninfix right 2 (||) = or\ninfix right 3 (&&) = and\ninfix non   4 (==) = eq\ninfix non   4 (/=) = neq\ninfix non   4 (<)  = lt\ninfix non   4 (>)  = gt\ninfix non   4 (<=) = le\ninfix non   4 (>=) = ge\ninfix right 5 (++) = append\ninfix left  6 (+)  = add\ninfix left  6 (-)  = sub\ninfix left  7 (*)  = mul\ninfix left  7 (/)  = fdiv\ninfix left  7 (//) = idiv\ninfix right 8 (^)  = pow\ninfix left  9 (<<) = composeL\ninfix right 9 (>>) = composeR\n\n\n\n-- MATHEMATICS\n\n\n{-| An `Int` is a whole number. Valid syntax for integers includes:\n\n    0\n    42\n    9000\n    0xFF   -- 255 in hexadecimal\n    0x000A --  10 in hexadecimal\n\n**Note:** `Int` math is well-defined in the range `-2^31` to `2^31 - 1`. Outside\nof that range, the behavior is determined by the compilation target. When\ngenerating JavaScript, the safe range expands to `-(2^53 - 1)` to `2^53 - 1` for some\noperations, but if we generate WebAssembly some day, we would do the traditional\n[integer overflow][io]. This quirk is necessary to get good performance on\nquirky compilation targets.\n\n**Historical Note:** The name `Int` comes from the term [integer][]. It appears\nthat the `int` abbreviation was introduced in [ALGOL 68][68], shortening it\nfrom `integer` in [ALGOL 60][60]. Today, almost all programming languages use\nthis abbreviation.\n\n[io]: https://en.wikipedia.org/wiki/Integer_overflow\n[integer]: https://en.wikipedia.org/wiki/Integer\n[60]: https://en.wikipedia.org/wiki/ALGOL_60\n[68]: https://en.wikipedia.org/wiki/ALGOL_68\n-}\ntype Int = Int -- NOTE: The compiler provides the real implementation.\n\n\n{-| A `Float` is a [floating-point number][fp]. Valid syntax for floats includes:\n\n    0\n    42\n    3.14\n    0.1234\n    6.022e23   -- == (6.022 * 10^23)\n    6.022e+23  -- == (6.022 * 10^23)\n    1.602e19  -- == (1.602 * 10^-19)\n    1e3        -- == (1 * 10^3) == 1000\n\n**Historical Note:** The particular details of floats (e.g. `NaN`) are\nspecified by [IEEE 754][ieee] which is literally hard-coded into almost all\nCPUs in the world. That means if you think `NaN` is weird, you must\nsuccessfully overtake Intel and AMD with a chip that is not backwards\ncompatible with any widely-used assembly language.\n\n[fp]: https://en.wikipedia.org/wiki/Floating-point_arithmetic\n[ieee]: https://en.wikipedia.org/wiki/IEEE_754\n-}\ntype Float = Float -- NOTE: The compiler provides the real implementation.\n\n\n{-| Add two numbers. The `number` type variable means this operation can be\nspecialized to `Int -> Int -> Int` or to `Float -> Float -> Float`. So you\ncan do things like this:\n\n    3002 + 4004 == 7006  -- all ints\n    3.14 + 3.14 == 6.28  -- all floats\n\nYou _cannot_ add an `Int` and a `Float` directly though. Use functions like\n[toFloat](#toFloat) or [round](#round) to convert both values to the same type.\nSo if you needed to add a list length to a `Float` for some reason, you\ncould say one of these:\n\n    3.14 + toFloat (List.length [1,2,3]) == 6.14\n    round 3.14 + List.length [1,2,3]     == 6\n\n**Note:** Languages like Java and JavaScript automatically convert `Int` values\nto `Float` values when you mix and match. This can make it difficult to be sure\nexactly what type of number you are dealing with. When you try to _infer_ these\nconversions (as Scala does) it can be even more confusing. Elm has opted for a\ndesign that makes all conversions explicit.\n-}\nadd : number -> number -> number\nadd =\n  Elm.Kernel.Basics.add\n\n\n{-| Subtract numbers like `4 - 3 == 1`.\n\nSee [`(+)`](#+) for docs on the `number` type variable.\n-}\nsub : number -> number -> number\nsub =\n  Elm.Kernel.Basics.sub\n\n\n{-| Multiply numbers like `2 * 3 == 6`.\n\nSee [`(+)`](#+) for docs on the `number` type variable.\n-}\nmul : number -> number -> number\nmul =\n  Elm.Kernel.Basics.mul\n\n\n{-| Floating-point division:\n\n    10 / 4 == 2.5\n    11 / 4 == 2.75\n    12 / 4 == 3\n    13 / 4 == 3.25\n    14 / 4 == 3.5\n\n    -1 / 4 == -0.25\n    -5 / 4 == -1.25\n\n-}\nfdiv : Float -> Float -> Float\nfdiv =\n  Elm.Kernel.Basics.fdiv\n\n\n{-| Integer division:\n\n    10 // 4 == 2\n    11 // 4 == 2\n    12 // 4 == 3\n    13 // 4 == 3\n    14 // 4 == 3\n\n    -1 // 4 == 0\n    -5 // 4 == -1\n\nNotice that the remainder is discarded, so `3 // 4` is giving output\nsimilar to `truncate (3 / 4)`.\n\nIt may sometimes be useful to pair this with the [`remainderBy`](#remainderBy)\nfunction.\n-}\nidiv : Int -> Int -> Int\nidiv =\n  Elm.Kernel.Basics.idiv\n\n\n{-| Exponentiation\n\n    3^2 == 9\n    3^3 == 27\n-}\npow : number -> number -> number\npow =\n  Elm.Kernel.Basics.pow\n\n\n\n-- INT TO FLOAT / FLOAT TO INT\n\n\n{-| Convert an integer into a float. Useful when mixing `Int` and `Float`\nvalues like this:\n\n    halfOf : Int -> Float\n    halfOf number =\n      toFloat number / 2\n\n-}\ntoFloat : Int -> Float\ntoFloat =\n  Elm.Kernel.Basics.toFloat\n\n\n{-| Round a number to the nearest integer.\n\n    round 1.0 == 1\n    round 1.2 == 1\n    round 1.5 == 2\n    round 1.8 == 2\n\n    round -1.2 == -1\n    round -1.5 == -1\n    round -1.8 == -2\n-}\nround : Float -> Int\nround =\n  Elm.Kernel.Basics.round\n\n\n{-| Floor function, rounding down.\n\n    floor 1.0 == 1\n    floor 1.2 == 1\n    floor 1.5 == 1\n    floor 1.8 == 1\n\n    floor -1.2 == -2\n    floor -1.5 == -2\n    floor -1.8 == -2\n-}\nfloor : Float -> Int\nfloor =\n  Elm.Kernel.Basics.floor\n\n\n{-| Ceiling function, rounding up.\n\n    ceiling 1.0 == 1\n    ceiling 1.2 == 2\n    ceiling 1.5 == 2\n    ceiling 1.8 == 2\n\n    ceiling -1.2 == -1\n    ceiling -1.5 == -1\n    ceiling -1.8 == -1\n-}\nceiling : Float -> Int\nceiling =\n  Elm.Kernel.Basics.ceiling\n\n\n{-| Truncate a number, rounding towards zero.\n\n    truncate 1.0 == 1\n    truncate 1.2 == 1\n    truncate 1.5 == 1\n    truncate 1.8 == 1\n\n    truncate -1.2 == -1\n    truncate -1.5 == -1\n    truncate -1.8 == -1\n-}\ntruncate : Float -> Int\ntruncate =\n  Elm.Kernel.Basics.truncate\n\n\n\n-- EQUALITY\n\n\n{-| Check if values are &ldquo;the same&rdquo;.\n\n**Note:** Elm uses structural equality on tuples, records, and user-defined\nunion types. This means the values `(3, 4)` and `(3, 4)` are definitely equal.\nThis is not true in languages like JavaScript that use reference equality on\nobjects.\n\n**Note:** Do not use `(==)` with functions, JSON values from `elm/json`, or\nregular expressions from `elm/regex`. It does not work. It will crash if\npossible. With JSON values, decode to Elm values before doing any equality\nchecks!\n\nWhy is it like this? Equality in the Elm sense can be difficult or impossible\nto compute. Proving that functions are the same is [undecidable][], and JSON\nvalues can come in through ports and have functions, cycles, and new JS data\ntypes that interact weirdly with our equality implementation. In a future\nrelease, the compiler will detect when `(==)` is used with problematic types\nand provide a helpful error message at compile time. This will require some\npretty serious infrastructure work, so the stopgap is to crash as quickly as\npossible.\n\n[undecidable]: https://en.wikipedia.org/wiki/Undecidable_problem\n-}\neq : a -> a -> Bool\neq =\n  Elm.Kernel.Utils.equal\n\n\n{-| Check if values are not &ldquo;the same&rdquo;.\n\nSo `(a /= b)` is the same as `(not (a == b))`.\n-}\nneq : a -> a -> Bool\nneq =\n  Elm.Kernel.Utils.notEqual\n\n\n\n-- COMPARISONS\n\n\n{-|-}\nlt : comparable -> comparable -> Bool\nlt =\n  Elm.Kernel.Utils.lt\n\n\n{-|-}\ngt : comparable -> comparable -> Bool\ngt =\n  Elm.Kernel.Utils.gt\n\n\n{-|-}\nle : comparable -> comparable -> Bool\nle =\n  Elm.Kernel.Utils.le\n\n\n{-|-}\nge : comparable -> comparable -> Bool\nge =\n  Elm.Kernel.Utils.ge\n\n\n{-| Find the smaller of two comparables.\n\n    min 42 12345678 == 42\n    min \"abc\" \"xyz\" == \"abc\"\n-}\nmin : comparable -> comparable -> comparable\nmin x y =\n  if lt x y then x else y\n\n\n{-| Find the larger of two comparables.\n\n    max 42 12345678 == 12345678\n    max \"abc\" \"xyz\" == \"xyz\"\n-}\nmax : comparable -> comparable -> comparable\nmax x y =\n  if gt x y then x else y\n\n\n{-| Compare any two comparable values. Comparable values include `String`,\n`Char`, `Int`, `Float`, or a list or tuple containing comparable values. These\nare also the only values that work as `Dict` keys or `Set` members.\n\n    compare 3 4 == LT\n    compare 4 4 == EQ\n    compare 5 4 == GT\n-}\ncompare : comparable -> comparable -> Order\ncompare =\n  Elm.Kernel.Utils.compare\n\n\n{-| Represents the relative ordering of two things.\nThe relations are less than, equal to, and greater than.\n-}\ntype Order = LT | EQ | GT\n\n\n\n-- BOOLEANS\n\n\n{-| A Boolean value. It can either be `True` or `False`.\n\n**Note:** Programmers coming from JavaScript, Java, etc. tend to reach for\nboolean values way too often in Elm. Using a [union type][ut] is often clearer\nand more reliable. You can learn more about this from Jeremy [here][jf] or\nfrom Richard [here][rt].\n\n[ut]: https://guide.elm-lang.org/types/union_types.html\n[jf]: https://youtu.be/6TDKHGtAxeg?t=1m25s\n[rt]: https://youtu.be/IcgmSRJHu_8?t=1m14s\n-}\ntype Bool = True | False\n\n\n{-| Negate a boolean value.\n\n    not True == False\n    not False == True\n-}\nnot : Bool -> Bool\nnot =\n  Elm.Kernel.Basics.not\n\n\n{-| The logical AND operator. `True` if both inputs are `True`.\n\n    True  && True  == True\n    True  && False == False\n    False && True  == False\n    False && False == False\n\n**Note:** When used in the infix position, like `(left && right)`, the operator\nshort-circuits. This means if `left` is `False` we do not bother evaluating `right`\nand just return `False` overall.\n-}\nand : Bool -> Bool -> Bool\nand =\n  Elm.Kernel.Basics.and\n\n\n{-| The logical OR operator. `True` if one or both inputs are `True`.\n\n    True  || True  == True\n    True  || False == True\n    False || True  == True\n    False || False == False\n\n**Note:** When used in the infix position, like `(left || right)`, the operator\nshort-circuits. This means if `left` is `True` we do not bother evaluating `right`\nand just return `True` overall.\n-}\nor : Bool -> Bool -> Bool\nor =\n  Elm.Kernel.Basics.or\n\n\n{-| The exclusive-or operator. `True` if exactly one input is `True`.\n\n    xor True  True  == False\n    xor True  False == True\n    xor False True  == True\n    xor False False == False\n-}\nxor : Bool -> Bool -> Bool\nxor =\n  Elm.Kernel.Basics.xor\n\n\n\n-- APPEND\n\n\n{-| Put two appendable things together. This includes strings and lists.\n\n    \"hello\" ++ \"world\" == \"helloworld\"\n    [1,1,2] ++ [3,5,8] == [1,1,2,3,5,8]\n-}\nappend : appendable -> appendable -> appendable\nappend =\n  Elm.Kernel.Utils.append\n\n\n\n-- FANCIER MATH\n\n\n{-| Perform [modular arithmetic](https://en.wikipedia.org/wiki/Modular_arithmetic).\nA common trick is to use (n mod 2) to detect even and odd numbers:\n\n    modBy 2 0 == 0\n    modBy 2 1 == 1\n    modBy 2 2 == 0\n    modBy 2 3 == 1\n\nOur `modBy` function works in the typical mathematical way when you run into\nnegative numbers:\n\n    List.map (modBy 4) [ -5, -4, -3, -2, -1,  0,  1,  2,  3,  4,  5 ]\n    --                 [  3,  0,  1,  2,  3,  0,  1,  2,  3,  0,  1 ]\n\nUse [`remainderBy`](#remainderBy) for a different treatment of negative numbers,\nor read Daan Leijens [Division and Modulus for Computer Scientists][dm] for more\ninformation.\n\n[dm]: https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/divmodnote-letter.pdf\n-}\nmodBy : Int -> Int -> Int\nmodBy =\n  Elm.Kernel.Basics.modBy\n\n\n{-| Get the remainder after division. Here are bunch of examples of dividing by four:\n\n    List.map (remainderBy 4) [ -5, -4, -3, -2, -1,  0,  1,  2,  3,  4,  5 ]\n    --                       [ -1,  0, -3, -2, -1,  0,  1,  2,  3,  0,  1 ]\n\nUse [`modBy`](#modBy) for a different treatment of negative numbers,\nor read Daan Leijens [Division and Modulus for Computer Scientists][dm] for more\ninformation.\n\n[dm]: https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/divmodnote-letter.pdf\n-}\nremainderBy : Int -> Int -> Int\nremainderBy =\n  Elm.Kernel.Basics.remainderBy\n\n\n{-| Negate a number.\n\n    negate 42 == -42\n    negate -42 == 42\n    negate 0 == 0\n-}\nnegate : number -> number\nnegate n =\n  -n\n\n\n{-| Get the [absolute value][abs] of a number.\n\n    abs 16   == 16\n    abs -4   == 4\n    abs -8.5 == 8.5\n    abs 3.14 == 3.14\n\n[abs]: https://en.wikipedia.org/wiki/Absolute_value\n-}\nabs : number -> number\nabs n =\n  if lt n 0 then -n else n\n\n\n{-| Clamps a number within a given range. With the expression\n`clamp 100 200 x` the results are as follows:\n\n    100     if x < 100\n     x      if 100 <= x < 200\n    200     if 200 <= x\n-}\nclamp : number -> number -> number -> number\nclamp low high number =\n  if lt number low then\n    low\n  else if gt number high then\n    high\n  else\n    number\n\n\n{-| Take the square root of a number.\n\n    sqrt  4 == 2\n    sqrt  9 == 3\n    sqrt 16 == 4\n    sqrt 25 == 5\n-}\nsqrt : Float -> Float\nsqrt =\n  Elm.Kernel.Basics.sqrt\n\n\n{-| Calculate the logarithm of a number with a given base.\n\n    logBase 10 100 == 2\n    logBase 2 256 == 8\n-}\nlogBase : Float -> Float -> Float\nlogBase base number =\n  fdiv\n    (Elm.Kernel.Basics.log number)\n    (Elm.Kernel.Basics.log base)\n\n\n{-| An approximation of e.\n-}\ne : Float\ne =\n  Elm.Kernel.Basics.e\n\n\n\n-- ANGLES\n\n\n{-| Convert radians to standard Elm angles (radians).\n\n    radians pi == 3.141592653589793\n-}\nradians : Float -> Float\nradians angleInRadians =\n  angleInRadians\n\n\n{-| Convert degrees to standard Elm angles (radians).\n\n    degrees 180 == 3.141592653589793\n-}\ndegrees : Float -> Float\ndegrees angleInDegrees =\n  fdiv (mul angleInDegrees pi) 180\n\n\n{-| Convert turns to standard Elm angles (radians). One turn is equal to 360.\n\n    turns (1/2) == 3.141592653589793\n-}\nturns : Float -> Float\nturns angleInTurns =\n  mul (mul 2 pi) angleInTurns\n\n\n\n-- TRIGONOMETRY\n\n\n{-| An approximation of pi.\n-}\npi : Float\npi =\n  Elm.Kernel.Basics.pi\n\n\n{-| Figure out the cosine given an angle in radians.\n\n    cos (degrees 60)     == 0.5000000000000001\n    cos (turns (1/6))    == 0.5000000000000001\n    cos (radians (pi/3)) == 0.5000000000000001\n    cos (pi/3)           == 0.5000000000000001\n\n-}\ncos : Float -> Float\ncos =\n  Elm.Kernel.Basics.cos\n\n\n{-| Figure out the sine given an angle in radians.\n\n    sin (degrees 30)     == 0.49999999999999994\n    sin (turns (1/12))   == 0.49999999999999994\n    sin (radians (pi/6)) == 0.49999999999999994\n    sin (pi/6)           == 0.49999999999999994\n\n-}\nsin : Float -> Float\nsin =\n  Elm.Kernel.Basics.sin\n\n\n{-| Figure out the tangent given an angle in radians.\n\n    tan (degrees 45)     == 0.9999999999999999\n    tan (turns (1/8))    == 0.9999999999999999\n    tan (radians (pi/4)) == 0.9999999999999999\n    tan (pi/4)           == 0.9999999999999999\n-}\ntan : Float -> Float\ntan =\n  Elm.Kernel.Basics.tan\n\n\n{-| Figure out the arccosine for `adjacent / hypotenuse` in radians:\n\n    acos (1/2) == 1.0471975511965979 -- 60 or pi/3 radians\n\n-}\nacos : Float -> Float\nacos =\n  Elm.Kernel.Basics.acos\n\n\n{-| Figure out the arcsine for `opposite / hypotenuse` in radians:\n\n    asin (1/2) == 0.5235987755982989 -- 30 or pi/6 radians\n\n-}\nasin : Float -> Float\nasin =\n  Elm.Kernel.Basics.asin\n\n\n{-| This helps you find the angle (in radians) to an `(x,y)` coordinate, but\nin a way that is rarely useful in programming. **You probably want\n[`atan2`](#atan2) instead!**\n\nThis version takes `y/x` as its argument, so there is no way to know whether\nthe negative signs comes from the `y` or `x` value. So as we go counter-clockwise\naround the origin from point `(1,1)` to `(1,-1)` to `(-1,-1)` to `(-1,1)` we do\nnot get angles that go in the full circle:\n\n    atan (  1 /  1 ) ==  0.7853981633974483 --  45 or   pi/4 radians\n    atan (  1 / -1 ) == -0.7853981633974483 -- 315 or 7*pi/4 radians\n    atan ( -1 / -1 ) ==  0.7853981633974483 --  45 or   pi/4 radians\n    atan ( -1 /  1 ) == -0.7853981633974483 -- 315 or 7*pi/4 radians\n\nNotice that everything is between `pi/2` and `-pi/2`. That is pretty useless\nfor figuring out angles in any sort of visualization, so again, check out\n[`atan2`](#atan2) instead!\n-}\natan : Float -> Float\natan =\n  Elm.Kernel.Basics.atan\n\n\n{-| This helps you find the angle (in radians) to an `(x,y)` coordinate.\nSo rather than saying `atan (y/x)` you say `atan2 y x` and you can get a full\nrange of angles:\n\n    atan2  1  1 ==  0.7853981633974483 --  45 or   pi/4 radians\n    atan2  1 -1 ==  2.356194490192345  -- 135 or 3*pi/4 radians\n    atan2 -1 -1 == -2.356194490192345  -- 225 or 5*pi/4 radians\n    atan2 -1  1 == -0.7853981633974483 -- 315 or 7*pi/4 radians\n\n-}\natan2 : Float -> Float -> Float\natan2 =\n  Elm.Kernel.Basics.atan2\n\n\n\n-- POLAR COORDINATES\n\n\n{-| Convert polar coordinates (r,&theta;) to Cartesian coordinates (x,y).\n\n    fromPolar (sqrt 2, degrees 45) == (1, 1)\n-}\nfromPolar : (Float,Float) -> (Float,Float)\nfromPolar (radius, theta) =\n  ( mul radius (cos theta)\n  , mul radius (sin theta)\n  )\n\n\n{-| Convert Cartesian coordinates (x,y) to polar coordinates (r,&theta;).\n\n    toPolar (3, 4) == ( 5, 0.9272952180016122)\n    toPolar (5,12) == (13, 1.1760052070951352)\n-}\ntoPolar : (Float,Float) -> (Float,Float)\ntoPolar ( x, y ) =\n  ( sqrt (add (mul x x) (mul y y))\n  , atan2 y x\n  )\n\n\n\n-- CRAZY FLOATS\n\n\n{-| Determine whether a float is an undefined or unrepresentable number.\nNaN stands for *not a number* and it is [a standardized part of floating point\nnumbers](https://en.wikipedia.org/wiki/NaN).\n\n    isNaN (0/0)     == True\n    isNaN (sqrt -1) == True\n    isNaN (1/0)     == False  -- infinity is a number\n    isNaN 1         == False\n-}\nisNaN : Float -> Bool\nisNaN =\n  Elm.Kernel.Basics.isNaN\n\n\n{-| Determine whether a float is positive or negative infinity.\n\n    isInfinite (0/0)     == False\n    isInfinite (sqrt -1) == False\n    isInfinite (1/0)     == True\n    isInfinite 1         == False\n\nNotice that NaN is not infinite! For float `n` to be finite implies that\n`not (isInfinite n || isNaN n)` evaluates to `True`.\n-}\nisInfinite : Float -> Bool\nisInfinite =\n  Elm.Kernel.Basics.isInfinite\n\n\n\n-- FUNCTION HELPERS\n\n\n{-| Function composition, passing results along in the suggested direction. For\nexample, the following code checks if the square root of a number is odd:\n\n    not << isEven << sqrt\n\nYou can think of this operator as equivalent to the following:\n\n    (g << f)  ==  (\\x -> g (f x))\n\nSo our example expands out to something like this:\n\n    \\n -> not (isEven (sqrt n))\n-}\ncomposeL : (b -> c) -> (a -> b) -> (a -> c)\ncomposeL g f x =\n  g (f x)\n\n\n{-| Function composition, passing results along in the suggested direction. For\nexample, the following code checks if the square root of a number is odd:\n\n    sqrt >> isEven >> not\n\n-}\ncomposeR : (a -> b) -> (b -> c) -> (a -> c)\ncomposeR f g x =\n  g (f x)\n\n\n{-| Saying `x |> f` is exactly the same as `f x`.\n\nIt is called the pipe operator because it lets you write pipelined code.\nFor example, say we have a `sanitize` function for turning user input into\nintegers:\n\n    -- BEFORE\n    sanitize : String -> Maybe Int\n    sanitize input =\n      String.toInt (String.trim input)\n\nWe can rewrite it like this:\n\n    -- AFTER\n    sanitize : String -> Maybe Int\n    sanitize input =\n      input\n        |> String.trim\n        |> String.toInt\n\nTotally equivalent! I recommend trying to rewrite code that uses `x |> f`\ninto code like `f x` until there are no pipes left. That can help you build\nyour intuition.\n\n**Note:** This can be overused! I think folks find it quite neat, but when you\nhave three or four steps, the code often gets clearer if you break out a\ntop-level helper function. Now the transformation has a name. The arguments are\nnamed. It has a type annotation. It is much more self-documenting that way!\nTesting the logic gets easier too. Nice side benefit!\n-}\napR : a -> (a -> b) -> b\napR x f =\n  f x\n\n\n{-| Saying `f <| x` is exactly the same as `f x`.\n\nIt can help you avoid parentheses, which can be nice sometimes. Maybe you want\nto apply a function to a `case` expression? That sort of thing.\n-}\napL : (a -> b) -> a -> b\napL f x =\n  f x\n\n\n{-| Given a value, returns exactly the same value. This is called\n[the identity function](https://en.wikipedia.org/wiki/Identity_function).\n-}\nidentity : a -> a\nidentity x =\n  x\n\n\n{-| Create a function that *always* returns the same value. Useful with\nfunctions like `map`:\n\n    List.map (always 0) [1,2,3,4,5] == [0,0,0,0,0]\n\n    -- List.map (\\_ -> 0) [1,2,3,4,5] == [0,0,0,0,0]\n    -- always = (\\x _ -> x)\n-}\nalways : a -> b -> a\nalways a _ =\n  a\n\n\n{-| A value that can never happen! For context:\n\n  - The boolean type `Bool` has two values: `True` and `False`\n  - The unit type `()` has one value: `()`\n  - The never type `Never` has no values!\n\nYou may see it in the wild in `Html Never` which means this HTML will never\nproduce any messages. You would need to write an event handler like\n`onClick ??? : Attribute Never` but how can we fill in the question marks?!\nSo there cannot be any event handlers on that HTML.\n\nYou may also see this used with tasks that never fail, like `Task Never ()`.\n\nThe `Never` type is useful for restricting *arguments* to a function. Maybe my\nAPI can only accept HTML without event handlers, so I require `Html Never` and\nusers can give `Html msg` and everything will go fine. Generally speaking, you\ndo not want `Never` in your return types though.\n-}\ntype Never = JustOneMore Never\n\n\n{-| A function that can never be called. Seems extremely pointless, but it\n*can* come in handy. Imagine you have some HTML that should never produce any\nmessages. And say you want to use it in some other HTML that *does* produce\nmessages. You could say:\n\n    import Html exposing (..)\n\n    embedHtml : Html Never -> Html msg\n    embedHtml staticStuff =\n      div []\n        [ text \"hello\"\n        , Html.map never staticStuff\n        ]\n\nSo the `never` function is basically telling the type system, make sure no one\never calls me!\n-}\nnever : Never -> a\nnever (JustOneMore nvr) =\n  never nvr\n" })
        )
        ,( "Char.elm"
        , BlobNode ({ utf8 = "module Char exposing\n  ( Char\n  , isUpper, isLower, isAlpha, isAlphaNum\n  , isDigit, isOctDigit, isHexDigit\n  , toUpper, toLower, toLocaleUpper, toLocaleLower\n  , toCode, fromCode\n  )\n\n{-| Functions for working with characters. Character literals are enclosed in\n`'a'` pair of single quotes.\n\n# Characters\n@docs Char\n\n# ASCII Letters\n@docs isUpper, isLower, isAlpha, isAlphaNum\n\n# Digits\n@docs isDigit, isOctDigit, isHexDigit\n\n# Conversion\n@docs toUpper, toLower, toLocaleUpper, toLocaleLower\n\n# Unicode Code Points\n@docs toCode, fromCode\n-}\n\nimport Basics exposing (Bool, Int, (&&), (||), (>=), (<=))\nimport Elm.Kernel.Char\n\n\n\n-- CHAR\n\n\n{-| A `Char` is a single [unicode][u] character:\n\n    'a'\n    '0'\n    'Z'\n    '?'\n    '\"'\n    ''\n    ''\n\n    '\\t'\n    '\\\"'\n    '\\''\n    '\\u{1F648}' -- ''\n\n**Note 1:** You _cannot_ use single quotes around multiple characters like in\nJavaScript. This is how we distinguish [`String`](String#String) and `Char`\nvalues in syntax.\n\n**Note 2:** You can use the unicode escapes from `\\u{0000}` to `\\u{10FFFF}` to\nrepresent characters by their code point. You can also include the unicode\ncharacters directly. Using the escapes can be better if you need one of the\nmany whitespace characters with different widths.\n\n[u]: https://en.wikipedia.org/wiki/Unicode\n-}\ntype Char = Char -- NOTE: The compiler provides the real implementation.\n\n\n\n-- CLASSIFICATION\n\n\n{-| Detect upper case ASCII characters.\n\n    isUpper 'A' == True\n    isUpper 'B' == True\n    ...\n    isUpper 'Z' == True\n\n    isUpper '0' == False\n    isUpper 'a' == False\n    isUpper '-' == False\n    isUpper '' == False\n-}\nisUpper : Char -> Bool\nisUpper char =\n  let\n    code =\n      toCode char\n  in\n    code <= 0x5A && 0x41 <= code\n\n\n{-| Detect lower case ASCII characters.\n\n    isLower 'a' == True\n    isLower 'b' == True\n    ...\n    isLower 'z' == True\n\n    isLower '0' == False\n    isLower 'A' == False\n    isLower '-' == False\n    isLower '' == False\n-}\nisLower : Char -> Bool\nisLower char =\n  let\n    code =\n      toCode char\n  in\n    0x61 <= code && code <= 0x7A\n\n\n{-| Detect upper case and lower case ASCII characters.\n\n    isAlpha 'a' == True\n    isAlpha 'b' == True\n    isAlpha 'E' == True\n    isAlpha 'Y' == True\n\n    isAlpha '0' == False\n    isAlpha '-' == False\n    isAlpha '' == False\n-}\nisAlpha : Char -> Bool\nisAlpha char =\n  isLower char || isUpper char\n\n\n{-| Detect upper case and lower case ASCII characters.\n\n    isAlphaNum 'a' == True\n    isAlphaNum 'b' == True\n    isAlphaNum 'E' == True\n    isAlphaNum 'Y' == True\n    isAlphaNum '0' == True\n    isAlphaNum '7' == True\n\n    isAlphaNum '-' == False\n    isAlphaNum '' == False\n-}\nisAlphaNum : Char -> Bool\nisAlphaNum char =\n  isLower char || isUpper char || isDigit char\n\n\n{-| Detect digits `0123456789`\n\n    isDigit '0' == True\n    isDigit '1' == True\n    ...\n    isDigit '9' == True\n\n    isDigit 'a' == False\n    isDigit 'b' == False\n    isDigit 'A' == False\n-}\nisDigit : Char -> Bool\nisDigit char =\n  let\n    code =\n      toCode char\n  in\n    code <= 0x39 && 0x30 <= code\n\n\n{-| Detect octal digits `01234567`\n\n    isOctDigit '0' == True\n    isOctDigit '1' == True\n    ...\n    isOctDigit '7' == True\n\n    isOctDigit '8' == False\n    isOctDigit 'a' == False\n    isOctDigit 'A' == False\n-}\nisOctDigit : Char -> Bool\nisOctDigit char =\n  let\n    code =\n      toCode char\n  in\n    code <= 0x37 && 0x30 <= code\n\n\n{-| Detect hexadecimal digits `0123456789abcdefABCDEF`\n-}\nisHexDigit : Char -> Bool\nisHexDigit char =\n  let\n    code =\n      toCode char\n  in\n    (0x30 <= code && code <= 0x39)\n    || (0x41 <= code && code <= 0x46)\n    || (0x61 <= code && code <= 0x66)\n\n\n\n-- CONVERSIONS\n\n\n{-| Convert to upper case. -}\ntoUpper : Char -> Char\ntoUpper =\n  Elm.Kernel.Char.toUpper\n\n\n{-| Convert to lower case. -}\ntoLower : Char -> Char\ntoLower =\n  Elm.Kernel.Char.toLower\n\n\n{-| Convert to upper case, according to any locale-specific case mappings. -}\ntoLocaleUpper : Char -> Char\ntoLocaleUpper =\n  Elm.Kernel.Char.toLocaleUpper\n\n\n{-| Convert to lower case, according to any locale-specific case mappings. -}\ntoLocaleLower : Char -> Char\ntoLocaleLower =\n  Elm.Kernel.Char.toLocaleLower\n\n\n{-| Convert to the corresponding Unicode [code point][cp].\n\n[cp]: https://en.wikipedia.org/wiki/Code_point\n\n    toCode 'A' == 65\n    toCode 'B' == 66\n    toCode '' == 0x6728\n    toCode '' == 0x1D306\n    toCode '' == 0x1F603\n-}\ntoCode : Char -> Int\ntoCode =\n  Elm.Kernel.Char.toCode\n\n\n{-| Convert a Unicode [code point][cp] to a character.\n\n    fromCode 65      == 'A'\n    fromCode 66      == 'B'\n    fromCode 0x6728  == ''\n    fromCode 0x1D306 == ''\n    fromCode 0x1F603 == ''\n    fromCode -1      == ''\n\nThe full range of unicode is from `0` to `0x10FFFF`. With numbers outside that\nrange, you get [the replacement character][fffd].\n\n[cp]: https://en.wikipedia.org/wiki/Code_point\n[fffd]: https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character\n-}\nfromCode : Int -> Char\nfromCode =\n  Elm.Kernel.Char.fromCode\n" })
        )
        ,( "List.elm"
        , BlobNode ({ utf8 = "module List exposing\n  ( singleton, repeat, range, (::)\n  , map, indexedMap, foldl, foldr, filter, filterMap\n  , length, reverse, member, all, any, maximum, minimum, sum, product\n  , append, concat, concatMap, intersperse, map2, map3, map4, map5\n  , sort, sortBy, sortWith\n  , isEmpty, head, tail, take, drop, partition, unzip\n  )\n\n{-| You can create a `List` in Elm with the `[1,2,3]` syntax, so lists are\nused all over the place. This module has a bunch of functions to help you work\nwith them!\n\n# Create\n@docs singleton, repeat, range, (::)\n\n# Transform\n@docs map, indexedMap, foldl, foldr, filter, filterMap\n\n# Utilities\n@docs length, reverse, member, all, any, maximum, minimum, sum, product\n\n# Combine\n@docs append, concat, concatMap, intersperse, map2, map3, map4, map5\n\n# Sort\n@docs sort, sortBy, sortWith\n\n# Deconstruct\n@docs isEmpty, head, tail, take, drop, partition, unzip\n\n-}\n\nimport Basics exposing (..)\nimport Elm.Kernel.List\nimport Maybe exposing ( Maybe(..) )\n\n\n\n\ninfix right 5 (::) = cons\n\n\n\n-- CREATE\n\n\n\n{-| Create a list with only one element:\n\n    singleton 1234 == [1234]\n    singleton \"hi\" == [\"hi\"]\n-}\nsingleton : a -> List a\nsingleton value =\n  [value]\n\n\n{-| Create a list with *n* copies of a value:\n\n    repeat 3 (0,0) == [(0,0),(0,0),(0,0)]\n-}\nrepeat : Int -> a -> List a\nrepeat n value =\n  repeatHelp [] n value\n\n\nrepeatHelp : List a -> Int -> a -> List a\nrepeatHelp result n value =\n  if n <= 0 then\n    result\n\n  else\n    repeatHelp (cons value result) (n-1) value\n\n\n{-| Create a list of numbers, every element increasing by one.\nYou give the lowest and highest number that should be in the list.\n\n    range 3 6 == [3, 4, 5, 6]\n    range 3 3 == [3]\n    range 6 3 == []\n-}\nrange : Int -> Int -> List Int\nrange lo hi =\n  rangeHelp lo hi []\n\n\nrangeHelp : Int -> Int -> List Int -> List Int\nrangeHelp lo hi list =\n  if lo <= hi then\n    rangeHelp lo (hi - 1) (cons hi list)\n\n  else\n    list\n\n\n{-| Add an element to the front of a list.\n\n    1 :: [2,3] == [1,2,3]\n    1 :: [] == [1]\n\nThis operator is pronounced *cons* for historical reasons, but you can think\nof it like pushing an entry onto a stack.\n-}\ncons : a -> List a -> List a\ncons =\n  Elm.Kernel.List.cons\n\n\n\n-- TRANSFORM\n\n\n{-| Apply a function to every element of a list.\n\n    map sqrt [1,4,9] == [1,2,3]\n\n    map not [True,False,True] == [False,True,False]\n\nSo `map func [ a, b, c ]` is the same as `[ func a, func b, func c ]`\n-}\nmap : (a -> b) -> List a -> List b\nmap f xs =\n  foldr (\\x acc -> cons (f x) acc) [] xs\n\n\n{-| Same as `map` but the function is also applied to the index of each\nelement (starting at zero).\n\n    indexedMap Tuple.pair [\"Tom\",\"Sue\",\"Bob\"] == [ (0,\"Tom\"), (1,\"Sue\"), (2,\"Bob\") ]\n-}\nindexedMap : (Int -> a -> b) -> List a -> List b\nindexedMap f xs =\n  map2 f (range 0 (length xs - 1)) xs\n\n\n{-| Reduce a list from the left.\n\n    foldl (+)  0  [1,2,3] == 6\n    foldl (::) [] [1,2,3] == [3,2,1]\n\nSo `foldl step state [1,2,3]` is like saying:\n\n    state\n      |> step 1\n      |> step 2\n      |> step 3\n-}\nfoldl : (a -> b -> b) -> b -> List a -> b\nfoldl func acc list =\n  case list of\n    [] ->\n      acc\n\n    x :: xs ->\n      foldl func (func x acc) xs\n\n\n{-| Reduce a list from the right.\n\n    foldr (+)  0  [1,2,3] == 6\n    foldr (::) [] [1,2,3] == [1,2,3]\n\nSo `foldr step state [1,2,3]` is like saying:\n\n    state\n      |> step 3\n      |> step 2\n      |> step 1\n-}\nfoldr : (a -> b -> b) -> b -> List a -> b\nfoldr fn acc ls =\n    foldrHelper fn acc 0 ls\n\n\nfoldrHelper : (a -> b -> b) -> b -> Int -> List a -> b\nfoldrHelper fn acc ctr ls =\n    case ls of\n        [] ->\n            acc\n\n        a :: r1 ->\n            case r1 of\n                [] ->\n                    fn a acc\n\n                b :: r2 ->\n                    case r2 of\n                        [] ->\n                            fn a (fn b acc)\n\n                        c :: r3 ->\n                            case r3 of\n                                [] ->\n                                    fn a (fn b (fn c acc))\n\n                                d :: r4 ->\n                                    let\n                                        res =\n                                            if ctr > 500 then\n                                                foldl fn acc (reverse r4)\n                                            else\n                                                foldrHelper fn acc (ctr + 1) r4\n                                    in\n                                        fn a (fn b (fn c (fn d res)))\n\n\n{-| Keep elements that satisfy the test.\n\n    filter isEven [1,2,3,4,5,6] == [2,4,6]\n-}\nfilter : (a -> Bool) -> List a -> List a\nfilter isGood list =\n  foldr (\\x xs -> if isGood x then cons x xs else xs) [] list\n\n\n{-| Filter out certain values. For example, maybe you have a bunch of strings\nfrom an untrusted source and you want to turn them into numbers:\n\n    numbers : List Int\n    numbers =\n      filterMap String.toInt [\"3\", \"hi\", \"12\", \"4th\", \"May\"]\n\n    -- numbers == [3, 12]\n\n-}\nfilterMap : (a -> Maybe b) -> List a -> List b\nfilterMap f xs =\n  foldr (maybeCons f) [] xs\n\n\nmaybeCons : (a -> Maybe b) -> a -> List b -> List b\nmaybeCons f mx xs =\n  case f mx of\n    Just x ->\n      cons x xs\n\n    Nothing ->\n      xs\n\n\n-- UTILITIES\n\n\n{-| Determine the length of a list.\n\n    length [1,2,3] == 3\n-}\nlength : List a -> Int\nlength xs =\n  foldl (\\_ i -> i + 1) 0 xs\n\n\n{-| Reverse a list.\n\n    reverse [1,2,3,4] == [4,3,2,1]\n-}\nreverse : List a -> List a\nreverse list =\n  foldl cons [] list\n\n\n{-| Figure out whether a list contains a value.\n\n    member 9 [1,2,3,4] == False\n    member 4 [1,2,3,4] == True\n-}\nmember : a -> List a -> Bool\nmember x xs =\n  any (\\a -> a == x) xs\n\n\n{-| Determine if all elements satisfy some test.\n\n    all isEven [2,4] == True\n    all isEven [2,3] == False\n    all isEven [] == True\n-}\nall : (a -> Bool) -> List a -> Bool\nall isOkay list =\n  not (any (not << isOkay) list)\n\n\n{-| Determine if any elements satisfy some test.\n\n    any isEven [2,3] == True\n    any isEven [1,3] == False\n    any isEven [] == False\n-}\nany : (a -> Bool) -> List a -> Bool\nany isOkay list =\n  case list of\n    [] ->\n      False\n\n    x :: xs ->\n      -- note: (isOkay x || any isOkay xs) would not get TCO\n      if isOkay x then\n        True\n\n      else\n        any isOkay xs\n\n\n{-| Find the maximum element in a non-empty list.\n\n    maximum [1,4,2] == Just 4\n    maximum []      == Nothing\n-}\nmaximum : List comparable -> Maybe comparable\nmaximum list =\n  case list of\n    x :: xs ->\n      Just (foldl max x xs)\n\n    _ ->\n      Nothing\n\n\n{-| Find the minimum element in a non-empty list.\n\n    minimum [3,2,1] == Just 1\n    minimum []      == Nothing\n-}\nminimum : List comparable -> Maybe comparable\nminimum list =\n  case list of\n    x :: xs ->\n      Just (foldl min x xs)\n\n    _ ->\n      Nothing\n\n\n{-| Get the sum of the list elements.\n\n    sum [1,2,3] == 6\n    sum [1,1,1] == 3\n    sum []      == 0\n\n-}\nsum : List number -> number\nsum numbers =\n  foldl (+) 0 numbers\n\n\n{-| Get the product of the list elements.\n\n    product [2,2,2] == 8\n    product [3,3,3] == 27\n    product []      == 1\n\n-}\nproduct : List number -> number\nproduct numbers =\n  foldl (*) 1 numbers\n\n\n\n-- COMBINE\n\n\n{-| Put two lists together.\n\n    append [1,1,2] [3,5,8] == [1,1,2,3,5,8]\n    append ['a','b'] ['c'] == ['a','b','c']\n\nYou can also use [the `(++)` operator](Basics#++) to append lists.\n-}\nappend : List a -> List a -> List a\nappend xs ys =\n  case ys of\n    [] ->\n      xs\n\n    _ ->\n      foldr cons ys xs\n\n\n{-| Concatenate a bunch of lists into a single list:\n\n    concat [[1,2],[3],[4,5]] == [1,2,3,4,5]\n-}\nconcat : List (List a) -> List a\nconcat lists =\n  foldr append [] lists\n\n\n{-| Map a given function onto a list and flatten the resulting lists.\n\n    concatMap f xs == concat (map f xs)\n-}\nconcatMap : (a -> List b) -> List a -> List b\nconcatMap f list =\n  concat (map f list)\n\n\n{-| Places the given value between all members of the given list.\n\n    intersperse \"on\" [\"turtles\",\"turtles\",\"turtles\"] == [\"turtles\",\"on\",\"turtles\",\"on\",\"turtles\"]\n-}\nintersperse : a -> List a -> List a\nintersperse sep xs =\n  case xs of\n    [] ->\n      []\n\n    hd :: tl ->\n      let\n        step x rest =\n          cons sep (cons x rest)\n\n        spersed =\n          foldr step [] tl\n      in\n        cons hd spersed\n\n\n{-| Combine two lists, combining them with the given function.\nIf one list is longer, the extra elements are dropped.\n\n    totals : List Int -> List Int -> List Int\n    totals xs ys =\n      List.map2 (+) xs ys\n\n    -- totals [1,2,3] [4,5,6] == [5,7,9]\n\n    pairs : List a -> List b -> List (a,b)\n    pairs xs ys =\n      List.map2 Tuple.pair xs ys\n\n    -- pairs [\"alice\",\"bob\",\"chuck\"] [2,5,7,8]\n    --   == [(\"alice\",2),(\"bob\",5),(\"chuck\",7)]\n\n-}\nmap2 : (a -> b -> result) -> List a -> List b -> List result\nmap2 =\n  Elm.Kernel.List.map2\n\n\n{-|-}\nmap3 : (a -> b -> c -> result) -> List a -> List b -> List c -> List result\nmap3 =\n  Elm.Kernel.List.map3\n\n\n{-|-}\nmap4 : (a -> b -> c -> d -> result) -> List a -> List b -> List c -> List d -> List result\nmap4 =\n  Elm.Kernel.List.map4\n\n\n{-|-}\nmap5 : (a -> b -> c -> d -> e -> result) -> List a -> List b -> List c -> List d -> List e -> List result\nmap5 =\n  Elm.Kernel.List.map5\n\n\n\n-- SORT\n\n\n{-| Sort values from lowest to highest\n\n    sort [3,1,5] == [1,3,5]\n-}\nsort : List comparable -> List comparable\nsort xs =\n  sortBy identity xs\n\n\n{-| Sort values by a derived property.\n\n    alice = { name=\"Alice\", height=1.62 }\n    bob   = { name=\"Bob\"  , height=1.85 }\n    chuck = { name=\"Chuck\", height=1.76 }\n\n    sortBy .name   [chuck,alice,bob] == [alice,bob,chuck]\n    sortBy .height [chuck,alice,bob] == [alice,chuck,bob]\n\n    sortBy String.length [\"mouse\",\"cat\"] == [\"cat\",\"mouse\"]\n-}\nsortBy : (a -> comparable) -> List a -> List a\nsortBy =\n  Elm.Kernel.List.sortBy\n\n\n{-| Sort values with a custom comparison function.\n\n    sortWith flippedComparison [1,2,3,4,5] == [5,4,3,2,1]\n\n    flippedComparison a b =\n        case compare a b of\n          LT -> GT\n          EQ -> EQ\n          GT -> LT\n\nThis is also the most general sort function, allowing you\nto define any other: `sort == sortWith compare`\n-}\nsortWith : (a -> a -> Order) -> List a -> List a\nsortWith =\n  Elm.Kernel.List.sortWith\n\n\n\n-- DECONSTRUCT\n\n\n{-| Determine if a list is empty.\n\n    isEmpty [] == True\n\n**Note:** It is usually preferable to use a `case` to test this so you do not\nforget to handle the `(x :: xs)` case as well!\n-}\nisEmpty : List a -> Bool\nisEmpty xs =\n  case xs of\n    [] ->\n      True\n\n    _ ->\n      False\n\n\n{-| Extract the first element of a list.\n\n    head [1,2,3] == Just 1\n    head [] == Nothing\n\n**Note:** It is usually preferable to use a `case` to deconstruct a `List`\nbecause it gives you `(x :: xs)` and you can work with both subparts.\n-}\nhead : List a -> Maybe a\nhead list =\n  case list of\n    x :: xs ->\n      Just x\n\n    [] ->\n      Nothing\n\n\n{-| Extract the rest of the list.\n\n    tail [1,2,3] == Just [2,3]\n    tail [] == Nothing\n\n**Note:** It is usually preferable to use a `case` to deconstruct a `List`\nbecause it gives you `(x :: xs)` and you can work with both subparts.\n-}\ntail : List a -> Maybe (List a)\ntail list =\n  case list of\n    x :: xs ->\n      Just xs\n\n    [] ->\n      Nothing\n\n\n{-| Take the first *n* members of a list.\n\n    take 2 [1,2,3,4] == [1,2]\n-}\ntake : Int -> List a -> List a\ntake n list =\n  takeFast 0 n list\n\n\ntakeFast : Int -> Int -> List a -> List a\ntakeFast ctr n list =\n  if n <= 0 then\n    []\n  else\n    case ( n, list ) of\n      ( _, [] ) ->\n        list\n\n      ( 1, x :: _ ) ->\n        [ x ]\n\n      ( 2, x :: y :: _ ) ->\n        [ x, y ]\n\n      ( 3, x :: y :: z :: _ ) ->\n        [ x, y, z ]\n\n      ( _, x :: y :: z :: w :: tl ) ->\n        if ctr > 1000 then\n          cons x (cons y (cons z (cons w (takeTailRec (n - 4) tl))))\n        else\n          cons x (cons y (cons z (cons w (takeFast (ctr + 1) (n - 4) tl))))\n\n      _ ->\n        list\n\ntakeTailRec : Int -> List a -> List a\ntakeTailRec n list =\n  reverse (takeReverse n list [])\n\n\ntakeReverse : Int -> List a -> List a -> List a\ntakeReverse n list kept =\n  if n <= 0 then\n    kept\n  else\n    case list of\n      [] ->\n        kept\n\n      x :: xs ->\n        takeReverse (n - 1) xs (cons x kept)\n\n\n{-| Drop the first *n* members of a list.\n\n    drop 2 [1,2,3,4] == [3,4]\n-}\ndrop : Int -> List a -> List a\ndrop n list =\n  if n <= 0 then\n    list\n\n  else\n    case list of\n      [] ->\n        list\n\n      x :: xs ->\n        drop (n-1) xs\n\n\n{-| Partition a list based on some test. The first list contains all values\nthat satisfy the test, and the second list contains all the value that do not.\n\n    partition (\\x -> x < 3) [0,1,2,3,4,5] == ([0,1,2], [3,4,5])\n    partition isEven        [0,1,2,3,4,5] == ([0,2,4], [1,3,5])\n-}\npartition : (a -> Bool) -> List a -> (List a, List a)\npartition pred list =\n  let\n    step x (trues, falses) =\n      if pred x then\n        (cons x trues, falses)\n\n      else\n        (trues, cons x falses)\n  in\n    foldr step ([],[]) list\n\n\n{-| Decompose a list of tuples into a tuple of lists.\n\n    unzip [(0, True), (17, False), (1337, True)] == ([0,17,1337], [True,False,True])\n-}\nunzip : List (a,b) -> (List a, List b)\nunzip pairs =\n  let\n    step (x,y) (xs,ys) =\n      (cons x xs, cons y ys)\n  in\n    foldr step ([], []) pairs\n" })
        )
        ,( "Maybe.elm"
        , BlobNode ({ utf8 = "module Maybe exposing\n  ( Maybe(..)\n  , andThen\n  , map, map2, map3, map4, map5\n  , withDefault\n  )\n\n{-| This library fills a bunch of important niches in Elm. A `Maybe` can help\nyou with optional arguments, error handling, and records with optional fields.\n\n# Definition\n@docs Maybe\n\n# Common Helpers\n@docs withDefault, map, map2, map3, map4, map5\n\n# Chaining Maybes\n@docs andThen\n-}\n\n\nimport Basics exposing (Bool(..))\n\n\n\n{-| Represent values that may or may not exist. It can be useful if you have a\nrecord field that is only filled in sometimes. Or if a function takes a value\nsometimes, but does not absolutely need it.\n\n    -- A person, but maybe we do not know their age.\n    type alias Person =\n        { name : String\n        , age : Maybe Int\n        }\n\n    tom = { name = \"Tom\", age = Just 42 }\n    sue = { name = \"Sue\", age = Nothing }\n-}\ntype Maybe a\n    = Just a\n    | Nothing\n\n\n{-| Provide a default value, turning an optional value into a normal\nvalue.  This comes in handy when paired with functions like\n[`Dict.get`](Dict#get) which gives back a `Maybe`.\n\n    withDefault 100 (Just 42)   -- 42\n    withDefault 100 Nothing     -- 100\n\n    withDefault \"unknown\" (Dict.get \"Tom\" Dict.empty)   -- \"unknown\"\n\n**Note:** This can be overused! Many cases are better handled by a `case`\nexpression. And if you end up using `withDefault` a lot, it can be a good sign\nthat a [custom type][ct] will clean your code up quite a bit!\n\n[ct]: https://guide.elm-lang.org/types/custom_types.html\n-}\nwithDefault : a -> Maybe a -> a\nwithDefault default maybe =\n    case maybe of\n      Just value -> value\n      Nothing -> default\n\n\n{-| Transform a `Maybe` value with a given function:\n\n    map sqrt (Just 9) == Just 3\n    map sqrt Nothing  == Nothing\n\n    map sqrt (String.toFloat \"9\") == Just 3\n    map sqrt (String.toFloat \"x\") == Nothing\n\n-}\nmap : (a -> b) -> Maybe a -> Maybe b\nmap f maybe =\n  case maybe of\n    Just value ->\n      Just (f value)\n\n    Nothing ->\n      Nothing\n\n\n{-| Apply a function if all the arguments are `Just` a value.\n\n    map2 (+) (Just 3) (Just 4) == Just 7\n    map2 (+) (Just 3) Nothing == Nothing\n    map2 (+) Nothing (Just 4) == Nothing\n\n    map2 (+) (String.toInt \"1\") (String.toInt \"123\") == Just 124\n    map2 (+) (String.toInt \"x\") (String.toInt \"123\") == Nothing\n    map2 (+) (String.toInt \"1\") (String.toInt \"1.3\") == Nothing\n-}\nmap2 : (a -> b -> value) -> Maybe a -> Maybe b -> Maybe value\nmap2 func ma mb =\n  case ma of\n    Nothing ->\n      Nothing\n\n    Just a ->\n      case mb of\n        Nothing ->\n          Nothing\n\n        Just b ->\n          Just (func a b)\n\n\n{-|-}\nmap3 : (a -> b -> c -> value) -> Maybe a -> Maybe b -> Maybe c -> Maybe value\nmap3 func ma mb mc =\n  case ma of\n    Nothing ->\n      Nothing\n\n    Just a ->\n      case mb of\n        Nothing ->\n          Nothing\n\n        Just b ->\n          case mc of\n            Nothing ->\n              Nothing\n\n            Just c ->\n              Just (func a b c)\n\n\n{-|-}\nmap4 : (a -> b -> c -> d -> value) -> Maybe a -> Maybe b -> Maybe c -> Maybe d -> Maybe value\nmap4 func ma mb mc md =\n  case ma of\n    Nothing ->\n      Nothing\n\n    Just a ->\n      case mb of\n        Nothing ->\n          Nothing\n\n        Just b ->\n          case mc of\n            Nothing ->\n              Nothing\n\n            Just c ->\n              case md of\n                Nothing ->\n                  Nothing\n\n                Just d ->\n                  Just (func a b c d)\n\n\n{-|-}\nmap5 : (a -> b -> c -> d -> e -> value) -> Maybe a -> Maybe b -> Maybe c -> Maybe d -> Maybe e -> Maybe value\nmap5 func ma mb mc md me =\n  case ma of\n    Nothing ->\n      Nothing\n\n    Just a ->\n      case mb of\n        Nothing ->\n          Nothing\n\n        Just b ->\n          case mc of\n            Nothing ->\n              Nothing\n\n            Just c ->\n              case md of\n                Nothing ->\n                  Nothing\n\n                Just d ->\n                  case me of\n                    Nothing ->\n                      Nothing\n\n                    Just e ->\n                      Just (func a b c d e)\n\n\n{-| Chain together many computations that may fail. It is helpful to see its\ndefinition:\n\n    andThen : (a -> Maybe b) -> Maybe a -> Maybe b\n    andThen callback maybe =\n        case maybe of\n            Just value ->\n                callback value\n\n            Nothing ->\n                Nothing\n\nThis means we only continue with the callback if things are going well. For\nexample, say you need to parse some user input as a month:\n\n    parseMonth : String -> Maybe Int\n    parseMonth userInput =\n        String.toInt userInput\n          |> andThen toValidMonth\n\n    toValidMonth : Int -> Maybe Int\n    toValidMonth month =\n        if 1 <= month && month <= 12 then\n            Just month\n        else\n            Nothing\n\nIn the `parseMonth` function, if `String.toInt` produces `Nothing` (because\nthe `userInput` was not an integer) this entire chain of operations will\nshort-circuit and result in `Nothing`. If `toValidMonth` results in `Nothing`,\nagain the chain of computations will result in `Nothing`.\n-}\nandThen : (a -> Maybe b) -> Maybe a -> Maybe b\nandThen callback maybeValue =\n    case maybeValue of\n        Just value ->\n            callback value\n\n        Nothing ->\n            Nothing\n\n\n\n-- FOR INTERNAL USE ONLY\n--\n-- Use `case` expressions for this in Elm code!\n\n\nisJust : Maybe a -> Bool\nisJust maybe =\n  case maybe of\n    Just _ ->\n      True\n\n    Nothing ->\n      False\n\n\ndestruct : b -> (a -> b) -> Maybe a -> b\ndestruct default func maybe =\n  case maybe of\n    Just a ->\n      func a\n\n    Nothing ->\n      default\n" })
        )
        ,( "Result.elm"
        , BlobNode ({ utf8 = "module Result exposing\n  ( Result(..)\n  , withDefault\n  , map, map2, map3, map4, map5\n  , andThen\n  , toMaybe, fromMaybe, mapError\n  )\n\n{-| A `Result` is the result of a computation that may fail. This is a great\nway to manage errors in Elm.\n\n# Type and Constructors\n@docs Result\n\n# Mapping\n@docs map, map2, map3, map4, map5\n\n# Chaining\n@docs andThen\n\n# Handling Errors\n@docs withDefault, toMaybe, fromMaybe, mapError\n-}\n\nimport Basics exposing ( Bool(..) )\nimport Maybe exposing ( Maybe(..) )\n\n\n{-| A `Result` is either `Ok` meaning the computation succeeded, or it is an\n`Err` meaning that there was some failure.\n-}\ntype Result error value\n    = Ok value\n    | Err error\n\n\n{-| If the result is `Ok` return the value, but if the result is an `Err` then\nreturn a given default value. The following examples try to parse integers.\n\n    Result.withDefault 0 (Ok 123)   == 123\n    Result.withDefault 0 (Err \"no\") == 0\n-}\nwithDefault : a -> Result x a -> a\nwithDefault def result =\n  case result of\n    Ok a ->\n        a\n\n    Err _ ->\n        def\n\n\n{-| Apply a function to a result. If the result is `Ok`, it will be converted.\nIf the result is an `Err`, the same error value will propagate through.\n\n    map sqrt (Ok 4.0)          == Ok 2.0\n    map sqrt (Err \"bad input\") == Err \"bad input\"\n-}\nmap : (a -> value) -> Result x a -> Result x value\nmap func ra =\n  case ra of\n    Ok a ->\n      Ok (func a)\n\n    Err e ->\n      Err e\n\n\n{-| Apply a function if both results are `Ok`. If not, the first `Err` will\npropagate through.\n\n    map2 max (Ok 42)   (Ok 13)   == Ok 42\n    map2 max (Err \"x\") (Ok 13)   == Err \"x\"\n    map2 max (Ok 42)   (Err \"y\") == Err \"y\"\n    map2 max (Err \"x\") (Err \"y\") == Err \"x\"\n\nThis can be useful if you have two computations that may fail, and you want\nto put them together quickly.\n-}\nmap2 : (a -> b -> value) -> Result x a -> Result x b -> Result x value\nmap2 func ra rb =\n  case ra of\n    Err x ->\n      Err x\n\n    Ok a ->\n      case rb of\n        Err x ->\n          Err x\n\n        Ok b ->\n          Ok (func a b)\n\n\n{-|-}\nmap3 : (a -> b -> c -> value) -> Result x a -> Result x b -> Result x c -> Result x value\nmap3 func ra rb rc =\n  case ra of\n    Err x ->\n      Err x\n\n    Ok a ->\n      case rb of\n        Err x ->\n          Err x\n\n        Ok b ->\n          case rc of\n            Err x ->\n              Err x\n\n            Ok c ->\n              Ok (func a b c)\n\n\n{-|-}\nmap4 : (a -> b -> c -> d -> value) -> Result x a -> Result x b -> Result x c -> Result x d -> Result x value\nmap4 func ra rb rc rd =\n  case ra of\n    Err x ->\n      Err x\n\n    Ok a ->\n      case rb of\n        Err x ->\n          Err x\n\n        Ok b ->\n          case rc of\n            Err x ->\n              Err x\n\n            Ok c ->\n              case rd of\n                Err x ->\n                  Err x\n\n                Ok d ->\n                  Ok (func a b c d)\n\n\n{-|-}\nmap5 : (a -> b -> c -> d -> e -> value) -> Result x a -> Result x b -> Result x c -> Result x d -> Result x e -> Result x value\nmap5 func ra rb rc rd re =\n  case ra of\n    Err x ->\n      Err x\n\n    Ok a ->\n      case rb of\n        Err x ->\n          Err x\n\n        Ok b ->\n          case rc of\n            Err x ->\n              Err x\n\n            Ok c ->\n              case rd of\n                Err x ->\n                  Err x\n\n                Ok d ->\n                  case re of\n                    Err x ->\n                      Err x\n\n                    Ok e ->\n                      Ok (func a b c d e)\n\n\n{-| Chain together a sequence of computations that may fail. It is helpful\nto see its definition:\n\n    andThen : (a -> Result e b) -> Result e a -> Result e b\n    andThen callback result =\n        case result of\n          Ok value -> callback value\n          Err msg -> Err msg\n\nThis means we only continue with the callback if things are going well. For\nexample, say you need to use (`toInt : String -> Result String Int`) to parse\na month and make sure it is between 1 and 12:\n\n    toValidMonth : Int -> Result String Int\n    toValidMonth month =\n        if month >= 1 && month <= 12\n            then Ok month\n            else Err \"months must be between 1 and 12\"\n\n    toMonth : String -> Result String Int\n    toMonth rawString =\n        toInt rawString\n          |> andThen toValidMonth\n\n    -- toMonth \"4\" == Ok 4\n    -- toMonth \"9\" == Ok 9\n    -- toMonth \"a\" == Err \"cannot parse to an Int\"\n    -- toMonth \"0\" == Err \"months must be between 1 and 12\"\n\nThis allows us to come out of a chain of operations with quite a specific error\nmessage. It is often best to create a custom type that explicitly represents\nthe exact ways your computation may fail. This way it is easy to handle in your\ncode.\n-}\nandThen : (a -> Result x b) -> Result x a -> Result x b\nandThen callback result =\n    case result of\n      Ok value ->\n        callback value\n\n      Err msg ->\n        Err msg\n\n\n{-| Transform an `Err` value. For example, say the errors we get have too much\ninformation:\n\n    parseInt : String -> Result ParseError Int\n\n    type alias ParseError =\n        { message : String\n        , code : Int\n        , position : (Int,Int)\n        }\n\n    mapError .message (parseInt \"123\") == Ok 123\n    mapError .message (parseInt \"abc\") == Err \"char 'a' is not a number\"\n-}\nmapError : (x -> y) -> Result x a -> Result y a\nmapError f result =\n    case result of\n      Ok v ->\n        Ok v\n\n      Err e ->\n        Err (f e)\n\n\n{-| Convert to a simpler `Maybe` if the actual error message is not needed or\nyou need to interact with some code that primarily uses maybes.\n\n    parseInt : String -> Result ParseError Int\n\n    maybeParseInt : String -> Maybe Int\n    maybeParseInt string =\n        toMaybe (parseInt string)\n-}\ntoMaybe : Result x a -> Maybe a\ntoMaybe result =\n    case result of\n      Ok  v -> Just v\n      Err _ -> Nothing\n\n\n{-| Convert from a simple `Maybe` to interact with some code that primarily\nuses `Results`.\n\n    parseInt : String -> Maybe Int\n\n    resultParseInt : String -> Result String Int\n    resultParseInt string =\n        fromMaybe (\"error parsing string: \" ++ toString string) (parseInt string)\n-}\nfromMaybe : x -> Maybe a -> Result x a\nfromMaybe err maybe =\n    case maybe of\n      Just v  -> Ok v\n      Nothing -> Err err\n\n\n\n-- FOR INTERNAL USE ONLY\n--\n-- Use `case` expressions for this in Elm code!\n\n\nisOk : Result x a -> Bool\nisOk result =\n  case result of\n    Ok _ ->\n      True\n\n    Err _ ->\n      False\n" })
        )
        ,( "String.elm"
        , BlobNode ({ utf8 = "module String exposing\n  ( String\n  , isEmpty, length, reverse, repeat, replace\n  , append, concat, split, join, words, lines\n  , slice, left, right, dropLeft, dropRight\n  , contains, startsWith, endsWith, indexes, indices\n  , toInt, fromInt\n  , toFloat, fromFloat\n  , fromChar, cons, uncons\n  , toList, fromList\n  , toUpper, toLower, pad, padLeft, padRight, trim, trimLeft, trimRight\n  , map, filter, foldl, foldr, any, all\n  )\n\n{-| A built-in representation for efficient string manipulation. String literals\nare enclosed in `\"double quotes\"`. Strings are *not* lists of characters.\n\n# Strings\n@docs String, isEmpty, length, reverse, repeat, replace\n\n# Building and Splitting\n@docs append, concat, split, join, words, lines\n\n# Get Substrings\n@docs slice, left, right, dropLeft, dropRight\n\n# Check for Substrings\n@docs contains, startsWith, endsWith, indexes, indices\n\n# Int Conversions\n@docs toInt, fromInt\n\n# Float Conversions\n@docs toFloat, fromFloat\n\n# Char Conversions\n@docs fromChar, cons, uncons\n\n# List Conversions\n@docs toList, fromList\n\n# Formatting\nCosmetic operations such as padding with extra characters or trimming whitespace.\n\n@docs toUpper, toLower, pad, padLeft, padRight, trim, trimLeft, trimRight\n\n# Higher-Order Functions\n@docs map, filter, foldl, foldr, any, all\n-}\n\nimport Basics exposing (..)\nimport Bitwise\nimport Char exposing (Char)\nimport Elm.Kernel.List\nimport Elm.Kernel.String\nimport List exposing ((::))\nimport Maybe exposing (Maybe)\nimport Result exposing (Result)\n\n\n\n-- STRINGS\n\n\n{-| A `String` is a chunk of text:\n\n    \"Hello!\"\n    \"How are you?\"\n    \"\"\n\n    -- strings with escape characters\n    \"this\\n\\t\\\"that\\\"\"\n    \"\\u{1F648}\\u{1F649}\\u{1F64A}\" -- \"\"\n\n    -- multiline strings\n    \"\"\"Triple double quotes let you\n    create \"multiline strings\" which\n    can have unescaped quotes and newlines.\n    \"\"\"\n\nA `String` can represent any sequence of [unicode characters][u]. You can use\nthe unicode escapes from `\\u{0000}` to `\\u{10FFFF}` to represent characters\nby their code point. You can also include the unicode characters directly.\nUsing the escapes can be better if you need one of the many whitespace\ncharacters with different widths.\n\n[u]: https://en.wikipedia.org/wiki/Unicode\n\n**Note:** JavaScript lets you use double quotes and single quotes interchangably.\nThis is not true in Elm. You must use double quotes for a `String`, and you must\nuse single quotes for a [`Char`](Char#Char).\n-}\ntype String = String -- NOTE: The compiler provides the real implementation.\n\n\n{-| Determine if a string is empty.\n\n    isEmpty \"\" == True\n    isEmpty \"the world\" == False\n-}\nisEmpty : String -> Bool\nisEmpty string =\n  string == \"\"\n\n\n{-| Get the length of a string.\n\n    length \"innumerable\" == 11\n    length \"\" == 0\n\n-}\nlength : String -> Int\nlength =\n  Elm.Kernel.String.length\n\n\n{-| Reverse a string.\n\n    reverse \"stressed\" == \"desserts\"\n-}\nreverse : String -> String\nreverse =\n  Elm.Kernel.String.reverse\n\n\n{-| Repeat a string *n* times.\n\n    repeat 3 \"ha\" == \"hahaha\"\n-}\nrepeat : Int -> String -> String\nrepeat n chunk =\n  repeatHelp n chunk \"\"\n\n\nrepeatHelp : Int -> String -> String -> String\nrepeatHelp n chunk result =\n  if n <= 0 then\n    result\n  else\n    repeatHelp (Bitwise.shiftRightBy 1 n) (chunk ++ chunk) <|\n      if Bitwise.and n 1 == 0 then result else result ++ chunk\n\n\n{-| Replace all occurrences of some substring.\n\n    replace \".\" \"-\" \"Json.Decode.succeed\" == \"Json-Decode-succeed\"\n    replace \",\" \"/\" \"a,b,c,d,e\"           == \"a/b/c/d/e\"\n\n**Note:** If you need more advanced replacements, check out the\n[`elm/parser`][parser] or [`elm/regex`][regex] package.\n\n[parser]: /packages/elm/parser/latest\n[regex]: /packages/elm/regex/latest\n-}\nreplace : String -> String -> String -> String\nreplace before after string =\n  join after (split before string)\n\n\n\n-- BUILDING AND SPLITTING\n\n\n{-| Append two strings. You can also use [the `(++)` operator](Basics#++)\nto do this.\n\n    append \"butter\" \"fly\" == \"butterfly\"\n-}\nappend : String -> String -> String\nappend =\n  Elm.Kernel.String.append\n\n\n{-| Concatenate many strings into one.\n\n    concat [\"never\",\"the\",\"less\"] == \"nevertheless\"\n-}\nconcat : List String -> String\nconcat strings =\n  join \"\" strings\n\n\n{-| Split a string using a given separator.\n\n    split \",\" \"cat,dog,cow\"        == [\"cat\",\"dog\",\"cow\"]\n    split \"/\" \"home/evan/Desktop/\" == [\"home\",\"evan\",\"Desktop\", \"\"]\n\n-}\nsplit : String -> String -> List String\nsplit sep string =\n  Elm.Kernel.List.fromArray (Elm.Kernel.String.split sep string)\n\n\n{-| Put many strings together with a given separator.\n\n    join \"a\" [\"H\",\"w\",\"ii\",\"n\"]        == \"Hawaiian\"\n    join \" \" [\"cat\",\"dog\",\"cow\"]       == \"cat dog cow\"\n    join \"/\" [\"home\",\"evan\",\"Desktop\"] == \"home/evan/Desktop\"\n-}\njoin : String -> List String -> String\njoin sep chunks =\n  Elm.Kernel.String.join sep (Elm.Kernel.List.toArray chunks)\n\n\n{-| Break a string into words, splitting on chunks of whitespace.\n\n    words \"How are \\t you? \\n Good?\" == [\"How\",\"are\",\"you?\",\"Good?\"]\n-}\nwords : String -> List String\nwords =\n  Elm.Kernel.String.words\n\n\n{-| Break a string into lines, splitting on newlines.\n\n    lines \"How are you?\\nGood?\" == [\"How are you?\", \"Good?\"]\n-}\nlines : String -> List String\nlines =\n  Elm.Kernel.String.lines\n\n\n\n-- SUBSTRINGS\n\n\n{-| Take a substring given a start and end index. Negative indexes\nare taken starting from the *end* of the list.\n\n    slice  7  9 \"snakes on a plane!\" == \"on\"\n    slice  0  6 \"snakes on a plane!\" == \"snakes\"\n    slice  0 -7 \"snakes on a plane!\" == \"snakes on a\"\n    slice -6 -1 \"snakes on a plane!\" == \"plane\"\n-}\nslice : Int -> Int -> String -> String\nslice =\n  Elm.Kernel.String.slice\n\n\n{-| Take *n* characters from the left side of a string.\n\n    left 2 \"Mulder\" == \"Mu\"\n-}\nleft : Int -> String -> String\nleft n string =\n  if n < 1 then\n    \"\"\n  else\n    slice 0 n string\n\n\n{-| Take *n* characters from the right side of a string.\n\n    right 2 \"Scully\" == \"ly\"\n-}\nright : Int -> String -> String\nright n string =\n  if n < 1 then\n    \"\"\n  else\n    slice -n (length string) string\n\n\n{-| Drop *n* characters from the left side of a string.\n\n    dropLeft 2 \"The Lone Gunmen\" == \"e Lone Gunmen\"\n-}\ndropLeft : Int -> String -> String\ndropLeft n string =\n  if n < 1 then\n    string\n  else\n    slice n (length string) string\n\n\n{-| Drop *n* characters from the right side of a string.\n\n    dropRight 2 \"Cigarette Smoking Man\" == \"Cigarette Smoking M\"\n-}\ndropRight : Int -> String -> String\ndropRight n string =\n  if n < 1 then\n    string\n  else\n    slice 0 -n string\n\n\n\n-- DETECT SUBSTRINGS\n\n\n{-| See if the second string contains the first one.\n\n    contains \"the\" \"theory\" == True\n    contains \"hat\" \"theory\" == False\n    contains \"THE\" \"theory\" == False\n\n-}\ncontains : String -> String -> Bool\ncontains =\n  Elm.Kernel.String.contains\n\n\n{-| See if the second string starts with the first one.\n\n    startsWith \"the\" \"theory\" == True\n    startsWith \"ory\" \"theory\" == False\n-}\nstartsWith : String -> String -> Bool\nstartsWith =\n  Elm.Kernel.String.startsWith\n\n\n{-| See if the second string ends with the first one.\n\n    endsWith \"the\" \"theory\" == False\n    endsWith \"ory\" \"theory\" == True\n-}\nendsWith : String -> String -> Bool\nendsWith =\n  Elm.Kernel.String.endsWith\n\n\n{-| Get all of the indexes for a substring in another string.\n\n    indexes \"i\" \"Mississippi\"   == [1,4,7,10]\n    indexes \"ss\" \"Mississippi\"  == [2,5]\n    indexes \"needle\" \"haystack\" == []\n-}\nindexes : String -> String -> List Int\nindexes =\n  Elm.Kernel.String.indexes\n\n\n{-| Alias for `indexes`. -}\nindices : String -> String -> List Int\nindices =\n  Elm.Kernel.String.indexes\n\n\n\n-- FORMATTING\n\n\n{-| Convert a string to all upper case. Useful for case-insensitive comparisons\nand VIRTUAL YELLING.\n\n    toUpper \"skinner\" == \"SKINNER\"\n-}\ntoUpper : String -> String\ntoUpper =\n  Elm.Kernel.String.toUpper\n\n\n{-| Convert a string to all lower case. Useful for case-insensitive comparisons.\n\n    toLower \"X-FILES\" == \"x-files\"\n-}\ntoLower : String -> String\ntoLower =\n  Elm.Kernel.String.toLower\n\n\n{-| Pad a string on both sides until it has a given length.\n\n    pad 5 ' ' \"1\"   == \"  1  \"\n    pad 5 ' ' \"11\"  == \"  11 \"\n    pad 5 ' ' \"121\" == \" 121 \"\n-}\npad : Int -> Char -> String -> String\npad n char string =\n  let\n    half =\n      Basics.toFloat (n - length string) / 2\n  in\n    repeat (ceiling half) (fromChar char) ++ string ++ repeat (floor half) (fromChar char)\n\n\n{-| Pad a string on the left until it has a given length.\n\n    padLeft 5 '.' \"1\"   == \"....1\"\n    padLeft 5 '.' \"11\"  == \"...11\"\n    padLeft 5 '.' \"121\" == \"..121\"\n-}\npadLeft : Int -> Char -> String -> String\npadLeft n char string =\n  repeat (n - length string) (fromChar char) ++ string\n\n\n{-| Pad a string on the right until it has a given length.\n\n    padRight 5 '.' \"1\"   == \"1....\"\n    padRight 5 '.' \"11\"  == \"11...\"\n    padRight 5 '.' \"121\" == \"121..\"\n-}\npadRight : Int -> Char -> String -> String\npadRight n char string =\n  string ++ repeat (n - length string) (fromChar char)\n\n\n{-| Get rid of whitespace on both sides of a string.\n\n    trim \"  hats  \\n\" == \"hats\"\n-}\ntrim : String -> String\ntrim =\n  Elm.Kernel.String.trim\n\n\n{-| Get rid of whitespace on the left of a string.\n\n    trimLeft \"  hats  \\n\" == \"hats  \\n\"\n-}\ntrimLeft : String -> String\ntrimLeft =\n  Elm.Kernel.String.trimLeft\n\n\n{-| Get rid of whitespace on the right of a string.\n\n    trimRight \"  hats  \\n\" == \"  hats\"\n-}\ntrimRight : String -> String\ntrimRight =\n  Elm.Kernel.String.trimRight\n\n\n\n-- INT CONVERSIONS\n\n\n{-| Try to convert a string into an int, failing on improperly formatted strings.\n\n    String.toInt \"123\" == Just 123\n    String.toInt \"-42\" == Just -42\n    String.toInt \"3.1\" == Nothing\n    String.toInt \"31a\" == Nothing\n\nIf you are extracting a number from some raw user input, you will typically\nwant to use [`Maybe.withDefault`](Maybe#withDefault) to handle bad data:\n\n    Maybe.withDefault 0 (String.toInt \"42\") == 42\n    Maybe.withDefault 0 (String.toInt \"ab\") == 0\n-}\ntoInt : String -> Maybe Int\ntoInt =\n  Elm.Kernel.String.toInt\n\n\n{-| Convert an `Int` to a `String`.\n\n    String.fromInt 123 == \"123\"\n    String.fromInt -42 == \"-42\"\n\nCheck out [`Debug.toString`](Debug#toString) to convert *any* value to a string\nfor debugging purposes.\n-}\nfromInt : Int -> String\nfromInt =\n  Elm.Kernel.String.fromNumber\n\n\n\n-- FLOAT CONVERSIONS\n\n\n{-| Try to convert a string into a float, failing on improperly formatted strings.\n\n    String.toFloat \"123\" == Just 123.0\n    String.toFloat \"-42\" == Just -42.0\n    String.toFloat \"3.1\" == Just 3.1\n    String.toFloat \"31a\" == Nothing\n\nIf you are extracting a number from some raw user input, you will typically\nwant to use [`Maybe.withDefault`](Maybe#withDefault) to handle bad data:\n\n    Maybe.withDefault 0 (String.toFloat \"42.5\") == 42.5\n    Maybe.withDefault 0 (String.toFloat \"cats\") == 0\n-}\ntoFloat : String -> Maybe Float\ntoFloat =\n  Elm.Kernel.String.toFloat\n\n\n{-| Convert a `Float` to a `String`.\n\n    String.fromFloat 123 == \"123\"\n    String.fromFloat -42 == \"-42\"\n    String.fromFloat 3.9 == \"3.9\"\n\nCheck out [`Debug.toString`](Debug#toString) to convert *any* value to a string\nfor debugging purposes.\n-}\nfromFloat : Float -> String\nfromFloat =\n  Elm.Kernel.String.fromNumber\n\n\n\n-- LIST CONVERSIONS\n\n\n{-| Convert a string to a list of characters.\n\n    toList \"abc\" == ['a','b','c']\n    toList \"\" == ['','','']\n-}\ntoList : String -> List Char\ntoList string =\n  foldr (::) [] string\n\n\n{-| Convert a list of characters into a String. Can be useful if you\nwant to create a string primarily by consing, perhaps for decoding\nsomething.\n\n    fromList ['a','b','c'] == \"abc\"\n    fromList ['','',''] == \"\"\n-}\nfromList : List Char -> String\nfromList =\n  Elm.Kernel.String.fromList\n\n\n\n-- CHAR CONVERSIONS\n\n\n{-| Create a string from a given character.\n\n    fromChar 'a' == \"a\"\n-}\nfromChar : Char -> String\nfromChar char =\n  cons char \"\"\n\n\n{-| Add a character to the beginning of a string.\n\n    cons 'T' \"he truth is out there\" == \"The truth is out there\"\n-}\ncons : Char -> String -> String\ncons =\n  Elm.Kernel.String.cons\n\n\n{-| Split a non-empty string into its head and tail. This lets you\npattern match on strings exactly as you would with lists.\n\n    uncons \"abc\" == Just ('a',\"bc\")\n    uncons \"\"    == Nothing\n-}\nuncons : String -> Maybe (Char, String)\nuncons =\n  Elm.Kernel.String.uncons\n\n\n\n-- HIGHER-ORDER FUNCTIONS\n\n\n{-| Transform every character in a string\n\n    map (\\c -> if c == '/' then '.' else c) \"a/b/c\" == \"a.b.c\"\n-}\nmap : (Char -> Char) -> String -> String\nmap =\n  Elm.Kernel.String.map\n\n\n{-| Keep only the characters that pass the test.\n\n    filter isDigit \"R2-D2\" == \"22\"\n-}\nfilter : (Char -> Bool) -> String -> String\nfilter =\n  Elm.Kernel.String.filter\n\n\n{-| Reduce a string from the left.\n\n    foldl cons \"\" \"time\" == \"emit\"\n-}\nfoldl : (Char -> b -> b) -> b -> String -> b\nfoldl =\n  Elm.Kernel.String.foldl\n\n\n{-| Reduce a string from the right.\n\n    foldr cons \"\" \"time\" == \"time\"\n-}\nfoldr : (Char -> b -> b) -> b -> String -> b\nfoldr =\n  Elm.Kernel.String.foldr\n\n\n{-| Determine whether *any* characters pass the test.\n\n    any isDigit \"90210\" == True\n    any isDigit \"R2-D2\" == True\n    any isDigit \"heart\" == False\n-}\nany : (Char -> Bool) -> String -> Bool\nany =\n  Elm.Kernel.String.any\n\n\n{-| Determine whether *all* characters pass the test.\n\n    all isDigit \"90210\" == True\n    all isDigit \"R2-D2\" == False\n    all isDigit \"heart\" == False\n-}\nall : (Char -> Bool) -> String -> Bool\nall =\n  Elm.Kernel.String.all\n" })
        )
        ,( "Tuple.elm"
        , BlobNode ({ utf8 = "module Tuple exposing\n  ( pair\n  , first, second\n  , mapFirst, mapSecond, mapBoth\n  )\n\n{-| Elm has built-in syntax for tuples, so you can define 2D points like this:\n\n    origin : (Float, Float)\n    origin =\n      (0, 0)\n\n    position : (Float, Float)\n    position =\n      (3, 4)\n\nThis module is a bunch of helpers for working with 2-tuples.\n\n**Note 1:** For more complex data, it is best to switch to records. So instead\nof representing a 3D point as `(3,4,5)` and not having any helper functions,\nrepresent it as `{ x = 3, y = 4, z = 5 }` and use all the built-in record\nsyntax!\n\n**Note 2:** If your record contains a bunch of `Bool` and `Maybe` values,\nyou may want to upgrade to union types. Check out [Jols post][ut] for more\ninfo on this. (Picking appropriate data structures is super important in Elm!)\n\n[ut]: https://robots.thoughtbot.com/modeling-with-union-types\n\n# Create\n@docs pair\n\n# Access\n@docs first, second\n\n# Map\n@docs mapFirst, mapSecond, mapBoth\n\n-}\n\n\n\n-- CREATE\n\n\n{-| Create a 2-tuple.\n\n    -- pair 3 4 == (3, 4)\n\n    zip : List a -> List b -> List (a, b)\n    zip xs ys =\n      List.map2 Tuple.pair xs ys\n-}\npair : a -> b -> (a, b)\npair a b =\n  (a, b)\n\n\n\n-- ACCESS\n\n\n{-| Extract the first value from a tuple.\n\n    first (3, 4) == 3\n    first (\"john\", \"doe\") == \"john\"\n-}\nfirst : (a, b) -> a\nfirst (x,_) =\n  x\n\n\n{-| Extract the second value from a tuple.\n\n    second (3, 4) == 4\n    second (\"john\", \"doe\") == \"doe\"\n-}\nsecond : (a, b) -> b\nsecond (_,y) =\n  y\n\n\n\n-- MAP\n\n\n{-| Transform the first value in a tuple.\n\n    import String\n\n    mapFirst String.reverse (\"stressed\", 16) == (\"desserts\", 16)\n    mapFirst String.length  (\"stressed\", 16) == (8, 16)\n-}\nmapFirst : (a -> x) -> (a, b) -> (x, b)\nmapFirst func (x,y) =\n  (func x, y)\n\n\n{-| Transform the second value in a tuple.\n\n    mapSecond sqrt   (\"stressed\", 16) == (\"stressed\", 4)\n    mapSecond negate (\"stressed\", 16) == (\"stressed\", -16)\n-}\nmapSecond : (b -> y) -> (a, b) -> (a, y)\nmapSecond func (x,y) =\n  (x, func y)\n\n\n{-| Transform both parts of a tuple.\n\n    import String\n\n    mapBoth String.reverse sqrt  (\"stressed\", 16) == (\"desserts\", 4)\n    mapBoth String.length negate (\"stressed\", 16) == (8, -16)\n-}\nmapBoth : (a -> x) -> (b -> y) -> (a, b) -> (x, y)\nmapBoth funcA funcB (x,y) =\n  ( funcA x, funcB y )\n" })
        )]

file_tree_node_elm_kernel_modules_browser_src =
    TreeNode
        [( "Browser"
        , TreeNode
            [( "AnimationManager.elm"
            , BlobNode ({ utf8 = "effect module Browser.AnimationManager where { subscription = MySub } exposing\n    ( onAnimationFrame\n    , onAnimationFrameDelta\n    )\n\nimport Elm.Kernel.Browser\nimport Process\nimport Task exposing (Task)\nimport Time\n\n\n\n-- PUBLIC STUFF\n\n\nonAnimationFrame : (Time.Posix -> msg) -> Sub msg\nonAnimationFrame tagger =\n    subscription (Time tagger)\n\n\nonAnimationFrameDelta : (Float -> msg) -> Sub msg\nonAnimationFrameDelta tagger =\n    subscription (Delta tagger)\n\n\n\n-- SUBSCRIPTIONS\n\n\ntype MySub msg\n    = Time (Time.Posix -> msg)\n    | Delta (Float -> msg)\n\n\nsubMap : (a -> b) -> MySub a -> MySub b\nsubMap func sub =\n    case sub of\n        Time tagger ->\n            Time (func << tagger)\n\n        Delta tagger ->\n            Delta (func << tagger)\n\n\n\n-- EFFECT MANAGER\n\n\ntype alias State msg =\n    { subs : List (MySub msg)\n    , request : Maybe Process.Id\n    , oldTime : Int\n    }\n\n\n\n-- NOTE: used in onEffects\n--\n\n\ninit : Task Never (State msg)\ninit =\n    Task.succeed (State [] Nothing 0)\n\n\nonEffects : Platform.Router msg Int -> List (MySub msg) -> State msg -> Task Never (State msg)\nonEffects router subs { request, oldTime } =\n    case ( request, subs ) of\n        ( Nothing, [] ) ->\n            init\n\n        ( Just pid, [] ) ->\n            Process.kill pid\n                |> Task.andThen (\\_ -> init)\n\n        ( Nothing, _ ) ->\n            Process.spawn (Task.andThen (Platform.sendToSelf router) rAF)\n                |> Task.andThen\n                    (\\pid ->\n                        now\n                            |> Task.andThen (\\time -> Task.succeed (State subs (Just pid) time))\n                    )\n\n        ( Just _, _ ) ->\n            Task.succeed (State subs request oldTime)\n\n\nonSelfMsg : Platform.Router msg Int -> Int -> State msg -> Task Never (State msg)\nonSelfMsg router newTime { subs, oldTime } =\n    let\n        send sub =\n            case sub of\n                Time tagger ->\n                    Platform.sendToApp router (tagger (Time.millisToPosix newTime))\n\n                Delta tagger ->\n                    Platform.sendToApp router (tagger (toFloat (newTime - oldTime)))\n    in\n    Process.spawn (Task.andThen (Platform.sendToSelf router) rAF)\n        |> Task.andThen\n            (\\pid ->\n                Task.sequence (List.map send subs)\n                    |> Task.andThen (\\_ -> Task.succeed (State subs (Just pid) newTime))\n            )\n\n\nrAF : Task x Int\nrAF =\n    Elm.Kernel.Browser.rAF ()\n\n\nnow : Task x Int\nnow =\n    Elm.Kernel.Browser.now ()\n" })
            )
            ,( "Dom.elm"
            , BlobNode ({ utf8 = "module Browser.Dom exposing\n    ( focus, blur, Error(..)\n    , getViewport, Viewport, getViewportOf\n    , setViewport, setViewportOf\n    , getElement, Element\n    )\n\n{-| This module allows you to manipulate the DOM in various ways. It covers:\n\n  - Focus and blur input elements.\n  - Get the `width` and `height` of elements.\n  - Get the `x` and `y` coordinates of elements.\n  - Figure out the scroll position.\n  - Change the scroll position!\n\nWe use different terminology than JavaScript though...\n\n\n# Terminology\n\nHave you ever thought about how &ldquo;scrolling&rdquo; is a metaphor about\nscrolls? Like hanging scrolls of caligraphy made during the Han Dynasty\nin China?\n\nThis metaphor falls apart almost immediately though. For example, many scrolls\nread horizontally! Like a [Sefer Torah][torah] or [Chinese Handscrolls][hand].\nThe two sides move independently, sometimes kept in place with stones. What is\na scroll bar in this world? And [hanging scrolls][hang] (which _are_ displayed\nvertically) do not &ldquo;scroll&rdquo; at all! They hang!\n\nSo in JavaScript, we start with a badly stretched metaphor and add a bunch of\nDOM details like padding, borders, and margins. How do those relate to scrolls?\nFor example, JavaScript has `clientWidth`. Client like a feudal state that pays\ntribute to the emperor? And `offsetHeight`. Can an offset even have height? And\nwhat has that got to do with scrolls?\n\nSo instead of inheriting this metaphorical hodge-podge, we use terminology from\n3D graphics. You have a **scene** containing all your elements and a **viewport**\ninto the scene. I think it ends up being a lot clearer, but you can evaluate\nfor yourself when you see the diagrams later!\n\n**Note:** For more scroll facts, I recommend [A Day on the Grand Canal with\nthe Emperor of China or: Surface Is Illusion But So Is Depth][doc] where David\nHockney explores the history of _perspective_ in art. Really interesting!\n\n[torah]: https://en.wikipedia.org/wiki/Sefer_Torah\n[hand]: https://www.metmuseum.org/toah/hd/chhs/hd_chhs.htm\n[hang]: https://en.wikipedia.org/wiki/Hanging_scroll\n[doc]: https://www.imdb.com/title/tt0164525/\n\n\n# Focus\n\n@docs focus, blur, Error\n\n\n# Get Viewport\n\n@docs getViewport, Viewport, getViewportOf\n\n\n# Set Viewport\n\n@docs setViewport, setViewportOf\n\n\n# Position\n\n@docs getElement, Element\n\n-}\n\nimport Elm.Kernel.Browser\nimport Task exposing (Task)\n\n\n\n-- FOCUS\n\n\n{-| Find a DOM node by `id` and focus on it. So if you wanted to focus a node\nlike `<input type=\"text\" id=\"search-box\">` you could say:\n\n    import Browser.Dom as Dom\n    import Task\n\n    type Msg\n        = NoOp\n\n    focusSearchBox : Cmd Msg\n    focusSearchBox =\n        Task.attempt (\\_ -> NoOp) (Dom.focus \"search-box\")\n\nNotice that this code ignores the possibility that `search-box` is not used\nas an `id` by any node, failing silently in that case. It would be better to\nlog the failure with whatever error reporting system you use.\n\n-}\nfocus : String -> Task Error ()\nfocus =\n    Elm.Kernel.Browser.call \"focus\"\n\n\n{-| Find a DOM node by `id` and make it lose focus. So if you wanted a node\nlike `<input type=\"text\" id=\"search-box\">` to lose focus you could say:\n\n    import Browser.Dom as Dom\n    import Task\n\n    type Msg\n        = NoOp\n\n    unfocusSearchBox : Cmd Msg\n    unfocusSearchBox =\n        Task.attempt (\\_ -> NoOp) (Dom.blur \"search-box\")\n\nNotice that this code ignores the possibility that `search-box` is not used\nas an `id` by any node, failing silently in that case. It would be better to\nlog the failure with whatever error reporting system you use.\n\n-}\nblur : String -> Task Error ()\nblur =\n    Elm.Kernel.Browser.call \"blur\"\n\n\n\n-- ERROR\n\n\n{-| Many functions in this module look up DOM nodes up by their `id`. If you\nask for an `id` that is not in the DOM, you will get this error.\n-}\ntype Error\n    = NotFound String\n\n\n\n-- VIEWPORT\n\n\n{-| Get information on the current viewport of the browser.\n\n![getViewport](https://elm.github.io/browser/v1/getViewport.svg)\n\nIf you want to move the viewport around (i.e. change the scroll position) you\ncan use [`setViewport`](#setViewport) which change the `x` and `y` of the\nviewport.\n\n-}\ngetViewport : Task x Viewport\ngetViewport =\n    Elm.Kernel.Browser.withWindow Elm.Kernel.Browser.getViewport\n\n\n{-| All the information about the current viewport.\n\n![getViewport](https://elm.github.io/browser/v1/getViewport.svg)\n\n-}\ntype alias Viewport =\n    { scene :\n        { width : Float\n        , height : Float\n        }\n    , viewport :\n        { x : Float\n        , y : Float\n        , width : Float\n        , height : Float\n        }\n    }\n\n\n{-| Just like `getViewport`, but for any scrollable DOM node. Say we have an\napplication with a chat box in the bottow right corner like this:\n\n![chat](https://elm.github.io/browser/v1/chat.svg)\n\nThere are probably a whole bunch of messages that are not being shown. You\ncould scroll up to see them all. Well, we can think of that chat box is a\nviewport into a scene!\n\n![getViewportOf](https://elm.github.io/browser/v1/getViewportOf.svg)\n\nThis can be useful with [`setViewportOf`](#setViewportOf) to make sure new\nmessages always appear on the bottom.\n\nThe viewport size _does not_ include the border or margins.\n\n**Note:** This data is collected from specific fields in JavaScript, so it\nmay be helpful to know that:\n\n  - `scene.width` = [`scrollWidth`][sw]\n  - `scene.height` = [`scrollHeight`][sh]\n  - `viewport.x` = [`scrollLeft`][sl]\n  - `viewport.y` = [`scrollTop`][st]\n  - `viewport.width` = [`clientWidth`][cw]\n  - `viewport.height` = [`clientHeight`][ch]\n\nNeither [`offsetWidth`][ow] nor [`offsetHeight`][oh] are available. The theory\nis that (1) the information can always be obtained by using `getElement` on a\nnode without margins, (2) no cases came to mind where you actually care in the\nfirst place, and (3) it is available through ports if it is really needed.\nIf you have a case that really needs it though, please share your specific\nscenario in an issue! Nicely presented case studies are the raw ingredients for\nAPI improvements!\n\n[sw]: https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollWidth\n[sh]: https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollHeight\n[st]: https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollTop\n[sl]: https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollLeft\n[cw]: https://developer.mozilla.org/en-US/docs/Web/API/Element/clientWidth\n[ch]: https://developer.mozilla.org/en-US/docs/Web/API/Element/clientHeight\n[ow]: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetWidth\n[oh]: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetHeight\n\n-}\ngetViewportOf : String -> Task Error Viewport\ngetViewportOf =\n    Elm.Kernel.Browser.getViewportOf\n\n\n\n-- SET VIEWPORT\n\n\n{-| Change the `x` and `y` offset of the browser viewport immediately. For\nexample, you could make a command to jump to the top of the page:\n\n    import Browser.Dom as Dom\n    import Task\n\n    type Msg\n        = NoOp\n\n    resetViewport : Cmd Msg\n    resetViewport =\n        Task.perform (\\_ -> NoOp) (Dom.setViewport 0 0)\n\nThis sets the viewport offset to zero.\n\nThis could be useful with `Browser.application` where you may want to reset\nthe viewport when the URL changes. Maybe you go to a &ldquo;new page&rdquo;\nand want people to start at the top!\n\n-}\nsetViewport : Float -> Float -> Task x ()\nsetViewport =\n    Elm.Kernel.Browser.setViewport\n\n\n{-| Change the `x` and `y` offset of a DOM node&rsquo;s viewport by ID. This\nis common in text messaging and chat rooms, where once the messages fill the\nscreen, you want to always be at the very bottom of the message chain. This\nway the latest message is always on screen! You could do this:\n\n    import Browser.Dom as Dom\n    import Task\n\n    type Msg\n        = NoOp\n\n    jumpToBottom : String -> Cmd Msg\n    jumpToBottom id =\n        Dom.getViewportOf id\n            |> Task.andThen (\\info -> Dom.setViewportOf id 0 info.scene.height)\n            |> Task.attempt (\\_ -> NoOp)\n\nSo you could call `jumpToBottom \"chat-box\"` whenever you add a new message.\n\n**Note 1:** What happens if the viewport is placed out of bounds? Where there\nis no `scene` to show? To avoid this question, the `x` and `y` offsets are\nclamped such that the viewport is always fully within the `scene`. So when\n`jumpToBottom` sets the `y` offset of the viewport to the `height` of the\n`scene` (i.e. too far!) it relies on this clamping behavior to put the viewport\nback in bounds.\n\n**Note 2:** The example ignores when the element ID is not found, but it would\nbe great to log that information. It means there may be a bug or a dead link\nsomewhere!\n\n-}\nsetViewportOf : String -> Float -> Float -> Task Error ()\nsetViewportOf =\n    Elm.Kernel.Browser.setViewportOf\n\n\n\n{--SLIDE VIEWPORT\n\n\n{-| Change the `x` and `y` offset of the viewport with an animation. In JS,\nthis corresponds to setting [`scroll-behavior`][sb] to `smooth`.\n\nThis can definitely be overused, so try to use it specifically when you want\nthe user to be spatially situated in a scene. For example, a &ldquo;back to\ntop&rdquo; button might use it:\n\n    import Browser.Dom as Dom\n    import Task\n\n    type Msg = NoOp\n\n    backToTop : Cmd Msg\n    backToTop =\n      Task.perform (\\_ -> NoOp) (Dom.slideViewport 0 0)\n\nBe careful when paring this with `Browser.application`. When the URL changes\nand a whole new scene is going to be rendered, using `setViewport` is probably\nbest. If you are moving within a scene, you may benefit from a mix of\n`setViewport` and `slideViewport`. Sliding to the top is nice, but sliding\naround everywhere is probably annoying.\n\n[sb]: https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior\n-}\nslideViewport : Float -> Float -> Task x ()\nslideViewport =\n  Debug.todo \"slideViewport\"\n\n\nslideViewportOf : String -> Float -> Float -> Task Error ()\nslideViewportOf =\n  Debug.todo \"slideViewportOf\"\n\n--}\n-- ELEMENT\n\n\n{-| Get position information about specific elements. Say we put\n`id \"jesting-aside\"` on the seventh paragraph of the text. When we call\n`getElement \"jesting-aside\"` we would get the following information:\n\n![getElement](https://elm.github.io/browser/v1/getElement.svg)\n\nThis can be useful for:\n\n  - **Scrolling** &mdash; Pair this information with `setViewport` to scroll\n    specific elements into view. This gives you a lot of control over where exactly\n    the element would be after the viewport moved.\n\n  - **Drag and Drop** &mdash; As of this writing, `touchmove` events do not tell\n    you which element you are currently above. To figure out if you have dragged\n    something over the target, you could see if the `pageX` and `pageY` of the\n    touch are inside the `x`, `y`, `width`, and `height` of the target element.\n\n**Note:** This corresponds to JavaScript&rsquo;s [`getBoundingClientRect`][gbcr],\nso **the element&rsquo;s margins are included in its `width` and `height`**.\nWith scrolling, maybe you want to include the margins. With drag-and-drop, you\nprobably do not, so some folks set the margins to zero and put the target\nelement in a `<div>` that adds the spacing. Just something to be aware of!\n\n[gbcr]: https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect\n\n-}\ngetElement : String -> Task Error Element\ngetElement =\n    Elm.Kernel.Browser.getElement\n\n\n{-| A bunch of information about the position and size of an element relative\nto the overall scene.\n\n![getElement](https://elm.github.io/browser/v1/getElement.svg)\n\n-}\ntype alias Element =\n    { scene :\n        { width : Float\n        , height : Float\n        }\n    , viewport :\n        { x : Float\n        , y : Float\n        , width : Float\n        , height : Float\n        }\n    , element :\n        { x : Float\n        , y : Float\n        , width : Float\n        , height : Float\n        }\n    }\n" })
            )
            ,( "Events.elm"
            , BlobNode ({ utf8 = "effect module Browser.Events where { subscription = MySub } exposing\n  ( onAnimationFrame, onAnimationFrameDelta\n  , onKeyPress, onKeyDown, onKeyUp\n  , onClick, onMouseMove, onMouseDown, onMouseUp\n  , onResize, onVisibilityChange, Visibility(..)\n  )\n\n{-| In JavaScript, information about the root of an HTML document is held in\nthe `document` and `window` objects. This module lets you create event\nlisteners on those objects for the following topics: [animation](#animation),\n[keyboard](#keyboard), [mouse](#mouse), and [window](#window).\n\nIf there is something else you need, use [ports] to do it in JavaScript!\n\n[ports]: https://guide.elm-lang.org/interop/ports.html\n\n\n# Animation\n\n@docs onAnimationFrame, onAnimationFrameDelta\n\n\n# Keyboard\n\n@docs onKeyPress, onKeyDown, onKeyUp\n\n\n# Mouse\n\n@docs onClick, onMouseMove, onMouseDown, onMouseUp\n\n\n# Window\n\n@docs onResize, onVisibilityChange, Visibility\n\n-}\n\nimport Browser.AnimationManager as AM\nimport Dict\nimport Elm.Kernel.Browser\nimport Json.Decode as Decode\nimport Process\nimport Task exposing (Task)\nimport Time\n\n\n\n-- ANIMATION\n\n\n{-| An animation frame triggers about 60 times per second. Get the POSIX time\non each frame. (See [`elm/time`](/packages/elm/time/latest) for more info on\nPOSIX times.)\n\n**Note:** Browsers have their own render loop, repainting things as fast as\npossible. If you want smooth animations in your application, it is helpful to\nsync up with the browsers natural refresh rate. This hooks into JavaScript's\n`requestAnimationFrame` function.\n\n-}\nonAnimationFrame : (Time.Posix -> msg) -> Sub msg\nonAnimationFrame =\n  AM.onAnimationFrame\n\n\n{-| Just like `onAnimationFrame`, except message is the time in milliseconds\nsince the previous frame. So you should get a sequence of values all around\n`1000 / 60` which is nice for stepping animations by a time delta.\n-}\nonAnimationFrameDelta : (Float -> msg) -> Sub msg\nonAnimationFrameDelta =\n  AM.onAnimationFrameDelta\n\n\n\n-- KEYBOARD\n\n\n{-| Subscribe to key presses that normally produce characters. So you should\nnot rely on this for arrow keys.\n\n**Note:** Check out [this advice][note] to learn more about decoding key codes.\nIt is more complicated than it should be.\n\n[note]: https://github.com/elm/browser/blob/1.0.2/notes/keyboard.md\n\n-}\nonKeyPress : Decode.Decoder msg -> Sub msg\nonKeyPress =\n  on Document \"keypress\"\n\n\n{-| Subscribe to get codes whenever a key goes down. This can be useful for\ncreating games. Maybe you want to know if people are pressing `w`, `a`, `s`,\nor `d` at any given time.\n\n**Note:** Check out [this advice][note] to learn more about decoding key codes.\nIt is more complicated than it should be.\n\n[note]: https://github.com/elm/browser/blob/1.0.2/notes/keyboard.md\n\n-}\nonKeyDown : Decode.Decoder msg -> Sub msg\nonKeyDown =\n  on Document \"keydown\"\n\n\n{-| Subscribe to get codes whenever a key goes up. Often used in combination\nwith [`onVisibilityChange`](#onVisibilityChange) to be sure keys do not appear\nto down and never come back up.\n-}\nonKeyUp : Decode.Decoder msg -> Sub msg\nonKeyUp =\n  on Document \"keyup\"\n\n\n\n-- MOUSE\n\n\n{-| Subscribe to mouse clicks anywhere on screen. Maybe you need to create a\ncustom drop down. You could listen for clicks when it is open, letting you know\nif someone clicked out of it:\n\n    import Browser.Events as Events\n    import Json.Decode as D\n\n    type Msg\n       = ClickOut\n\n    subscriptions : Model -> Sub Msg\n    subscriptions model =\n      case model.dropDown of\n        Closed _ ->\n          Sub.none\n\n        Open _ ->\n          Events.onClick (D.succeed ClickOut)\n\n-}\nonClick : Decode.Decoder msg -> Sub msg\nonClick =\n  on Document \"click\"\n\n\n{-| Subscribe to mouse moves anywhere on screen.\n\nYou could use this to implement resizable panels like in Elm's online code\neditor. Check out the example imprementation [here][drag].\n\n[drag]: https://github.com/elm/browser/blob/1.0.2/examples/src/Drag.elm\n\n**Note:** Unsubscribe if you do not need these events! Running code on every\nsingle mouse movement can be very costly, and it is recommended to only\nsubscribe when absolutely necessary.\n\n-}\nonMouseMove : Decode.Decoder msg -> Sub msg\nonMouseMove =\n  on Document \"mousemove\"\n\n\n{-| Subscribe to get mouse information whenever the mouse button goes down.\n-}\nonMouseDown : Decode.Decoder msg -> Sub msg\nonMouseDown =\n  on Document \"mousedown\"\n\n\n{-| Subscribe to get mouse information whenever the mouse button goes up.\nOften used in combination with [`onVisibilityChange`](#onVisibilityChange)\nto be sure keys do not appear to down and never come back up.\n-}\nonMouseUp : Decode.Decoder msg -> Sub msg\nonMouseUp =\n  on Document \"mouseup\"\n\n\n\n-- WINDOW\n\n\n{-| Subscribe to any changes in window size.\n\nFor example, you could track the current width by saying:\n\n    import Browser.Events as E\n\n    type Msg\n      = GotNewWidth Int\n\n    subscriptions : model -> Cmd Msg\n    subscriptions _ =\n      E.onResize (\\w h -> GotNewWidth w)\n\n**Note:** This is equivalent to getting events from [`window.onresize`][resize].\n\n[resize]: https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onresize\n\n-}\nonResize : (Int -> Int -> msg) -> Sub msg\nonResize func =\n  on Window \"resize\" <|\n    Decode.field \"target\" <|\n      Decode.map2 func\n        (Decode.field \"innerWidth\" Decode.int)\n        (Decode.field \"innerHeight\" Decode.int)\n\n\n{-| Subscribe to any visibility changes, like if the user switches to a\ndifferent tab or window. When the user looks away, you may want to:\n\n- Pause a timer.\n- Pause an animation.\n- Pause video or audio.\n- Pause an image carousel.\n- Stop polling a server for new information.\n- Stop waiting for an [`onKeyUp`](#onKeyUp) event.\n\n-}\nonVisibilityChange : (Visibility -> msg) -> Sub msg\nonVisibilityChange func =\n  let\n    info = Elm.Kernel.Browser.visibilityInfo ()\n  in\n  on Document info.change <|\n    Decode.map (withHidden func) <|\n      Decode.field \"target\" <|\n        Decode.field info.hidden Decode.bool\n\n\nwithHidden : (Visibility -> msg) -> Bool -> msg\nwithHidden func isHidden =\n  func (if isHidden then Hidden else Visible)\n\n\n{-| Value describing whether the page is hidden or visible.\n-}\ntype Visibility\n  = Visible\n  | Hidden\n\n\n\n-- SUBSCRIPTIONS\n\n\ntype Node\n  = Document\n  | Window\n\n\non : Node -> String -> Decode.Decoder msg -> Sub msg\non node name decoder =\n  subscription (MySub node name decoder)\n\n\ntype MySub msg\n  = MySub Node String (Decode.Decoder msg)\n\n\nsubMap : (a -> b) -> MySub a -> MySub b\nsubMap func (MySub node name decoder) =\n  MySub node name (Decode.map func decoder)\n\n\n\n-- EFFECT MANAGER\n\n\ntype alias State msg =\n  { subs : List ( String, MySub msg )\n  , pids : Dict.Dict String Process.Id\n  }\n\n\ninit : Task Never (State msg)\ninit =\n  Task.succeed (State [] Dict.empty)\n\n\ntype alias Event =\n  { key : String\n  , event : Decode.Value\n  }\n\n\nonSelfMsg : Platform.Router msg Event -> Event -> State msg -> Task Never (State msg)\nonSelfMsg router { key, event } state =\n  let\n    toMessage ( subKey, MySub node name decoder ) =\n      if subKey == key then\n        Elm.Kernel.Browser.decodeEvent decoder event\n      else\n        Nothing\n\n    messages = List.filterMap toMessage state.subs\n  in\n  Task.sequence (List.map (Platform.sendToApp router) messages)\n    |> Task.andThen (\\_ -> Task.succeed state)\n\n\nonEffects : Platform.Router msg Event -> List (MySub msg) -> State msg -> Task Never (State msg)\nonEffects router subs state =\n  let\n    newSubs = List.map addKey subs\n\n    stepLeft _ pid (deads, lives, news) =\n      (pid :: deads, lives, news)\n\n    stepBoth key pid _ (deads, lives, news) =\n      (deads, Dict.insert key pid lives, news)\n\n    stepRight key sub (deads, lives, news) =\n      (deads, lives, spawn router key sub :: news)\n\n    (deadPids, livePids, makeNewPids) =\n      Dict.merge stepLeft stepBoth stepRight state.pids (Dict.fromList newSubs) ([], Dict.empty, [])\n  in\n  Task.sequence (List.map Process.kill deadPids)\n    |> Task.andThen (\\_ -> Task.sequence makeNewPids)\n    |> Task.andThen (\\pids -> Task.succeed (State newSubs (Dict.union livePids (Dict.fromList pids))))\n\n\n\n-- TO KEY\n\n\naddKey : MySub msg -> ( String, MySub msg )\naddKey ((MySub node name _) as sub) =\n  (nodeToKey node ++ name, sub)\n\n\nnodeToKey : Node -> String\nnodeToKey node =\n  case node of\n    Document -> \"d_\"\n    Window   -> \"w_\"\n\n\n\n-- SPAWN\n\n\nspawn : Platform.Router msg Event -> String -> MySub msg -> Task Never ( String, Process.Id )\nspawn router key (MySub node name _) =\n  let\n    actualNode =\n      case node of\n        Document -> Elm.Kernel.Browser.doc\n        Window -> Elm.Kernel.Browser.window\n  in\n  Task.map (\\value -> ( key, value )) <|\n    Elm.Kernel.Browser.on actualNode name <|\n      \\event -> Platform.sendToSelf router (Event key event)\n" })
            )
            ,( "Navigation.elm"
            , BlobNode ({ utf8 = "module Browser.Navigation exposing\n    ( Key, pushUrl, replaceUrl, back, forward\n    , load, reload, reloadAndSkipCache\n    )\n\n{-| This module helps you manage the browsers URL yourself. This is the\ncrucial trick when using [`Browser.application`](Browser#application).\n\nThe most important function is [`pushUrl`](#pushUrl) which changes the\naddress bar _without_ starting a page load.\n\n\n## What is a page load?\n\n1.  Request a new HTML document. The page goes blank.\n2.  As the HTML loads, request any `<script>` or `<link>` resources.\n3.  A `<script>` may mutate the document, so these tags block rendering.\n4.  When _all_ of the assets are loaded, actually render the page.\n\nThat means the page will go blank for at least two round-trips to the servers!\nYou may have 90% of the data you need and be blocked on a font that is taking\na long time. Still blank!\n\n\n## How does `pushUrl` help?\n\nThe `pushUrl` function changes the URL, but lets you keep the current HTML.\nThis means the page _never_ goes blank. Instead of making two round-trips to\nthe server, you load whatever assets you want from within Elm. Maybe you do\nnot need any round-trips! Meanwhile, you retain full control over the UI, so\nyou can show a loading bar, show information as it loads, etc. Whatever you\nwant!\n\n\n# Navigate within Page\n\n@docs Key, pushUrl, replaceUrl, back, forward\n\n\n# Navigate to other Pages\n\n@docs load, reload, reloadAndSkipCache\n\n-}\n\nimport Elm.Kernel.Browser\nimport Task exposing (Task)\n\n\n\n-- WITHIN PAGE\n\n\n{-| A navigation `Key` is needed to create navigation commands that change the\nURL. That includes [`pushUrl`](#pushUrl), [`replaceUrl`](#replaceUrl),\n[`back`](#back), and [`forward`](#forward).\n\nYou only get access to a `Key` when you create your program with\n[`Browser.application`](Browser#application), guaranteeing that your program is\nequipped to detect these URL changes. If `Key` values were available in other\nkinds of programs, unsuspecting programmers would be sure to run into some\n[annoying bugs][bugs] and learn a bunch of techniques the hard way!\n\n[bugs]: https://github.com/elm/browser/blob/1.0.2/notes/navigation-in-elements.md\n\n-}\ntype Key\n    = Key\n\n\n{-| Change the URL, but do not trigger a page load.\n\nThis will add a new entry to the browser history.\n\nCheck out the [`elm/url`][url] package for help building URLs. The\n[`Url.Builder.absolute`][abs] and [`Url.Builder.relative`][rel] functions can\nbe particularly handy!\n\n[url]: /packages/elm/url/latest\n[abs]: /packages/elm/url/latest/Url-Builder#absolute\n[rel]: /packages/elm/url/latest/Url-Builder#relative\n\n**Note:** If the user has gone `back` a few pages, there will be &ldquo;future\npages&rdquo; that the user can go `forward` to. Adding a new URL in that\nscenario will clear out any future pages. It is like going back in time and\nmaking a different choice.\n\n-}\npushUrl : Key -> String -> Cmd msg\npushUrl =\n    Elm.Kernel.Browser.pushUrl\n\n\n{-| Change the URL, but do not trigger a page load.\n\nThis _will not_ add a new entry to the browser history.\n\nThis can be useful if you have search box and you want the `?search=hats` in\nthe URL to match without adding a history entry for every single key stroke.\nImagine how annoying it would be to click `back` thirty times and still be on\nthe same page!\n\n**Note:** Browsers may rate-limit this function by throwing an exception. The\ndiscussion [here](https://bugs.webkit.org/show_bug.cgi?id=156115) suggests\nthat the limit is 100 calls per 30 second interval in Safari in 2016. It also\nsuggests techniques for people changing the URL based on scroll position.\n\n-}\nreplaceUrl : Key -> String -> Cmd msg\nreplaceUrl =\n    Elm.Kernel.Browser.replaceUrl\n\n\n{-| Go back some number of pages. So `back 1` goes back one page, and `back 2`\ngoes back two pages.\n\n**Note:** You only manage the browser history that _you_ created. Think of this\nlibrary as letting you have access to a small part of the overall history. So\nif you go back farther than the history you own, you will just go back to some\nother website!\n\n-}\nback : Key -> Int -> Cmd msg\nback key n =\n    Elm.Kernel.Browser.go key -n\n\n\n{-| Go forward some number of pages. So `forward 1` goes forward one page, and\n`forward 2` goes forward two pages. If there are no more pages in the future,\nthis will do nothing.\n\n**Note:** You only manage the browser history that _you_ created. Think of this\nlibrary as letting you have access to a small part of the overall history. So\nif you go forward farther than the history you own, the user will end up on\nwhatever website they visited next!\n\n-}\nforward : Key -> Int -> Cmd msg\nforward =\n    Elm.Kernel.Browser.go\n\n\n\n-- EXTERNAL PAGES\n\n\n{-| Leave the current page and load the given URL. **This always results in a\npage load**, even if the provided URL is the same as the current one.\n\n    gotoElmWebsite : Cmd msg\n    gotoElmWebsite =\n        load \"https://elm-lang.org\"\n\nCheck out the [`elm/url`][url] package for help building URLs. The\n[`Url.absolute`][abs] and [`Url.relative`][rel] functions can be particularly\nhandy!\n\n[url]: /packages/elm/url/latest\n[abs]: /packages/elm/url/latest/Url#absolute\n[rel]: /packages/elm/url/latest/Url#relative\n\n-}\nload : String -> Cmd msg\nload =\n    Elm.Kernel.Browser.load\n\n\n{-| Reload the current page. **This always results in a page load!**\nThis may grab resources from the browser cache, so use\n[`reloadAndSkipCache`](#reloadAndSkipCache)\nif you want to be sure that you are not loading any cached resources.\n-}\nreload : Cmd msg\nreload =\n    Elm.Kernel.Browser.reload False\n\n\n{-| Reload the current page without using the browser cache. **This always\nresults in a page load!** It is more common to want [`reload`](#reload).\n-}\nreloadAndSkipCache : Cmd msg\nreloadAndSkipCache =\n    Elm.Kernel.Browser.reload True\n" })
            )]
        )
        ,( "Browser.elm"
        , BlobNode ({ utf8 = "module Browser exposing\n    ( sandbox\n    , element\n    , document, Document\n    , application, UrlRequest(..)\n    )\n\n{-| This module helps you set up an Elm `Program` with functions like\n[`sandbox`](#sandbox) and [`document`](#document).\n\n\n# Sandboxes\n\n@docs sandbox\n\n\n# Elements\n\n@docs element\n\n\n# Documents\n\n@docs document, Document\n\n\n# Applications\n\n@docs application, UrlRequest\n\n-}\n\nimport Browser.Navigation as Navigation\nimport Debugger.Main\nimport Dict\nimport Elm.Kernel.Browser\nimport Html exposing (Html)\nimport Url\n\n\n\n-- SANDBOX\n\n\n{-| Create a sandboxed program that cannot communicate with the outside\nworld.\n\nThis is great for learning the basics of [The Elm Architecture][tea]. You can\nsee sandboxes in action in the following examples:\n\n  - [Buttons](https://guide.elm-lang.org/architecture/buttons.html)\n  - [Text Fields](https://guide.elm-lang.org/architecture/text_fields.html)\n  - [Forms](https://guide.elm-lang.org/architecture/forms.html)\n\nThose are nice, but **I very highly recommend reading [this guide][guide]\nstraight through** to really learn how Elm works. Understanding the\nfundamentals actually pays off in this language!\n\n[tea]: https://guide.elm-lang.org/architecture/\n[guide]: https://guide.elm-lang.org/\n\n-}\nsandbox :\n    { init : model\n    , view : model -> Html msg\n    , update : msg -> model -> model\n    }\n    -> Program () model msg\nsandbox impl =\n    Elm.Kernel.Browser.element\n        { init = \\() -> ( impl.init, Cmd.none )\n        , view = impl.view\n        , update = \\msg model -> ( impl.update msg model, Cmd.none )\n        , subscriptions = \\_ -> Sub.none\n        }\n\n\n\n-- ELEMENT\n\n\n{-| Create an HTML element managed by Elm. The resulting elements are easy to\nembed in larger JavaScript projects, and lots of companies that use Elm\nstarted with this approach! Try it out on something small. If it works, great,\ndo more! If not, revert, no big deal.\n\nUnlike a [`sandbox`](#sandbox), an `element` can talk to the outside world in\na couple ways:\n\n  - `Cmd` &mdash; you can command the Elm runtime to do stuff, like HTTP.\n  - `Sub` &mdash; you can subscribe to event sources, like clock ticks.\n  - `flags` &mdash; JavaScript can pass in data when starting the Elm program\n  - `ports` &mdash; set up a client-server relationship with JavaScript\n\nAs you read [the guide][guide] you will run into a bunch of examples of `element`\nin [this section][fx]. You can learn more about flags and ports in [the interop\nsection][interop].\n\n[guide]: https://guide.elm-lang.org/\n[fx]: https://guide.elm-lang.org/effects/\n[interop]: https://guide.elm-lang.org/interop/\n\n-}\nelement :\n    { init : flags -> ( model, Cmd msg )\n    , view : model -> Html msg\n    , update : msg -> model -> ( model, Cmd msg )\n    , subscriptions : model -> Sub msg\n    }\n    -> Program flags model msg\nelement =\n    Elm.Kernel.Browser.element\n\n\n\n-- DOCUMENT\n\n\n{-| Create an HTML document managed by Elm. This expands upon what `element`\ncan do in that `view` now gives you control over the `<title>` and `<body>`.\n-}\ndocument :\n    { init : flags -> ( model, Cmd msg )\n    , view : model -> Document msg\n    , update : msg -> model -> ( model, Cmd msg )\n    , subscriptions : model -> Sub msg\n    }\n    -> Program flags model msg\ndocument =\n    Elm.Kernel.Browser.document\n\n\n{-| This data specifies the `<title>` and all of the nodes that should go in\nthe `<body>`. This means you can update the title as your application changes.\nMaybe your \"single-page app\" navigates to a \"different page\", maybe a calendar\napp shows an accurate date in the title, etc.\n\n> **Note about CSS:** This looks similar to an `<html>` document, but this is\n> not the place to manage CSS assets. If you want to work with CSS, there are\n> a couple ways:\n>\n> 1.  Packages like [`rtfeldman/elm-css`][elm-css] give all of the features\n>     of CSS without any CSS files. You can add all the styles you need in your\n>     `view` function, and there is no need to worry about class names matching.\n>\n> 2.  Compile your Elm code to JavaScript with `elm make --output=elm.js` and\n>     then make your own HTML file that loads `elm.js` and the CSS file you want.\n>     With this approach, it does not matter where the CSS comes from. Write it\n>     by hand. Generate it. Whatever you want to do.\n>\n> 3.  If you need to change `<link>` tags dynamically, you can send messages\n>     out a port to do it in JavaScript.\n>\n> The bigger point here is that loading assets involves touching the `<head>`\n> as an implementation detail of browsers, but that does not mean it should be\n> the responsibility of the `view` function in Elm. So we do it differently!\n\n[elm-css]: /packages/rtfeldman/elm-css/latest/\n\n-}\ntype alias Document msg =\n    { title : String\n    , body : List (Html msg)\n    }\n\n\n\n-- APPLICATION\n\n\n{-| Create an application that manages [`Url`][url] changes.\n\n**When the application starts**, `init` gets the initial `Url`. You can show\ndifferent things depending on the `Url`!\n\n**When someone clicks a link**, like `<a href=\"/home\">Home</a>`, it always goes\nthrough `onUrlRequest`. The resulting message goes to your `update` function,\ngiving you a chance to save scroll position or persist data before changing\nthe URL yourself with [`pushUrl`][bnp] or [`load`][bnl]. More info on this in\nthe [`UrlRequest`](#UrlRequest) docs!\n\n**When the URL changes**, the new `Url` goes through `onUrlChange`. The\nresulting message goes to `update` where you can decide what to show next.\n\nApplications always use the [`Browser.Navigation`][bn] module for precise\ncontrol over `Url` changes.\n\n**More Info:** Here are some example usages of `application` programs:\n\n  - [RealWorld example app](https://github.com/rtfeldman/elm-spa-example)\n  - [Elms package website](https://github.com/elm/package.elm-lang.org)\n\nThese are quite advanced Elm programs, so be sure to go through [the guide][g]\nfirst to get a solid conceptual foundation before diving in! If you start\nreading a calculus book from page 314, it might seem confusing. Same here!\n\n**Note:** Can an [`element`](#element) manage the URL too? Read [this]!\n\n[g]: https://guide.elm-lang.org/\n[bn]: Browser-Navigation\n[bnp]: Browser-Navigation#pushUrl\n[bnl]: Browser-Navigation#load\n[url]: /packages/elm/url/latest/Url#Url\n[this]: https://github.com/elm/browser/blob/1.0.2/notes/navigation-in-elements.md\n\n-}\napplication :\n    { init : flags -> Url.Url -> Navigation.Key -> ( model, Cmd msg )\n    , view : model -> Document msg\n    , update : msg -> model -> ( model, Cmd msg )\n    , subscriptions : model -> Sub msg\n    , onUrlRequest : UrlRequest -> msg\n    , onUrlChange : Url.Url -> msg\n    }\n    -> Program flags model msg\napplication =\n    Elm.Kernel.Browser.application\n\n\n{-| All links in an [`application`](#application) create a `UrlRequest`. So\nwhen you click `<a href=\"/home\">Home</a>`, it does not just navigate! It\nnotifies `onUrlRequest` that the user wants to change the `Url`.\n\n\n### `Internal` vs `External`\n\nImagine we are browsing `https://example.com`. An `Internal` link would be\nlike:\n\n  - `settings#privacy`\n  - `/home`\n  - `https://example.com/home`\n  - `//example.com/home`\n\nAll of these links exist under the `https://example.com` domain. An `External`\nlink would be like:\n\n  - `https://elm-lang.org/examples`\n  - `https://other.example.com/home`\n  - `http://example.com/home`\n\nAnything that changes the domain. Notice that changing the protocol from\n`https` to `http` is considered a different domain! (And vice versa!)\n\n\n### Purpose\n\nHaving a `UrlRequest` requires a case in your `update` like this:\n\n    import Browser exposing (..)\n    import Browser.Navigation as Nav\n    import Url\n\n    type Msg\n        = ClickedLink UrlRequest\n\n    update : Msg -> Model -> ( Model, Cmd msg )\n    update msg model =\n        case msg of\n            ClickedLink urlRequest ->\n                case urlRequest of\n                    Internal url ->\n                        ( model\n                        , Nav.pushUrl model.key (Url.toString url)\n                        )\n\n                    External url ->\n                        ( model\n                        , Nav.load url\n                        )\n\nThis is useful because it gives you a chance to customize the behavior in each\ncase. Maybe on some `Internal` links you save the scroll position with\n[`Browser.Dom.getViewport`](Browser-Dom#getViewport) so you can restore it\nlater. Maybe on `External` links you persist parts of the `Model` on your\nservers before leaving. Whatever you need to do!\n\n**Note:** Knowing the scroll position is not enough to restore it! What if the\nbrowser dimensions change? The scroll position will not correlate with\n&ldquo;what was on screen&rdquo; anymore. So it may be better to remember\n&ldquo;what was on screen&rdquo; and recreate the position based on that. For\nexample, in a Wikipedia article, remember the header that they were looking at\nmost recently. [`Browser.Dom.getElement`](Browser-Dom#getElement) is designed\nfor figuring that out!\n\n-}\ntype UrlRequest\n    = Internal Url.Url\n    | External String\n" })
        )]

file_tree_node_elm_kernel_modules_html_src =
    TreeNode
        [( "Html"
        , TreeNode
            [( "Attributes.elm"
            , BlobNode ({ utf8 = "module Html.Attributes exposing\n  ( style, property, attribute, map\n  , class, classList, id, title, hidden\n  , type_, value, checked, placeholder, selected\n  , accept, acceptCharset, action, autocomplete, autofocus\n  , disabled, enctype, list, maxlength, minlength, method, multiple\n  , name, novalidate, pattern, readonly, required, size, for, form\n  , max, min, step\n  , cols, rows, wrap\n  , href, target, download, hreflang, media, ping, rel\n  , ismap, usemap, shape, coords\n  , src, height, width, alt\n  , autoplay, controls, loop, preload, poster, default, kind, srclang\n  , sandbox, srcdoc\n  , reversed, start\n  , align, colspan, rowspan, headers, scope\n  , accesskey, contenteditable, contextmenu, dir, draggable, dropzone\n  , itemprop, lang, spellcheck, tabindex\n  , cite, datetime, pubdate, manifest\n  )\n\n{-| Helper functions for HTML attributes. They are organized roughly by\ncategory. Each attribute is labeled with the HTML tags it can be used with, so\njust search the page for `video` if you want video stuff.\n\n# Primitives\n@docs style, property, attribute, map\n\n# Super Common Attributes\n@docs class, classList, id, title, hidden\n\n# Inputs\n@docs type_, value, checked, placeholder, selected\n\n## Input Helpers\n@docs accept, acceptCharset, action, autocomplete, autofocus,\n    disabled, enctype, list, maxlength, minlength, method, multiple,\n    name, novalidate, pattern, readonly, required, size, for, form\n\n## Input Ranges\n@docs max, min, step\n\n## Input Text Areas\n@docs cols, rows, wrap\n\n\n# Links and Areas\n@docs href, target, download, hreflang, media, ping, rel\n\n## Maps\n@docs ismap, usemap, shape, coords\n\n\n# Embedded Content\n@docs src, height, width, alt\n\n## Audio and Video\n@docs autoplay, controls, loop, preload, poster, default, kind, srclang\n\n## iframes\n@docs sandbox, srcdoc\n\n# Ordered Lists\n@docs reversed, start\n\n# Tables\n@docs align, colspan, rowspan, headers, scope\n\n# Less Common Global Attributes\nAttributes that can be attached to any HTML tag but are less commonly used.\n@docs accesskey, contenteditable, contextmenu, dir, draggable, dropzone,\n      itemprop, lang, spellcheck, tabindex\n\n# Miscellaneous\n@docs cite, datetime, pubdate, manifest\n\n-}\n\n\nimport Elm.Kernel.VirtualDom\nimport Html exposing (Attribute)\nimport Json.Encode as Json\nimport VirtualDom\n\n\n-- This library does not include low, high, or optimum because the idea of a\n-- `meter` is just too crazy.\n\n\n\n-- PRIMITIVES\n\n\n{-| Specify a style.\n\n    greeting : Node msg\n    greeting =\n      div\n        [ style \"background-color\" \"red\"\n        , style \"height\" \"90px\"\n        , style \"width\" \"100%\"\n        ]\n        [ text \"Hello!\"\n        ]\n\nThere is no `Html.Styles` module because best practices for working with HTML\nsuggest that this should primarily be specified in CSS files. So the general\nrecommendation is to use this function lightly.\n-}\nstyle : String -> String -> Attribute msg\nstyle =\n  VirtualDom.style\n\n\n{-| This function makes it easier to build a space-separated class attribute.\nEach class can easily be added and removed depending on the boolean value it\nis paired with. For example, maybe we want a way to view notices:\n\n    viewNotice : Notice -> Html msg\n    viewNotice notice =\n      div\n        [ classList\n            [ (\"notice\", True)\n            , (\"notice-important\", notice.isImportant)\n            , (\"notice-seen\", notice.isSeen)\n            ]\n        ]\n        [ text notice.content ]\n\n**Note:** You can have as many `class` and `classList` attributes as you want.\nThey all get applied, so if you say `[ class \"notice\", class \"notice-seen\" ]`\nyou will get both classes!\n-}\nclassList : List (String, Bool) -> Attribute msg\nclassList classes =\n  class <| String.join \" \" <| List.map Tuple.first <|\n    List.filter Tuple.second classes\n\n\n\n-- CUSTOM ATTRIBUTES\n\n\n{-| Create *properties*, like saying `domNode.className = 'greeting'` in\nJavaScript.\n\n    import Json.Encode as Encode\n\n    class : String -> Attribute msg\n    class name =\n      property \"className\" (Encode.string name)\n\nRead more about the difference between properties and attributes [here][].\n\n[here]: https://github.com/elm/html/blob/master/properties-vs-attributes.md\n-}\nproperty : String -> Json.Value -> Attribute msg\nproperty =\n  VirtualDom.property\n\n\nstringProperty : String -> String -> Attribute msg\nstringProperty key string =\n  Elm.Kernel.VirtualDom.property key (Json.string string)\n\n\nboolProperty : String -> Bool -> Attribute msg\nboolProperty key bool =\n  Elm.Kernel.VirtualDom.property key (Json.bool bool)\n\n\n{-| Create *attributes*, like saying `domNode.setAttribute('class', 'greeting')`\nin JavaScript.\n\n    class : String -> Attribute msg\n    class name =\n      attribute \"class\" name\n\nRead more about the difference between properties and attributes [here][].\n\n[here]: https://github.com/elm/html/blob/master/properties-vs-attributes.md\n-}\nattribute : String -> String -> Attribute msg\nattribute =\n  VirtualDom.attribute\n\n\n{-| Transform the messages produced by an `Attribute`.\n-}\nmap : (a -> msg) -> Attribute a -> Attribute msg\nmap =\n  VirtualDom.mapAttribute\n\n\n\n-- GLOBAL ATTRIBUTES\n\n\n{-| Often used with CSS to style elements with common properties.\n\n**Note:** You can have as many `class` and `classList` attributes as you want.\nThey all get applied, so if you say `[ class \"notice\", class \"notice-seen\" ]`\nyou will get both classes!\n-}\nclass : String -> Attribute msg\nclass =\n  stringProperty \"className\"\n\n\n{-| Indicates the relevance of an element. -}\nhidden : Bool -> Attribute msg\nhidden =\n  boolProperty \"hidden\"\n\n\n{-| Often used with CSS to style a specific element. The value of this\nattribute must be unique.\n-}\nid : String -> Attribute msg\nid =\n  stringProperty \"id\"\n\n\n{-| Text to be displayed in a tooltip when hovering over the element. -}\ntitle : String -> Attribute msg\ntitle =\n  stringProperty \"title\"\n\n\n\n-- LESS COMMON GLOBAL ATTRIBUTES\n\n\n{-| Defines a keyboard shortcut to activate or add focus to the element. -}\naccesskey : Char -> Attribute msg\naccesskey char =\n  stringProperty \"accessKey\" (String.fromChar char)\n\n\n{-| Indicates whether the element's content is editable. -}\ncontenteditable : Bool -> Attribute msg\ncontenteditable =\n  boolProperty \"contentEditable\"\n\n\n{-| Defines the ID of a `menu` element which will serve as the element's\ncontext menu.\n-}\ncontextmenu : String -> Attribute msg\ncontextmenu =\n  Elm.Kernel.VirtualDom.attribute \"contextmenu\"\n\n\n{-| Defines the text direction. Allowed values are ltr (Left-To-Right) or rtl\n(Right-To-Left).\n-}\ndir : String -> Attribute msg\ndir =\n  stringProperty \"dir\"\n\n\n{-| Defines whether the element can be dragged. -}\ndraggable : String -> Attribute msg\ndraggable =\n  Elm.Kernel.VirtualDom.attribute \"draggable\"\n\n\n{-| Indicates that the element accept the dropping of content on it. -}\ndropzone : String -> Attribute msg\ndropzone =\n  stringProperty \"dropzone\"\n\n\n{-|-}\nitemprop : String -> Attribute msg\nitemprop =\n  Elm.Kernel.VirtualDom.attribute \"itemprop\"\n\n\n{-| Defines the language used in the element. -}\nlang : String -> Attribute msg\nlang =\n  stringProperty \"lang\"\n\n\n{-| Indicates whether spell checking is allowed for the element. -}\nspellcheck : Bool -> Attribute msg\nspellcheck =\n  boolProperty \"spellcheck\"\n\n\n{-| Overrides the browser's default tab order and follows the one specified\ninstead.\n-}\ntabindex : Int -> Attribute msg\ntabindex n =\n  Elm.Kernel.VirtualDom.attribute \"tabIndex\" (String.fromInt n)\n\n\n\n-- EMBEDDED CONTENT\n\n\n{-| The URL of the embeddable content. For `audio`, `embed`, `iframe`, `img`,\n`input`, `script`, `source`, `track`, and `video`.\n-}\nsrc : String -> Attribute msg\nsrc url =\n  stringProperty \"src\" (Elm.Kernel.VirtualDom.noJavaScriptOrHtmlUri url)\n\n\n{-| Declare the height of a `canvas`, `embed`, `iframe`, `img`, `input`,\n`object`, or `video`.\n-}\nheight : Int -> Attribute msg\nheight n =\n  Elm.Kernel.VirtualDom.attribute \"height\" (String.fromInt n)\n\n\n{-| Declare the width of a `canvas`, `embed`, `iframe`, `img`, `input`,\n`object`, or `video`.\n-}\nwidth : Int -> Attribute msg\nwidth n =\n  Elm.Kernel.VirtualDom.attribute \"width\" (String.fromInt n)\n\n\n{-| Alternative text in case an image can't be displayed. Works with `img`,\n`area`, and `input`.\n-}\nalt : String -> Attribute msg\nalt =\n  stringProperty \"alt\"\n\n\n\n-- AUDIO and VIDEO\n\n\n{-| The `audio` or `video` should play as soon as possible. -}\nautoplay : Bool -> Attribute msg\nautoplay =\n  boolProperty \"autoplay\"\n\n\n{-| Indicates whether the browser should show playback controls for the `audio`\nor `video`.\n-}\ncontrols : Bool -> Attribute msg\ncontrols =\n  boolProperty \"controls\"\n\n\n{-| Indicates whether the `audio` or `video` should start playing from the\nstart when it's finished.\n-}\nloop : Bool -> Attribute msg\nloop =\n  boolProperty \"loop\"\n\n\n{-| Control how much of an `audio` or `video` resource should be preloaded. -}\npreload : String -> Attribute msg\npreload =\n  stringProperty \"preload\"\n\n\n{-| A URL indicating a poster frame to show until the user plays or seeks the\n`video`.\n-}\nposter : String -> Attribute msg\nposter =\n  stringProperty \"poster\"\n\n\n{-| Indicates that the `track` should be enabled unless the user's preferences\nindicate something different.\n-}\ndefault : Bool -> Attribute msg\ndefault =\n  boolProperty \"default\"\n\n\n{-| Specifies the kind of text `track`. -}\nkind : String -> Attribute msg\nkind =\n  stringProperty \"kind\"\n\n\n{-- TODO: maybe reintroduce once there's a better way to disambiguate imports\n{-| Specifies a user-readable title of the text `track`. -}\nlabel : String -> Attribute msg\nlabel =\n  stringProperty \"label\"\n--}\n\n{-| A two letter language code indicating the language of the `track` text data.\n-}\nsrclang : String -> Attribute msg\nsrclang =\n  stringProperty \"srclang\"\n\n\n\n-- IFRAMES\n\n\n{-| A space separated list of security restrictions you'd like to lift for an\n`iframe`.\n-}\nsandbox : String -> Attribute msg\nsandbox =\n  stringProperty \"sandbox\"\n\n\n{-| An HTML document that will be displayed as the body of an `iframe`. It will\noverride the content of the `src` attribute if it has been specified.\n-}\nsrcdoc : String -> Attribute msg\nsrcdoc =\n  stringProperty \"srcdoc\"\n\n\n\n-- INPUT\n\n\n{-| Defines the type of a `button`, `checkbox`, `input`, `embed`, `menu`,\n`object`, `script`, `source`, or `style`.\n-}\ntype_ : String -> Attribute msg\ntype_ =\n  stringProperty \"type\"\n\n\n{-| Defines a default value which will be displayed in a `button`, `option`,\n`input`, `li`, `meter`, `progress`, or `param`.\n-}\nvalue : String -> Attribute msg\nvalue =\n  stringProperty \"value\"\n\n\n{-| Indicates whether an `input` of type checkbox is checked. -}\nchecked : Bool -> Attribute msg\nchecked =\n  boolProperty \"checked\"\n\n\n{-| Provides a hint to the user of what can be entered into an `input` or\n`textarea`.\n-}\nplaceholder : String -> Attribute msg\nplaceholder =\n  stringProperty \"placeholder\"\n\n\n{-| Defines which `option` will be selected on page load. -}\nselected : Bool -> Attribute msg\nselected =\n  boolProperty \"selected\"\n\n\n\n-- INPUT HELPERS\n\n\n{-| List of types the server accepts, typically a file type.\nFor `form` and `input`.\n-}\naccept : String -> Attribute msg\naccept =\n  stringProperty \"accept\"\n\n\n{-| List of supported charsets in a `form`.\n-}\nacceptCharset : String -> Attribute msg\nacceptCharset =\n  stringProperty \"acceptCharset\"\n\n\n{-| The URI of a program that processes the information submitted via a `form`.\n-}\naction : String -> Attribute msg\naction uri =\n  stringProperty \"action\" (Elm.Kernel.VirtualDom.noJavaScriptUri uri)\n\n\n{-| Indicates whether a `form` or an `input` can have their values automatically\ncompleted by the browser.\n-}\nautocomplete : Bool -> Attribute msg\nautocomplete bool =\n  stringProperty \"autocomplete\" (if bool then \"on\" else \"off\")\n\n\n{-| The element should be automatically focused after the page loaded.\nFor `button`, `input`, `select`, and `textarea`.\n-}\nautofocus : Bool -> Attribute msg\nautofocus =\n  boolProperty \"autofocus\"\n\n\n{-| Indicates whether the user can interact with a `button`, `fieldset`,\n`input`, `optgroup`, `option`, `select` or `textarea`.\n-}\ndisabled : Bool -> Attribute msg\ndisabled =\n  boolProperty \"disabled\"\n\n\n{-| How `form` data should be encoded when submitted with the POST method.\nOptions include: application/x-www-form-urlencoded, multipart/form-data, and\ntext/plain.\n-}\nenctype : String -> Attribute msg\nenctype =\n  stringProperty \"enctype\"\n\n\n{-| Associates an `input` with a `datalist` tag. The datalist gives some\npre-defined options to suggest to the user as they interact with an input.\nThe value of the list attribute must match the id of a `datalist` node.\nFor `input`.\n-}\nlist : String -> Attribute msg\nlist =\n  Elm.Kernel.VirtualDom.attribute \"list\"\n\n\n{-| Defines the minimum number of characters allowed in an `input` or\n`textarea`.\n-}\nminlength : Int -> Attribute msg\nminlength n =\n  Elm.Kernel.VirtualDom.attribute \"minLength\" (String.fromInt n)\n\n\n{-| Defines the maximum number of characters allowed in an `input` or\n`textarea`.\n-}\nmaxlength : Int -> Attribute msg\nmaxlength n =\n  Elm.Kernel.VirtualDom.attribute \"maxlength\" (String.fromInt n)\n\n\n{-| Defines which HTTP method to use when submitting a `form`. Can be GET\n(default) or POST.\n-}\nmethod : String -> Attribute msg\nmethod =\n  stringProperty \"method\"\n\n\n{-| Indicates whether multiple values can be entered in an `input` of type\nemail or file. Can also indicate that you can `select` many options.\n-}\nmultiple : Bool -> Attribute msg\nmultiple =\n  boolProperty \"multiple\"\n\n\n{-| Name of the element. For example used by the server to identify the fields\nin form submits. For `button`, `form`, `fieldset`, `iframe`, `input`,\n`object`, `output`, `select`, `textarea`, `map`, `meta`, and `param`.\n-}\nname : String -> Attribute msg\nname =\n  stringProperty \"name\"\n\n\n{-| This attribute indicates that a `form` shouldn't be validated when\nsubmitted.\n-}\nnovalidate : Bool -> Attribute msg\nnovalidate =\n  boolProperty \"noValidate\"\n\n\n{-| Defines a regular expression which an `input`'s value will be validated\nagainst.\n-}\npattern : String -> Attribute msg\npattern =\n  stringProperty \"pattern\"\n\n\n{-| Indicates whether an `input` or `textarea` can be edited. -}\nreadonly : Bool -> Attribute msg\nreadonly =\n  boolProperty \"readOnly\"\n\n\n{-| Indicates whether this element is required to fill out or not.\nFor `input`, `select`, and `textarea`.\n-}\nrequired : Bool -> Attribute msg\nrequired =\n  boolProperty \"required\"\n\n\n{-| For `input` specifies the width of an input in characters.\n\nFor `select` specifies the number of visible options in a drop-down list.\n-}\nsize : Int -> Attribute msg\nsize n =\n  Elm.Kernel.VirtualDom.attribute \"size\" (String.fromInt n)\n\n\n{-| The element ID described by this `label` or the element IDs that are used\nfor an `output`.\n-}\nfor : String -> Attribute msg\nfor =\n  stringProperty \"htmlFor\"\n\n\n{-| Indicates the element ID of the `form` that owns this particular `button`,\n`fieldset`, `input`, `label`, `meter`, `object`, `output`, `progress`,\n`select`, or `textarea`.\n-}\nform : String -> Attribute msg\nform =\n  Elm.Kernel.VirtualDom.attribute \"form\"\n\n\n\n-- RANGES\n\n\n{-| Indicates the maximum value allowed. When using an input of type number or\ndate, the max value must be a number or date. For `input`, `meter`, and `progress`.\n-}\nmax : String -> Attribute msg\nmax =\n  stringProperty \"max\"\n\n\n{-| Indicates the minimum value allowed. When using an input of type number or\ndate, the min value must be a number or date. For `input` and `meter`.\n-}\nmin : String -> Attribute msg\nmin =\n  stringProperty \"min\"\n\n\n{-| Add a step size to an `input`. Use `step \"any\"` to allow any floating-point\nnumber to be used in the input.\n-}\nstep : String -> Attribute msg\nstep n =\n  stringProperty \"step\" n\n\n\n--------------------------\n\n\n{-| Defines the number of columns in a `textarea`. -}\ncols : Int -> Attribute msg\ncols n =\n  Elm.Kernel.VirtualDom.attribute \"cols\" (String.fromInt n)\n\n\n{-| Defines the number of rows in a `textarea`. -}\nrows : Int -> Attribute msg\nrows n =\n  Elm.Kernel.VirtualDom.attribute \"rows\" (String.fromInt n)\n\n\n{-| Indicates whether the text should be wrapped in a `textarea`. Possible\nvalues are \"hard\" and \"soft\".\n-}\nwrap : String -> Attribute msg\nwrap =\n  stringProperty \"wrap\"\n\n\n\n-- MAPS\n\n\n{-| When an `img` is a descendant of an `a` tag, the `ismap` attribute\nindicates that the click location should be added to the parent `a`'s href as\na query string.\n-}\nismap : Bool -> Attribute msg\nismap =\n  boolProperty \"isMap\"\n\n\n{-| Specify the hash name reference of a `map` that should be used for an `img`\nor `object`. A hash name reference is a hash symbol followed by the element's name or id.\nE.g. `\"#planet-map\"`.\n-}\nusemap : String -> Attribute msg\nusemap =\n  stringProperty \"useMap\"\n\n\n{-| Declare the shape of the clickable area in an `a` or `area`. Valid values\ninclude: default, rect, circle, poly. This attribute can be paired with\n`coords` to create more particular shapes.\n-}\nshape : String -> Attribute msg\nshape =\n  stringProperty \"shape\"\n\n\n{-| A set of values specifying the coordinates of the hot-spot region in an\n`area`. Needs to be paired with a `shape` attribute to be meaningful.\n-}\ncoords : String -> Attribute msg\ncoords =\n  stringProperty \"coords\"\n\n\n\n-- REAL STUFF\n\n\n{-| Specifies the horizontal alignment of a `caption`, `col`, `colgroup`,\n`hr`, `iframe`, `img`, `table`, `tbody`,  `td`,  `tfoot`, `th`, `thead`, or\n`tr`.\n-}\nalign : String -> Attribute msg\nalign =\n  stringProperty \"align\"\n\n\n{-| Contains a URI which points to the source of the quote or change in a\n`blockquote`, `del`, `ins`, or `q`.\n-}\ncite : String -> Attribute msg\ncite =\n  stringProperty \"cite\"\n\n\n\n\n-- LINKS AND AREAS\n\n\n{-| The URL of a linked resource, such as `a`, `area`, `base`, or `link`. -}\nhref : String -> Attribute msg\nhref url =\n  stringProperty \"href\" (Elm.Kernel.VirtualDom.noJavaScriptUri url)\n\n\n{-| Specify where the results of clicking an `a`, `area`, `base`, or `form`\nshould appear. Possible special values include:\n\n  * _blank &mdash; a new window or tab\n  * _self &mdash; the same frame (this is default)\n  * _parent &mdash; the parent frame\n  * _top &mdash; the full body of the window\n\nYou can also give the name of any `frame` you have created.\n-}\ntarget : String -> Attribute msg\ntarget =\n  stringProperty \"target\"\n\n\n{-| Indicates that clicking an `a` and `area` will download the resource\ndirectly. The `String` argument determins the name of the downloaded file.\nSay the file you are serving is named `hats.json`.\n\n    download \"\"               -- hats.json\n    download \"my-hats.json\"   -- my-hats.json\n    download \"snakes.json\"    -- snakes.json\n\nThe empty `String` says to just name it whatever it was called on the server.\n-}\ndownload : String -> Attribute msg\ndownload fileName =\n  stringProperty \"download\" fileName\n\n\n{-| Indicates that clicking an `a` and `area` will download the resource\ndirectly, and that the downloaded resource with have the given filename.\nSo `downloadAs \"hats.json\"` means the person gets a file named `hats.json`.\n-}\ndownloadAs : String -> Attribute msg\ndownloadAs =\n  stringProperty \"download\"\n\n\n{-| Two-letter language code of the linked resource of an `a`, `area`, or `link`.\n-}\nhreflang : String -> Attribute msg\nhreflang =\n  stringProperty \"hreflang\"\n\n\n{-| Specifies a hint of the target media of a `a`, `area`, `link`, `source`,\nor `style`.\n-}\nmedia : String -> Attribute msg\nmedia =\n  Elm.Kernel.VirtualDom.attribute \"media\"\n\n\n{-| Specify a URL to send a short POST request to when the user clicks on an\n`a` or `area`. Useful for monitoring and tracking.\n-}\nping : String -> Attribute msg\nping =\n  stringProperty \"ping\"\n\n\n{-| Specifies the relationship of the target object to the link object.\nFor `a`, `area`, `link`.\n-}\nrel : String -> Attribute msg\nrel =\n  Elm.Kernel.VirtualDom.attribute \"rel\"\n\n\n\n-- CRAZY STUFF\n\n\n{-| Indicates the date and time associated with the element.\nFor `del`, `ins`, `time`.\n-}\ndatetime : String -> Attribute msg\ndatetime =\n  Elm.Kernel.VirtualDom.attribute \"datetime\"\n\n\n{-| Indicates whether this date and time is the date of the nearest `article`\nancestor element. For `time`.\n-}\npubdate : String -> Attribute msg\npubdate =\n  Elm.Kernel.VirtualDom.attribute \"pubdate\"\n\n\n\n-- ORDERED LISTS\n\n\n{-| Indicates whether an ordered list `ol` should be displayed in a descending\norder instead of a ascending.\n-}\nreversed : Bool -> Attribute msg\nreversed =\n  boolProperty \"reversed\"\n\n\n{-| Defines the first number of an ordered list if you want it to be something\nbesides 1.\n-}\nstart : Int -> Attribute msg\nstart n =\n  stringProperty \"start\" (String.fromInt n)\n\n\n\n-- TABLES\n\n\n{-| The colspan attribute defines the number of columns a cell should span.\nFor `td` and `th`.\n-}\ncolspan : Int -> Attribute msg\ncolspan n =\n  Elm.Kernel.VirtualDom.attribute \"colspan\" (String.fromInt n)\n\n\n{-| A space separated list of element IDs indicating which `th` elements are\nheaders for this cell. For `td` and `th`.\n-}\nheaders : String -> Attribute msg\nheaders =\n  stringProperty \"headers\"\n\n\n{-| Defines the number of rows a table cell should span over.\nFor `td` and `th`.\n-}\nrowspan : Int -> Attribute msg\nrowspan n =\n  Elm.Kernel.VirtualDom.attribute \"rowspan\" (String.fromInt n)\n\n\n{-| Specifies the scope of a header cell `th`. Possible values are: col, row,\ncolgroup, rowgroup.\n-}\nscope : String -> Attribute msg\nscope =\n  stringProperty \"scope\"\n\n\n{-| Specifies the URL of the cache manifest for an `html` tag. -}\nmanifest : String -> Attribute msg\nmanifest =\n  Elm.Kernel.VirtualDom.attribute \"manifest\"\n\n\n{-- TODO: maybe reintroduce once there's a better way to disambiguate imports\n{-| The number of columns a `col` or `colgroup` should span. -}\nspan : Int -> Attribute msg\nspan n =\n    stringProperty \"span\" (String.fromInt n)\n--}\n" })
            )
            ,( "Events.elm"
            , BlobNode ({ utf8 = "module Html.Events exposing\n  ( onClick, onDoubleClick\n  , onMouseDown, onMouseUp\n  , onMouseEnter, onMouseLeave\n  , onMouseOver, onMouseOut\n  , onInput, onCheck, onSubmit\n  , onBlur, onFocus\n  , on, stopPropagationOn, preventDefaultOn, custom\n  , targetValue, targetChecked, keyCode\n  )\n\n{-|\nIt is often helpful to create an [Custom Type][] so you can have many different kinds\nof events as seen in the [TodoMVC][] example.\n\n[Custom Type]: https://guide.elm-lang.org/types/custom_types.html\n[TodoMVC]: https://github.com/evancz/elm-todomvc/blob/master/Todo.elm\n\n# Mouse\n@docs onClick, onDoubleClick,\n      onMouseDown, onMouseUp,\n      onMouseEnter, onMouseLeave,\n      onMouseOver, onMouseOut\n\n# Forms\n@docs onInput, onCheck, onSubmit\n\n# Focus\n@docs onBlur, onFocus\n\n# Custom\n@docs on, stopPropagationOn, preventDefaultOn, custom\n\n## Custom Decoders\n@docs targetValue, targetChecked, keyCode\n-}\n\nimport Html exposing (Attribute)\nimport Json.Decode as Json\nimport VirtualDom\n\n\n\n-- MOUSE EVENTS\n\n\n{-|-}\nonClick : msg -> Attribute msg\nonClick msg =\n  on \"click\" (Json.succeed msg)\n\n\n{-|-}\nonDoubleClick : msg -> Attribute msg\nonDoubleClick msg =\n  on \"dblclick\" (Json.succeed msg)\n\n\n{-|-}\nonMouseDown : msg -> Attribute msg\nonMouseDown msg =\n  on \"mousedown\" (Json.succeed msg)\n\n\n{-|-}\nonMouseUp : msg -> Attribute msg\nonMouseUp msg =\n  on \"mouseup\" (Json.succeed msg)\n\n\n{-|-}\nonMouseEnter : msg -> Attribute msg\nonMouseEnter msg =\n  on \"mouseenter\" (Json.succeed msg)\n\n\n{-|-}\nonMouseLeave : msg -> Attribute msg\nonMouseLeave msg =\n  on \"mouseleave\" (Json.succeed msg)\n\n\n{-|-}\nonMouseOver : msg -> Attribute msg\nonMouseOver msg =\n  on \"mouseover\" (Json.succeed msg)\n\n\n{-|-}\nonMouseOut : msg -> Attribute msg\nonMouseOut msg =\n  on \"mouseout\" (Json.succeed msg)\n\n\n\n-- FORM EVENTS\n\n\n{-| Detect [input](https://developer.mozilla.org/en-US/docs/Web/Events/input)\nevents for things like text fields or text areas.\n\nFor more details on how `onInput` works, check out [`targetValue`](#targetValue).\n\n**Note 1:** It grabs the **string** value at `event.target.value`, so it will\nnot work if you need some other information. For example, if you want to track\ninputs on a range slider, make a custom handler with [`on`](#on).\n\n**Note 2:** It uses `stopPropagationOn` internally to always stop propagation\nof the event. This is important for complicated reasons explained [here][1] and\n[here][2].\n\n[1]: /packages/elm/virtual-dom/latest/VirtualDom#Handler\n[2]: https://github.com/elm/virtual-dom/issues/125\n-}\nonInput : (String -> msg) -> Attribute msg\nonInput tagger =\n  stopPropagationOn \"input\" (Json.map alwaysStop (Json.map tagger targetValue))\n\n\nalwaysStop : a -> (a, Bool)\nalwaysStop x =\n  (x, True)\n\n\n{-| Detect [change](https://developer.mozilla.org/en-US/docs/Web/Events/change)\nevents on checkboxes. It will grab the boolean value from `event.target.checked`\non any input event.\n\nCheck out [`targetChecked`](#targetChecked) for more details on how this works.\n-}\nonCheck : (Bool -> msg) -> Attribute msg\nonCheck tagger =\n  on \"change\" (Json.map tagger targetChecked)\n\n\n{-| Detect a [submit](https://developer.mozilla.org/en-US/docs/Web/Events/submit)\nevent with [`preventDefault`](https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\nin order to prevent the form from changing the pages location. If you need\ndifferent behavior, create a custom event handler.\n-}\nonSubmit : msg -> Attribute msg\nonSubmit msg =\n  preventDefaultOn \"submit\" (Json.map alwaysPreventDefault (Json.succeed msg))\n\n\nalwaysPreventDefault : msg -> ( msg, Bool )\nalwaysPreventDefault msg =\n  ( msg, True )\n\n\n\n-- FOCUS EVENTS\n\n\n{-|-}\nonBlur : msg -> Attribute msg\nonBlur msg =\n  on \"blur\" (Json.succeed msg)\n\n\n{-|-}\nonFocus : msg -> Attribute msg\nonFocus msg =\n  on \"focus\" (Json.succeed msg)\n\n\n\n-- CUSTOM EVENTS\n\n\n{-| Create a custom event listener. Normally this will not be necessary, but\nyou have the power! Here is how `onClick` is defined for example:\n\n    import Json.Decode as Decode\n\n    onClick : msg -> Attribute msg\n    onClick message =\n      on \"click\" (Decode.succeed message)\n\nThe first argument is the event name in the same format as with JavaScript's\n[`addEventListener`][aEL] function.\n\nThe second argument is a JSON decoder. Read more about these [here][decoder].\nWhen an event occurs, the decoder tries to turn the event object into an Elm\nvalue. If successful, the value is routed to your `update` function. In the\ncase of `onClick` we always just succeed with the given `message`.\n\nIf this is confusing, work through the [Elm Architecture Tutorial][tutorial].\nIt really helps!\n\n[aEL]: https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\n[decoder]: /packages/elm/json/latest/Json-Decode\n[tutorial]: https://github.com/evancz/elm-architecture-tutorial/\n\n**Note:** This creates a [passive][] event listener, enabling optimizations for\ntouch, scroll, and wheel events in some browsers.\n\n[passive]: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n-}\non : String -> Json.Decoder msg -> Attribute msg\non event decoder =\n  VirtualDom.on event (VirtualDom.Normal decoder)\n\n\n{-| Create an event listener that may [`stopPropagation`][stop]. Your decoder\nmust produce a message and a `Bool` that decides if `stopPropagation` should\nbe called.\n\n[stop]: https://developer.mozilla.org/en-US/docs/Web/API/Event/stopPropagation\n\n**Note:** This creates a [passive][] event listener, enabling optimizations for\ntouch, scroll, and wheel events in some browsers.\n\n[passive]: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n-}\nstopPropagationOn : String -> Json.Decoder (msg, Bool) -> Attribute msg\nstopPropagationOn event decoder =\n  VirtualDom.on event (VirtualDom.MayStopPropagation decoder)\n\n\n{-| Create an event listener that may [`preventDefault`][prevent]. Your decoder\nmust produce a message and a `Bool` that decides if `preventDefault` should\nbe called.\n\nFor example, the `onSubmit` function in this library *always* prevents the\ndefault behavior:\n\n[prevent]: https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault\n\n    onSubmit : msg -> Attribute msg\n    onSubmit msg =\n      preventDefaultOn \"submit\" (Json.map alwaysPreventDefault (Json.succeed msg))\n\n    alwaysPreventDefault : msg -> ( msg, Bool )\n    alwaysPreventDefault msg =\n      ( msg, True )\n-}\npreventDefaultOn : String -> Json.Decoder (msg, Bool) -> Attribute msg\npreventDefaultOn event decoder =\n  VirtualDom.on event (VirtualDom.MayPreventDefault decoder)\n\n\n{-| Create an event listener that may [`stopPropagation`][stop] or\n[`preventDefault`][prevent].\n\n[stop]: https://developer.mozilla.org/en-US/docs/Web/API/Event/stopPropagation\n[prevent]: https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault\n[handler]: https://package.elm-lang.org/packages/elm/virtual-dom/latest/VirtualDom#Handler\n\n**Note:** Check out the lower-level event API in `elm/virtual-dom` for more\ninformation on exactly how events work, especially the [`Handler`][handler]\ndocs.\n-}\ncustom : String -> Json.Decoder { message : msg, stopPropagation : Bool, preventDefault : Bool } -> Attribute msg\ncustom event decoder =\n  VirtualDom.on event (VirtualDom.Custom decoder)\n\n\n\n-- COMMON DECODERS\n\n\n{-| A `Json.Decoder` for grabbing `event.target.value`. We use this to define\n`onInput` as follows:\n\n    import Json.Decode as Json\n\n    onInput : (String -> msg) -> Attribute msg\n    onInput tagger =\n      stopPropagationOn \"input\" <|\n        Json.map alwaysStop (Json.map tagger targetValue)\n\n    alwaysStop : a -> (a, Bool)\n    alwaysStop x =\n      (x, True)\n\nYou probably will never need this, but hopefully it gives some insights into\nhow to make custom event handlers.\n-}\ntargetValue : Json.Decoder String\ntargetValue =\n  Json.at [\"target\", \"value\"] Json.string\n\n\n{-| A `Json.Decoder` for grabbing `event.target.checked`. We use this to define\n`onCheck` as follows:\n\n    import Json.Decode as Json\n\n    onCheck : (Bool -> msg) -> Attribute msg\n    onCheck tagger =\n      on \"input\" (Json.map tagger targetChecked)\n-}\ntargetChecked : Json.Decoder Bool\ntargetChecked =\n  Json.at [\"target\", \"checked\"] Json.bool\n\n\n{-| A `Json.Decoder` for grabbing `event.keyCode`. This helps you define\nkeyboard listeners like this:\n\n    import Json.Decode as Json\n\n    onKeyUp : (Int -> msg) -> Attribute msg\n    onKeyUp tagger =\n      on \"keyup\" (Json.map tagger keyCode)\n\n**Note:** It looks like the spec is moving away from `event.keyCode` and\ntowards `event.key`. Once this is supported in more browsers, we may add\nhelpers here for `onKeyUp`, `onKeyDown`, `onKeyPress`, etc.\n-}\nkeyCode : Json.Decoder Int\nkeyCode =\n  Json.field \"keyCode\" Json.int\n" })
            )
            ,( "Keyed.elm"
            , BlobNode ({ utf8 = "module Html.Keyed exposing\n  ( node\n  , ol\n  , ul\n  )\n{-| A keyed node helps optimize cases where children are getting added, moved,\nremoved, etc. Common examples include:\n\n  - The user can delete items from a list.\n  - The user can create new items in a list.\n  - You can sort a list based on name or date or whatever.\n\nWhen you use a keyed node, every child is paired with a string identifier. This\nmakes it possible for the underlying diffing algorithm to reuse nodes more\nefficiently.\n\n# Keyed Nodes\n@docs node\n\n# Commonly Keyed Nodes\n@docs ol, ul\n-}\n\n\nimport Html exposing (Attribute, Html)\nimport VirtualDom\n\n\n{-| Works just like `Html.node`, but you add a unique identifier to each child\nnode. You want this when you have a list of nodes that is changing: adding\nnodes, removing nodes, etc. In these cases, the unique identifiers help make\nthe DOM modifications more efficient.\n-}\nnode : String -> List (Attribute msg) -> List ( String, Html msg ) -> Html msg\nnode =\n  VirtualDom.keyedNode\n\n\n{-|-}\nol : List (Attribute msg) -> List ( String, Html msg ) -> Html msg\nol =\n  node \"ol\"\n\n\n{-|-}\nul : List (Attribute msg) -> List ( String, Html msg ) -> Html msg\nul =\n  node \"ul\"\n" })
            )
            ,( "Lazy.elm"
            , BlobNode ({ utf8 = "module Html.Lazy exposing\n  ( lazy, lazy2, lazy3, lazy4, lazy5, lazy6, lazy7, lazy8\n  )\n\n{-| Since all Elm functions are pure we have a guarantee that the same input\nwill always result in the same output. This module gives us tools to be lazy\nabout building `Html` that utilize this fact.\n\nRather than immediately applying functions to their arguments, the `lazy`\nfunctions just bundle the function and arguments up for later. When diffing\nthe old and new virtual DOM, it checks to see if all the arguments are equal\nby reference. If so, it skips calling the function!\n\nThis is a really cheap test and often makes things a lot faster, but definitely\nbenchmark to be sure!\n\n@docs lazy, lazy2, lazy3, lazy4, lazy5, lazy6, lazy7, lazy8\n\n-}\n\nimport Html exposing (Html)\nimport VirtualDom\n\n\n{-| A performance optimization that delays the building of virtual DOM nodes.\n\nCalling `(view model)` will definitely build some virtual DOM, perhaps a lot of\nit. Calling `(lazy view model)` delays the call until later. During diffing, we\ncan check to see if `model` is referentially equal to the previous value used,\nand if so, we just stop. No need to build up the tree structure and diff it,\nwe know if the input to `view` is the same, the output must be the same!\n-}\nlazy : (a -> Html msg) -> a -> Html msg\nlazy =\n  VirtualDom.lazy\n\n\n{-| Same as `lazy` but checks on two arguments.\n-}\nlazy2 : (a -> b -> Html msg) -> a -> b -> Html msg\nlazy2 =\n  VirtualDom.lazy2\n\n\n{-| Same as `lazy` but checks on three arguments.\n-}\nlazy3 : (a -> b -> c -> Html msg) -> a -> b -> c -> Html msg\nlazy3 =\n  VirtualDom.lazy3\n\n\n{-| Same as `lazy` but checks on four arguments.\n-}\nlazy4 : (a -> b -> c -> d -> Html msg) -> a -> b -> c -> d -> Html msg\nlazy4 =\n  VirtualDom.lazy4\n\n\n{-| Same as `lazy` but checks on five arguments.\n-}\nlazy5 : (a -> b -> c -> d -> e -> Html msg) -> a -> b -> c -> d -> e -> Html msg\nlazy5 =\n  VirtualDom.lazy5\n\n\n{-| Same as `lazy` but checks on six arguments.\n-}\nlazy6 : (a -> b -> c -> d -> e -> f -> Html msg) -> a -> b -> c -> d -> e -> f -> Html msg\nlazy6 =\n  VirtualDom.lazy6\n\n\n{-| Same as `lazy` but checks on seven arguments.\n-}\nlazy7 : (a -> b -> c -> d -> e -> f -> g -> Html msg) -> a -> b -> c -> d -> e -> f -> g -> Html msg\nlazy7 =\n  VirtualDom.lazy7\n\n\n{-| Same as `lazy` but checks on eight arguments.\n-}\nlazy8 : (a -> b -> c -> d -> e -> f -> g -> h -> Html msg) -> a -> b -> c -> d -> e -> f -> g -> h -> Html msg\nlazy8 =\n  VirtualDom.lazy8\n" })
            )]
        )
        ,( "Html.elm"
        , BlobNode ({ utf8 = "module Html exposing\n  ( Html, Attribute\n  , text, node, map\n  , h1, h2, h3, h4, h5, h6\n  , div, p, hr, pre, blockquote\n  , span, a, code, em, strong, i, b, u, sub, sup, br\n  , ol, ul, li, dl, dt, dd\n  , img, iframe, canvas, math\n  , form, input, textarea, button, select, option\n  , section, nav, article, aside, header, footer, address, main_\n  , figure, figcaption\n  , table, caption, colgroup, col, tbody, thead, tfoot, tr, td, th\n  , fieldset, legend, label, datalist, optgroup, output, progress, meter\n  , audio, video, source, track\n  , embed, object, param\n  , ins, del\n  , small, cite, dfn, abbr, time, var, samp, kbd, s, q\n  , mark, ruby, rt, rp, bdi, bdo, wbr\n  , details, summary, menuitem, menu\n  )\n\n{-| This file is organized roughly in order of popularity. The tags which you'd\nexpect to use frequently will be closer to the top.\n\n# Primitives\n@docs Html, Attribute, text, node, map\n\n# Tags\n\n## Headers\n@docs h1, h2, h3, h4, h5, h6\n\n## Grouping Content\n@docs div, p, hr, pre, blockquote\n\n## Text\n@docs span, a, code, em, strong, i, b, u, sub, sup, br\n\n## Lists\n@docs ol, ul, li, dl, dt, dd\n\n## Embedded Content\n@docs img, iframe, canvas, math\n\n## Inputs\n@docs form, input, textarea, button, select, option\n\n## Sections\n@docs section, nav, article, aside, header, footer, address, main_\n\n## Figures\n@docs figure, figcaption\n\n## Tables\n@docs table, caption, colgroup, col, tbody, thead, tfoot, tr, td, th\n\n\n## Less Common Elements\n\n### Less Common Inputs\n@docs fieldset, legend, label, datalist, optgroup, output, progress, meter\n\n### Audio and Video\n@docs audio, video, source, track\n\n### Embedded Objects\n@docs embed, object, param\n\n### Text Edits\n@docs ins, del\n\n### Semantic Text\n@docs small, cite, dfn, abbr, time, var, samp, kbd, s, q\n\n### Less Common Text Tags\n@docs mark, ruby, rt, rp, bdi, bdo, wbr\n\n## Interactive Elements\n@docs details, summary, menuitem, menu\n\n-}\n\n\nimport Elm.Kernel.VirtualDom\nimport VirtualDom\n\n\n\n-- CORE TYPES\n\n\n{-| The core building block used to build up HTML. Here we create an `Html`\nvalue with no attributes and one child:\n\n    hello : Html msg\n    hello =\n      div [] [ text \"Hello!\" ]\n-}\ntype alias Html msg = VirtualDom.Node msg\n\n\n{-| Set attributes on your `Html`. Learn more in the\n[`Html.Attributes`](Html-Attributes) module.\n-}\ntype alias Attribute msg = VirtualDom.Attribute msg\n\n\n\n-- PRIMITIVES\n\n\n{-| General way to create HTML nodes. It is used to define all of the helper\nfunctions in this library.\n\n    div : List (Attribute msg) -> List (Html msg) -> Html msg\n    div attributes children =\n        node \"div\" attributes children\n\nYou can use this to create custom nodes if you need to create something that\nis not covered by the helper functions in this library.\n-}\nnode : String -> List (Attribute msg) -> List (Html msg) -> Html msg\nnode =\n  VirtualDom.node\n\n\n{-| Just put plain text in the DOM. It will escape the string so that it appears\nexactly as you specify.\n\n    text \"Hello World!\"\n-}\ntext : String -> Html msg\ntext =\n  VirtualDom.text\n\n\n\n-- NESTING VIEWS\n\n\n{-| Transform the messages produced by some `Html`. In the following example,\nwe have `viewButton` that produces `()` messages, and we transform those values\ninto `Msg` values in `view`.\n\n    type Msg = Left | Right\n\n    view : model -> Html Msg\n    view model =\n      div []\n        [ map (\\_ -> Left) (viewButton \"Left\")\n        , map (\\_ -> Right) (viewButton \"Right\")\n        ]\n\n    viewButton : String -> Html ()\n    viewButton name =\n      button [ onClick () ] [ text name ]\n\nIf you are growing your project as recommended in [the official\nguide](https://guide.elm-lang.org/), this should not come in handy in most\nprojects. Usually it is easier to just pass things in as arguments.\n\n**Note:** Some folks have tried to use this to make components in their\nprojects, but they run into the fact that components are objects. Both are\nlocal mutable state with methods. Elm is not an object-oriented language, so\nyou run into all sorts of friction if you try to use it like one. I definitely\nrecommend against going down that path! Instead, make the simplest function\npossible and repeat.\n-}\nmap : (a -> msg) -> Html a -> Html msg\nmap =\n  VirtualDom.map\n\n\n\n-- SECTIONS\n\n\n{-| Defines a section in a document.\n-}\nsection : List (Attribute msg) -> List (Html msg) -> Html msg\nsection =\n  Elm.Kernel.VirtualDom.node \"section\"\n\n\n{-| Defines a section that contains only navigation links.\n-}\nnav : List (Attribute msg) -> List (Html msg) -> Html msg\nnav =\n  Elm.Kernel.VirtualDom.node \"nav\"\n\n\n{-| Defines self-contained content that could exist independently of the rest\nof the content.\n-}\narticle : List (Attribute msg) -> List (Html msg) -> Html msg\narticle =\n  Elm.Kernel.VirtualDom.node \"article\"\n\n\n{-| Defines some content loosely related to the page content. If it is removed,\nthe remaining content still makes sense.\n-}\naside : List (Attribute msg) -> List (Html msg) -> Html msg\naside =\n  Elm.Kernel.VirtualDom.node \"aside\"\n\n\n{-|-}\nh1 : List (Attribute msg) -> List (Html msg) -> Html msg\nh1 =\n  Elm.Kernel.VirtualDom.node \"h1\"\n\n\n{-|-}\nh2 : List (Attribute msg) -> List (Html msg) -> Html msg\nh2 =\n  Elm.Kernel.VirtualDom.node \"h2\"\n\n\n{-|-}\nh3 : List (Attribute msg) -> List (Html msg) -> Html msg\nh3 =\n  Elm.Kernel.VirtualDom.node \"h3\"\n\n\n{-|-}\nh4 : List (Attribute msg) -> List (Html msg) -> Html msg\nh4 =\n  Elm.Kernel.VirtualDom.node \"h4\"\n\n\n{-|-}\nh5 : List (Attribute msg) -> List (Html msg) -> Html msg\nh5 =\n  Elm.Kernel.VirtualDom.node \"h5\"\n\n\n{-|-}\nh6 : List (Attribute msg) -> List (Html msg) -> Html msg\nh6 =\n  Elm.Kernel.VirtualDom.node \"h6\"\n\n\n{-| Defines the header of a page or section. It often contains a logo, the\ntitle of the web site, and a navigational table of content.\n-}\nheader : List (Attribute msg) -> List (Html msg) -> Html msg\nheader =\n  Elm.Kernel.VirtualDom.node \"header\"\n\n\n{-| Defines the footer for a page or section. It often contains a copyright\nnotice, some links to legal information, or addresses to give feedback.\n-}\nfooter : List (Attribute msg) -> List (Html msg) -> Html msg\nfooter =\n  Elm.Kernel.VirtualDom.node \"footer\"\n\n\n{-| Defines a section containing contact information. -}\naddress : List (Attribute msg) -> List (Html msg) -> Html msg\naddress =\n  Elm.Kernel.VirtualDom.node \"address\"\n\n\n{-| Defines the main or important content in the document. There is only one\n`main` element in the document.\n-}\nmain_ : List (Attribute msg) -> List (Html msg) -> Html msg\nmain_ =\n  Elm.Kernel.VirtualDom.node \"main\"\n\n\n-- GROUPING CONTENT\n\n{-| Defines a portion that should be displayed as a paragraph. -}\np : List (Attribute msg) -> List (Html msg) -> Html msg\np =\n  Elm.Kernel.VirtualDom.node \"p\"\n\n\n{-| Represents a thematic break between paragraphs of a section or article or\nany longer content.\n-}\nhr : List (Attribute msg) -> List (Html msg) -> Html msg\nhr =\n  Elm.Kernel.VirtualDom.node \"hr\"\n\n\n{-| Indicates that its content is preformatted and that this format must be\npreserved.\n-}\npre : List (Attribute msg) -> List (Html msg) -> Html msg\npre =\n  Elm.Kernel.VirtualDom.node \"pre\"\n\n\n{-| Represents a content that is quoted from another source. -}\nblockquote : List (Attribute msg) -> List (Html msg) -> Html msg\nblockquote =\n  Elm.Kernel.VirtualDom.node \"blockquote\"\n\n\n{-| Defines an ordered list of items. -}\nol : List (Attribute msg) -> List (Html msg) -> Html msg\nol =\n  Elm.Kernel.VirtualDom.node \"ol\"\n\n\n{-| Defines an unordered list of items. -}\nul : List (Attribute msg) -> List (Html msg) -> Html msg\nul =\n  Elm.Kernel.VirtualDom.node \"ul\"\n\n\n{-| Defines a item of an enumeration list. -}\nli : List (Attribute msg) -> List (Html msg) -> Html msg\nli =\n  Elm.Kernel.VirtualDom.node \"li\"\n\n\n{-| Defines a definition list, that is, a list of terms and their associated\ndefinitions.\n-}\ndl : List (Attribute msg) -> List (Html msg) -> Html msg\ndl =\n  Elm.Kernel.VirtualDom.node \"dl\"\n\n\n{-| Represents a term defined by the next `dd`. -}\ndt : List (Attribute msg) -> List (Html msg) -> Html msg\ndt =\n  Elm.Kernel.VirtualDom.node \"dt\"\n\n\n{-| Represents the definition of the terms immediately listed before it. -}\ndd : List (Attribute msg) -> List (Html msg) -> Html msg\ndd =\n  Elm.Kernel.VirtualDom.node \"dd\"\n\n\n{-| Represents a figure illustrated as part of the document. -}\nfigure : List (Attribute msg) -> List (Html msg) -> Html msg\nfigure =\n  Elm.Kernel.VirtualDom.node \"figure\"\n\n\n{-| Represents the legend of a figure. -}\nfigcaption : List (Attribute msg) -> List (Html msg) -> Html msg\nfigcaption =\n  Elm.Kernel.VirtualDom.node \"figcaption\"\n\n\n{-| Represents a generic container with no special meaning. -}\ndiv : List (Attribute msg) -> List (Html msg) -> Html msg\ndiv =\n  Elm.Kernel.VirtualDom.node \"div\"\n\n\n-- TEXT LEVEL SEMANTIC\n\n{-| Represents a hyperlink, linking to another resource. -}\na : List (Attribute msg) -> List (Html msg) -> Html msg\na =\n  Elm.Kernel.VirtualDom.node \"a\"\n\n\n{-| Represents emphasized text, like a stress accent. -}\nem : List (Attribute msg) -> List (Html msg) -> Html msg\nem =\n  Elm.Kernel.VirtualDom.node \"em\"\n\n\n{-| Represents especially important text. -}\nstrong : List (Attribute msg) -> List (Html msg) -> Html msg\nstrong =\n  Elm.Kernel.VirtualDom.node \"strong\"\n\n\n{-| Represents a side comment, that is, text like a disclaimer or a\ncopyright, which is not essential to the comprehension of the document.\n-}\nsmall : List (Attribute msg) -> List (Html msg) -> Html msg\nsmall =\n  Elm.Kernel.VirtualDom.node \"small\"\n\n\n{-| Represents content that is no longer accurate or relevant. -}\ns : List (Attribute msg) -> List (Html msg) -> Html msg\ns =\n  Elm.Kernel.VirtualDom.node \"s\"\n\n\n{-| Represents the title of a work. -}\ncite : List (Attribute msg) -> List (Html msg) -> Html msg\ncite =\n  Elm.Kernel.VirtualDom.node \"cite\"\n\n\n{-| Represents an inline quotation. -}\nq : List (Attribute msg) -> List (Html msg) -> Html msg\nq =\n  Elm.Kernel.VirtualDom.node \"q\"\n\n\n{-| Represents a term whose definition is contained in its nearest ancestor\ncontent.\n-}\ndfn : List (Attribute msg) -> List (Html msg) -> Html msg\ndfn =\n  Elm.Kernel.VirtualDom.node \"dfn\"\n\n\n{-| Represents an abbreviation or an acronym; the expansion of the\nabbreviation can be represented in the title attribute.\n-}\nabbr : List (Attribute msg) -> List (Html msg) -> Html msg\nabbr =\n  Elm.Kernel.VirtualDom.node \"abbr\"\n\n\n{-| Represents a date and time value; the machine-readable equivalent can be\nrepresented in the datetime attribute.\n-}\ntime : List (Attribute msg) -> List (Html msg) -> Html msg\ntime =\n  Elm.Kernel.VirtualDom.node \"time\"\n\n\n{-| Represents computer code. -}\ncode : List (Attribute msg) -> List (Html msg) -> Html msg\ncode =\n  Elm.Kernel.VirtualDom.node \"code\"\n\n\n{-| Represents a variable. Specific cases where it should be used include an\nactual mathematical expression or programming context, an identifier\nrepresenting a constant, a symbol identifying a physical quantity, a function\nparameter, or a mere placeholder in prose.\n-}\nvar : List (Attribute msg) -> List (Html msg) -> Html msg\nvar =\n  Elm.Kernel.VirtualDom.node \"var\"\n\n\n{-| Represents the output of a program or a computer. -}\nsamp : List (Attribute msg) -> List (Html msg) -> Html msg\nsamp =\n  Elm.Kernel.VirtualDom.node \"samp\"\n\n\n{-| Represents user input, often from the keyboard, but not necessarily; it\nmay represent other input, like transcribed voice commands.\n-}\nkbd : List (Attribute msg) -> List (Html msg) -> Html msg\nkbd =\n  Elm.Kernel.VirtualDom.node \"kbd\"\n\n\n{-| Represent a subscript. -}\nsub : List (Attribute msg) -> List (Html msg) -> Html msg\nsub =\n  Elm.Kernel.VirtualDom.node \"sub\"\n\n\n{-| Represent a superscript. -}\nsup : List (Attribute msg) -> List (Html msg) -> Html msg\nsup =\n  Elm.Kernel.VirtualDom.node \"sup\"\n\n\n{-| Represents some text in an alternate voice or mood, or at least of\ndifferent quality, such as a taxonomic designation, a technical term, an\nidiomatic phrase, a thought, or a ship name.\n-}\ni : List (Attribute msg) -> List (Html msg) -> Html msg\ni =\n  Elm.Kernel.VirtualDom.node \"i\"\n\n\n{-| Represents a text which to which attention is drawn for utilitarian\npurposes. It doesn't convey extra importance and doesn't imply an alternate\nvoice.\n-}\nb : List (Attribute msg) -> List (Html msg) -> Html msg\nb =\n  Elm.Kernel.VirtualDom.node \"b\"\n\n\n{-| Represents a non-textual annotation for which the conventional\npresentation is underlining, such labeling the text as being misspelt or\nlabeling a proper name in Chinese text.\n-}\nu : List (Attribute msg) -> List (Html msg) -> Html msg\nu =\n  Elm.Kernel.VirtualDom.node \"u\"\n\n\n{-| Represents text highlighted for reference purposes, that is for its\nrelevance in another context.\n-}\nmark : List (Attribute msg) -> List (Html msg) -> Html msg\nmark =\n  Elm.Kernel.VirtualDom.node \"mark\"\n\n\n{-| Represents content to be marked with ruby annotations, short runs of text\npresented alongside the text. This is often used in conjunction with East Asian\nlanguage where the annotations act as a guide for pronunciation, like the\nJapanese furigana.\n-}\nruby : List (Attribute msg) -> List (Html msg) -> Html msg\nruby =\n  Elm.Kernel.VirtualDom.node \"ruby\"\n\n\n{-| Represents the text of a ruby annotation. -}\nrt : List (Attribute msg) -> List (Html msg) -> Html msg\nrt =\n  Elm.Kernel.VirtualDom.node \"rt\"\n\n\n{-| Represents parenthesis around a ruby annotation, used to display the\nannotation in an alternate way by browsers not supporting the standard display\nfor annotations.\n-}\nrp : List (Attribute msg) -> List (Html msg) -> Html msg\nrp =\n  Elm.Kernel.VirtualDom.node \"rp\"\n\n\n{-| Represents text that must be isolated from its surrounding for\nbidirectional text formatting. It allows embedding a span of text with a\ndifferent, or unknown, directionality.\n-}\nbdi : List (Attribute msg) -> List (Html msg) -> Html msg\nbdi =\n  Elm.Kernel.VirtualDom.node \"bdi\"\n\n\n{-| Represents the directionality of its children, in order to explicitly\noverride the Unicode bidirectional algorithm.\n-}\nbdo : List (Attribute msg) -> List (Html msg) -> Html msg\nbdo =\n  Elm.Kernel.VirtualDom.node \"bdo\"\n\n\n{-| Represents text with no specific meaning. This has to be used when no other\ntext-semantic element conveys an adequate meaning, which, in this case, is\noften brought by global attributes like `class`, `lang`, or `dir`.\n-}\nspan : List (Attribute msg) -> List (Html msg) -> Html msg\nspan =\n  Elm.Kernel.VirtualDom.node \"span\"\n\n\n{-| Represents a line break. -}\nbr : List (Attribute msg) -> List (Html msg) -> Html msg\nbr =\n  Elm.Kernel.VirtualDom.node \"br\"\n\n\n{-| Represents a line break opportunity, that is a suggested point for\nwrapping text in order to improve readability of text split on several lines.\n-}\nwbr : List (Attribute msg) -> List (Html msg) -> Html msg\nwbr =\n  Elm.Kernel.VirtualDom.node \"wbr\"\n\n\n-- EDITS\n\n{-| Defines an addition to the document. -}\nins : List (Attribute msg) -> List (Html msg) -> Html msg\nins =\n  Elm.Kernel.VirtualDom.node \"ins\"\n\n\n{-| Defines a removal from the document. -}\ndel : List (Attribute msg) -> List (Html msg) -> Html msg\ndel =\n  Elm.Kernel.VirtualDom.node \"del\"\n\n\n-- EMBEDDED CONTENT\n\n{-| Represents an image. -}\nimg : List (Attribute msg) -> List (Html msg) -> Html msg\nimg =\n  Elm.Kernel.VirtualDom.node \"img\"\n\n\n{-| Embedded an HTML document. -}\niframe : List (Attribute msg) -> List (Html msg) -> Html msg\niframe =\n  Elm.Kernel.VirtualDom.node \"iframe\"\n\n\n{-| Represents a integration point for an external, often non-HTML,\napplication or interactive content.\n-}\nembed : List (Attribute msg) -> List (Html msg) -> Html msg\nembed =\n  Elm.Kernel.VirtualDom.node \"embed\"\n\n\n{-| Represents an external resource, which is treated as an image, an HTML\nsub-document, or an external resource to be processed by a plug-in.\n-}\nobject : List (Attribute msg) -> List (Html msg) -> Html msg\nobject =\n  Elm.Kernel.VirtualDom.node \"object\"\n\n\n{-| Defines parameters for use by plug-ins invoked by `object` elements. -}\nparam : List (Attribute msg) -> List (Html msg) -> Html msg\nparam =\n  Elm.Kernel.VirtualDom.node \"param\"\n\n\n{-| Represents a video, the associated audio and captions, and controls. -}\nvideo : List (Attribute msg) -> List (Html msg) -> Html msg\nvideo =\n  Elm.Kernel.VirtualDom.node \"video\"\n\n\n{-| Represents a sound or audio stream. -}\naudio : List (Attribute msg) -> List (Html msg) -> Html msg\naudio =\n  Elm.Kernel.VirtualDom.node \"audio\"\n\n\n{-| Allows authors to specify alternative media resources for media elements\nlike `video` or `audio`.\n-}\nsource : List (Attribute msg) -> List (Html msg) -> Html msg\nsource =\n  Elm.Kernel.VirtualDom.node \"source\"\n\n\n{-| Allows authors to specify timed text track for media elements like `video`\nor `audio`.\n-}\ntrack : List (Attribute msg) -> List (Html msg) -> Html msg\ntrack =\n  Elm.Kernel.VirtualDom.node \"track\"\n\n\n{-| Represents a bitmap area for graphics rendering. -}\ncanvas : List (Attribute msg) -> List (Html msg) -> Html msg\ncanvas =\n  Elm.Kernel.VirtualDom.node \"canvas\"\n\n\n{-| Defines a mathematical formula. -}\nmath : List (Attribute msg) -> List (Html msg) -> Html msg\nmath =\n  Elm.Kernel.VirtualDom.node \"math\"\n\n\n-- TABULAR DATA\n\n{-| Represents data with more than one dimension. -}\ntable : List (Attribute msg) -> List (Html msg) -> Html msg\ntable =\n  Elm.Kernel.VirtualDom.node \"table\"\n\n\n{-| Represents the title of a table. -}\ncaption : List (Attribute msg) -> List (Html msg) -> Html msg\ncaption =\n  Elm.Kernel.VirtualDom.node \"caption\"\n\n\n{-| Represents a set of one or more columns of a table. -}\ncolgroup : List (Attribute msg) -> List (Html msg) -> Html msg\ncolgroup =\n  Elm.Kernel.VirtualDom.node \"colgroup\"\n\n\n{-| Represents a column of a table. -}\ncol : List (Attribute msg) -> List (Html msg) -> Html msg\ncol =\n  Elm.Kernel.VirtualDom.node \"col\"\n\n\n{-| Represents the block of rows that describes the concrete data of a table.\n-}\ntbody : List (Attribute msg) -> List (Html msg) -> Html msg\ntbody =\n  Elm.Kernel.VirtualDom.node \"tbody\"\n\n\n{-| Represents the block of rows that describes the column labels of a table.\n-}\nthead : List (Attribute msg) -> List (Html msg) -> Html msg\nthead =\n  Elm.Kernel.VirtualDom.node \"thead\"\n\n\n{-| Represents the block of rows that describes the column summaries of a table.\n-}\ntfoot : List (Attribute msg) -> List (Html msg) -> Html msg\ntfoot =\n  Elm.Kernel.VirtualDom.node \"tfoot\"\n\n\n{-| Represents a row of cells in a table. -}\ntr : List (Attribute msg) -> List (Html msg) -> Html msg\ntr =\n  Elm.Kernel.VirtualDom.node \"tr\"\n\n\n{-| Represents a data cell in a table. -}\ntd : List (Attribute msg) -> List (Html msg) -> Html msg\ntd =\n  Elm.Kernel.VirtualDom.node \"td\"\n\n\n{-| Represents a header cell in a table. -}\nth : List (Attribute msg) -> List (Html msg) -> Html msg\nth =\n  Elm.Kernel.VirtualDom.node \"th\"\n\n\n-- FORMS\n\n{-| Represents a form, consisting of controls, that can be submitted to a\nserver for processing.\n-}\nform : List (Attribute msg) -> List (Html msg) -> Html msg\nform =\n  Elm.Kernel.VirtualDom.node \"form\"\n\n\n{-| Represents a set of controls. -}\nfieldset : List (Attribute msg) -> List (Html msg) -> Html msg\nfieldset =\n  Elm.Kernel.VirtualDom.node \"fieldset\"\n\n\n{-| Represents the caption for a `fieldset`. -}\nlegend : List (Attribute msg) -> List (Html msg) -> Html msg\nlegend =\n  Elm.Kernel.VirtualDom.node \"legend\"\n\n\n{-| Represents the caption of a form control. -}\nlabel : List (Attribute msg) -> List (Html msg) -> Html msg\nlabel =\n  Elm.Kernel.VirtualDom.node \"label\"\n\n\n{-| Represents a typed data field allowing the user to edit the data. -}\ninput : List (Attribute msg) -> List (Html msg) -> Html msg\ninput =\n  Elm.Kernel.VirtualDom.node \"input\"\n\n\n{-| Represents a button. -}\nbutton : List (Attribute msg) -> List (Html msg) -> Html msg\nbutton =\n  Elm.Kernel.VirtualDom.node \"button\"\n\n\n{-| Represents a control allowing selection among a set of options. -}\nselect : List (Attribute msg) -> List (Html msg) -> Html msg\nselect =\n  Elm.Kernel.VirtualDom.node \"select\"\n\n\n{-| Represents a set of predefined options for other controls. -}\ndatalist : List (Attribute msg) -> List (Html msg) -> Html msg\ndatalist =\n  Elm.Kernel.VirtualDom.node \"datalist\"\n\n\n{-| Represents a set of options, logically grouped. -}\noptgroup : List (Attribute msg) -> List (Html msg) -> Html msg\noptgroup =\n  Elm.Kernel.VirtualDom.node \"optgroup\"\n\n\n{-| Represents an option in a `select` element or a suggestion of a `datalist`\nelement.\n-}\noption : List (Attribute msg) -> List (Html msg) -> Html msg\noption =\n  Elm.Kernel.VirtualDom.node \"option\"\n\n\n{-| Represents a multiline text edit control. -}\ntextarea : List (Attribute msg) -> List (Html msg) -> Html msg\ntextarea =\n  Elm.Kernel.VirtualDom.node \"textarea\"\n\n\n{-| Represents the result of a calculation. -}\noutput : List (Attribute msg) -> List (Html msg) -> Html msg\noutput =\n  Elm.Kernel.VirtualDom.node \"output\"\n\n\n{-| Represents the completion progress of a task. -}\nprogress : List (Attribute msg) -> List (Html msg) -> Html msg\nprogress =\n  Elm.Kernel.VirtualDom.node \"progress\"\n\n\n{-| Represents a scalar measurement (or a fractional value), within a known\nrange.\n-}\nmeter : List (Attribute msg) -> List (Html msg) -> Html msg\nmeter =\n  Elm.Kernel.VirtualDom.node \"meter\"\n\n\n-- INTERACTIVE ELEMENTS\n\n{-| Represents a widget from which the user can obtain additional information\nor controls.\n-}\ndetails : List (Attribute msg) -> List (Html msg) -> Html msg\ndetails =\n  Elm.Kernel.VirtualDom.node \"details\"\n\n\n{-| Represents a summary, caption, or legend for a given `details`. -}\nsummary : List (Attribute msg) -> List (Html msg) -> Html msg\nsummary =\n  Elm.Kernel.VirtualDom.node \"summary\"\n\n\n{-| Represents a command that the user can invoke. -}\nmenuitem : List (Attribute msg) -> List (Html msg) -> Html msg\nmenuitem =\n  Elm.Kernel.VirtualDom.node \"menuitem\"\n\n\n{-| Represents a list of commands. -}\nmenu : List (Attribute msg) -> List (Html msg) -> Html msg\nmenu =\n  Elm.Kernel.VirtualDom.node \"menu\"\n\n" })
        )]

file_tree_node_elm_kernel_modules_http_src =
    TreeNode
        [( "Http.elm"
        , BlobNode ({ utf8 = "effect module Http where { command = MyCmd, subscription = MySub } exposing\n  ( get, post, request\n  , Header, header\n  , Body, emptyBody, stringBody, jsonBody, fileBody, bytesBody\n  , multipartBody, Part, stringPart, filePart, bytesPart\n  , Expect, expectString, expectJson, expectBytes, expectWhatever, Error(..)\n  , track, Progress(..), fractionSent, fractionReceived\n  , cancel\n  , riskyRequest\n  , expectStringResponse, expectBytesResponse, Response(..), Metadata\n  , task, Resolver, stringResolver, bytesResolver, riskyTask\n  )\n\n{-| Send HTTP requests.\n\n# Requests\n@docs get, post, request\n\n# Header\n@docs Header, header\n\n# Body\n@docs Body, emptyBody, stringBody, jsonBody, fileBody, bytesBody\n\n# Body Parts\n@docs multipartBody, Part, stringPart, filePart, bytesPart\n\n# Expect\n@docs Expect, expectString, expectJson, expectBytes, expectWhatever, Error\n\n# Progress\n@docs track, Progress, fractionSent, fractionReceived\n\n# Cancel\n@docs cancel\n\n# Risky Requests\n@docs riskyRequest\n\n# Elaborate Expectations\n@docs expectStringResponse, expectBytesResponse, Response, Metadata\n\n# Tasks\n@docs task, Resolver, stringResolver, bytesResolver, riskyTask\n-}\n\n\nimport Bytes exposing (Bytes)\nimport Bytes.Decode as Bytes\nimport Dict exposing (Dict)\nimport Elm.Kernel.Http\nimport File exposing (File)\nimport Json.Decode as Decode\nimport Json.Encode as Encode\nimport Process\nimport Task exposing (Task)\n\n\n\n-- REQUESTS\n\n\n{-| Create a `GET` request.\n\n    import Http\n\n    type Msg\n      = GotText (Result Http.Error String)\n\n    getPublicOpinion : Cmd Msg\n    getPublicOpinion =\n      Http.get\n        { url = \"https://elm-lang.org/assets/public-opinion.txt\"\n        , expect = Http.expectString GotText\n        }\n\nYou can use functions like [`expectString`](#expectString) and\n[`expectJson`](#expectJson) to interpret the response in different ways. In\nthis example, we are expecting the response body to be a `String` containing\nthe full text of _Public Opinion_by Walter Lippmann.\n\n**Note:** Use [`elm/url`](/packages/elm/url/latest) to build reliable URLs.\n-}\nget\n  : { url : String\n    , expect : Expect msg\n    }\n  -> Cmd msg\nget r =\n  request\n    { method = \"GET\"\n    , headers = []\n    , url = r.url\n    , body = emptyBody\n    , expect = r.expect\n    , timeout = Nothing\n    , tracker = Nothing\n    }\n\n\n{-| Create a `POST` request. So imagine we want to send a POST request for\nsome JSON data. It might look like this:\n\n    import Http\n    import Json.Decode exposing (list, string)\n\n    type Msg\n      = GotBooks (Result Http.Error (List String))\n\n    postBooks : Cmd Msg\n    postBooks =\n      Http.post\n        { url = \"https://example.com/books\"\n        , body = Http.emptyBody\n        , expect = Http.expectJson GotBooks (list string)\n        }\n\nNotice that we are using [`expectJson`](#expectJson) to interpret the response\nas JSON. You can learn more about how JSON decoders work [here][] in the guide.\n\nWe did not put anything in the body of our request, but you can use functions\nlike [`stringBody`](#stringBody) and [`jsonBody`](#jsonBody) if you need to\nsend information to the server.\n\n[here]: https://guide.elm-lang.org/interop/json.html\n-}\npost\n  : { url : String\n    , body : Body\n    , expect : Expect msg\n    }\n  -> Cmd msg\npost r =\n  request\n    { method = \"POST\"\n    , headers = []\n    , url = r.url\n    , body = r.body\n    , expect = r.expect\n    , timeout = Nothing\n    , tracker = Nothing\n    }\n\n\n{-| Create a custom request. For example, a PUT for files might look like this:\n\n    import File\n    import Http\n\n    type Msg = Uploaded (Result Http.Error ())\n\n    upload : File.File -> Cmd Msg\n    upload file =\n      Http.request\n        { method = \"PUT\"\n        , headers = []\n        , url = \"https://example.com/publish\"\n        , body = Http.fileBody file\n        , expect = Http.expectWhatever Uploaded\n        , timeout = Nothing\n        , tracker = Nothing\n        }\n\nIt lets you set custom `headers` as needed. The `timeout` is the number of\nmilliseconds you are willing to wait before giving up. The `tracker` lets you\n[`cancel`](#cancel) and [`track`](#track) requests.\n-}\nrequest\n  : { method : String\n    , headers : List Header\n    , url : String\n    , body : Body\n    , expect : Expect msg\n    , timeout : Maybe Float\n    , tracker : Maybe String\n    }\n  -> Cmd msg\nrequest r =\n  command <| Request <|\n    { method = r.method\n    , headers = r.headers\n    , url = r.url\n    , body = r.body\n    , expect = r.expect\n    , timeout = r.timeout\n    , tracker = r.tracker\n    , allowCookiesFromOtherDomains = False\n    }\n\n\n\n-- HEADERS\n\n\n{-| An HTTP header for configuring requests. See a bunch of common headers\n[here](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields).\n-}\ntype Header = Header String String\n\n\n{-| Create a `Header`.\n\n    header \"If-Modified-Since\" \"Sat 29 Oct 1994 19:43:31 GMT\"\n    header \"Max-Forwards\" \"10\"\n    header \"X-Requested-With\" \"XMLHttpRequest\"\n-}\nheader : String -> String -> Header\nheader =\n  Header\n\n\n\n-- BODY\n\n\n{-| Represents the body of a `Request`.\n-}\ntype Body = Body\n\n\n{-| Create an empty body for your `Request`. This is useful for GET requests\nand POST requests where you are not sending any data.\n-}\nemptyBody : Body\nemptyBody =\n  Elm.Kernel.Http.emptyBody\n\n\n{-| Put some JSON value in the body of your `Request`.\n\nMaybe you want to search for 10 books relevant to a certain topic:\n\n    import Http\n    import Json.Encode as E\n\n    searchForBooks : String -> Cmd Msg\n    searchForBooks topic =\n      Http.post\n        { url = \"https://api.example.com/books\"\n        , body =\n            Http.jsonBody <|\n              E.object\n                [ ( \"topic\", E.string topic )\n                , ( \"limit\", E.int 10 )\n                ]\n        , expect =\n            Http.expectJson GotBooks booksDecoder\n        }\n\n**Note:** This will automatically add the `Content-Type: application/json` header.\n-}\njsonBody : Encode.Value -> Body\njsonBody value =\n  Elm.Kernel.Http.pair \"application/json\" (Encode.encode 0 value)\n\n\n{-| Put some string in the body of your `Request`. Defining `jsonBody` looks\nlike this:\n\n    import Json.Encode as Encode\n\n    jsonBody : Encode.Value -> Body\n    jsonBody value =\n      stringBody \"application/json\" (Encode.encode 0 value)\n\nThe first argument is a [MIME type](https://en.wikipedia.org/wiki/Media_type)\nof the body. Some servers are strict about this!\n-}\nstringBody : String -> String -> Body\nstringBody =\n  Elm.Kernel.Http.pair\n\n\n{-| Put some `Bytes` in the body of your `Request`. This allows you to use\n[`elm/bytes`](/packages/elm/bytes/latest) to have full control over the binary\nrepresentation of the data you are sending. For example, you could create an\n`archive.zip` file and send it along like this:\n\n    import Bytes exposing (Bytes)\n\n    zipBody : Bytes -> Body\n    zipBody bytes =\n      bytesBody \"application/zip\" bytes\n\nThe first argument is a [MIME type](https://en.wikipedia.org/wiki/Media_type)\nof the body. In other scenarios you may want to use MIME types like `image/png`\nor `image/jpeg` instead.\n\n**Note:** Use [`track`](#track) to track upload progress.\n-}\nbytesBody : String -> Bytes -> Body\nbytesBody =\n  Elm.Kernel.Http.pair\n\n\n{-| Use a file as the body of your `Request`. When someone uploads an image\ninto the browser with [`elm/file`](/packages/elm/file/latest) you can forward\nit to a server.\n\nThis will automatically set the `Content-Type` to the MIME type of the file.\n\n**Note:** Use [`track`](#track) to track upload progress.\n-}\nfileBody : File -> Body\nfileBody =\n  Elm.Kernel.Http.pair \"\"\n\n\n\n-- PARTS\n\n\n{-| When someone clicks submit on the `<form>`, browsers send a special HTTP\nrequest with all the form data. Something like this:\n\n```\nPOST /test.html HTTP/1.1\nHost: example.org\nContent-Type: multipart/form-data;boundary=\"7MA4YWxkTrZu0gW\"\n\n--7MA4YWxkTrZu0gW\nContent-Disposition: form-data; name=\"title\"\n\nTrip to London\n--7MA4YWxkTrZu0gW\nContent-Disposition: form-data; name=\"album[]\"; filename=\"parliment.jpg\"\n\n...RAW...IMAGE...BITS...\n--7MA4YWxkTrZu0gW--\n```\n\nThis was the only way to send files for a long time, so many servers expect\ndata in this format. **The `multipartBody` function lets you create these\nrequests.** For example, to upload a photo album all at once, you could create\na body like this:\n\n    multipartBody\n      [ stringPart \"title\" \"Trip to London\"\n      , filePart \"album[]\" file1\n      , filePart \"album[]\" file2\n      , filePart \"album[]\" file3\n      ]\n\nAll of the body parts need to have a name. Names can be repeated. Adding the\n`[]` on repeated names is a convention from PHP. It seems weird, but I see it\nenough to mention it. You do not have to do it that way, especially if your\nserver uses some other convention!\n\nThe `Content-Type: multipart/form-data` header is automatically set when\ncreating a body this way.\n\n**Note:** Use [`track`](#track) to track upload progress.\n-}\nmultipartBody : List Part -> Body\nmultipartBody parts =\n  Elm.Kernel.Http.pair \"\" (Elm.Kernel.Http.toFormData parts)\n\n\n{-| One part of a `multipartBody`.\n-}\ntype Part = Part\n\n\n{-| A part that contains `String` data.\n\n    multipartBody\n      [ stringPart \"title\" \"Tom\"\n      , filePart \"photo\" tomPng\n      ]\n-}\nstringPart : String -> String -> Part\nstringPart =\n  Elm.Kernel.Http.pair\n\n\n{-| A part that contains a file. You can use\n[`elm/file`](/packages/elm/file/latest) to get files loaded into the\nbrowser. From there, you can send it along to a server like this:\n\n    multipartBody\n      [ stringPart \"product\" \"Ikea Bekant\"\n      , stringPart \"description\" \"Great desk for home office.\"\n      , filePart \"image[]\" file1\n      , filePart \"image[]\" file2\n      , filePart \"image[]\" file3\n      ]\n-}\nfilePart : String -> File -> Part\nfilePart =\n  Elm.Kernel.Http.pair\n\n\n{-| A part that contains bytes, allowing you to use\n[`elm/bytes`](/packages/elm/bytes/latest) to encode data exactly in the format\nyou need.\n\n    multipartBody\n      [ stringPart \"title\" \"Tom\"\n      , bytesPart \"photo\" \"image/png\" bytes\n      ]\n\n**Note:** You must provide a MIME type so that the receiver has clues about\nhow to interpret the bytes.\n-}\nbytesPart : String -> String -> Bytes -> Part\nbytesPart key mime bytes =\n  Elm.Kernel.Http.pair key (Elm.Kernel.Http.bytesToBlob mime bytes)\n\n\n\n-- EXPECT\n\n\n{-| Logic for interpreting a response body.\n-}\ntype Expect msg = Expect\n\n\n{-| Expect the response body to be a `String`. Like when getting the full text\nof a book:\n\n    import Http\n\n    type Msg\n      = GotText (Result Http.Error String)\n\n    getPublicOpinion : Cmd Msg\n    getPublicOpinion =\n      Http.get\n        { url = \"https://elm-lang.org/assets/public-opinion.txt\"\n        , expect = Http.expectString GotText\n        }\n\nThe response body is always some sequence of bytes, but in this case, we\nexpect it to be UTF-8 encoded text that can be turned into a `String`.\n-}\nexpectString : (Result Error String -> msg) -> Expect msg\nexpectString toMsg =\n  expectStringResponse toMsg (resolve Ok)\n\n\n{-| Expect the response body to be JSON. Like if you want to get a random cat\nGIF you might say:\n\n    import Http\n    import Json.Decode exposing (Decoder, field, string)\n\n    type Msg\n      = GotGif (Result Http.Error String)\n\n    getRandomCatGif : Cmd Msg\n    getRandomCatGif =\n      Http.get\n        { url = \"https://api.giphy.com/v1/gifs/random?api_key=dc6zaTOxFJmzC&tag=cat\"\n        , expect = Http.expectJson GotGif gifDecoder\n        }\n\n    gifDecoder : Decoder String\n    gifDecoder =\n      field \"data\" (field \"image_url\" string)\n\nThe official guide goes through this particular example [here][]. That page\nalso introduces [`elm/json`][json] to help you get started turning JSON into\nElm values in other situations.\n\n[here]: https://guide.elm-lang.org/interop/json.html\n[json]: /packages/elm/json/latest/\n\nIf the JSON decoder fails, you get a `BadBody` error that tries to explain\nwhat went wrong.\n-}\nexpectJson : (Result Error a -> msg) -> Decode.Decoder a -> Expect msg\nexpectJson toMsg decoder =\n  expectStringResponse toMsg <| resolve <|\n    \\string ->\n      Result.mapError Decode.errorToString (Decode.decodeString decoder string)\n\n\n{-| Expect the response body to be binary data. For example, maybe you are\ntalking to an endpoint that gives back ProtoBuf data:\n\n    import Bytes.Decode as Bytes\n    import Http\n\n    type Msg\n      = GotData (Result Http.Error Data)\n\n    getData : Cmd Msg\n    getData =\n      Http.get\n        { url = \"/data\"\n        , expect = Http.expectBytes GotData dataDecoder\n        }\n\n    -- dataDecoder : Bytes.Decoder Data\n\nYou would use [`elm/bytes`](/packages/elm/bytes/latest/) to decode the binary\ndata according to a proto definition file like `example.proto`.\n\nIf the decoder fails, you get a `BadBody` error that just indicates that\n_something_ went wrong. It probably makes sense to debug by peeking at the\nbytes you are getting in the browser developer tools or something.\n-}\nexpectBytes : (Result Error a -> msg) -> Bytes.Decoder a -> Expect msg\nexpectBytes toMsg decoder =\n  expectBytesResponse toMsg <| resolve <|\n    \\bytes ->\n      Result.fromMaybe \"unexpected bytes\" (Bytes.decode decoder bytes)\n\n\n{-| Expect the response body to be whatever. It does not matter. Ignore it!\nFor example, you might want this when uploading files:\n\n    import Http\n\n    type Msg\n      = Uploaded (Result Http.Error ())\n\n    upload : File -> Cmd Msg\n    upload file =\n      Http.post\n        { url = \"/upload\"\n        , body = Http.fileBody file\n        , expect = Http.expectWhatever Uploaded\n        }\n\nThe server may be giving back a response body, but we do not care about it.\n-}\nexpectWhatever : (Result Error () -> msg) -> Expect msg\nexpectWhatever toMsg =\n  expectBytesResponse toMsg (resolve (\\_ -> Ok ()))\n\n\nresolve : (body -> Result String a) -> Response body -> Result Error a\nresolve toResult response =\n  case response of\n    BadUrl_ url -> Err (BadUrl url)\n    Timeout_ -> Err Timeout\n    NetworkError_ -> Err NetworkError\n    BadStatus_ metadata _ -> Err (BadStatus metadata.statusCode)\n    GoodStatus_ _ body -> Result.mapError BadBody (toResult body)\n\n\n{-| A `Request` can fail in a couple ways:\n\n- `BadUrl` means you did not provide a valid URL.\n- `Timeout` means it took too long to get a response.\n- `NetworkError` means the user turned off their wifi, went in a cave, etc.\n- `BadStatus` means you got a response back, but the status code indicates failure.\n- `BadBody` means you got a response back with a nice status code, but the body\nof the response was something unexpected. The `String` in this case is a\ndebugging message that explains what went wrong with your JSON decoder or\nwhatever.\n\n**Note:** You can use [`expectStringResponse`](#expectStringResponse) and\n[`expectBytesResponse`](#expectBytesResponse) to get more flexibility on this.\n-}\ntype Error\n  = BadUrl String\n  | Timeout\n  | NetworkError\n  | BadStatus Int\n  | BadBody String\n\n\n\n-- ELABORATE EXPECTATIONS\n\n\n{-| Expect a [`Response`](#Response) with a `String` body. So you could define\nyour own [`expectJson`](#expectJson) like this:\n\n    import Http\n    import Json.Decode as D\n\n    expectJson : (Result Http.Error a -> msg) -> D.Decoder a -> Expect msg\n    expectJson toMsg decoder =\n      expectStringResponse toMsg <|\n        \\response ->\n          case response of\n            Http.BadUrl_ url ->\n              Err (Http.BadUrl url)\n\n            Http.Timeout_ ->\n              Err Http.Timeout\n\n            Http.NetworkError_ ->\n              Err Http.NetworkError\n\n            Http.BadStatus_ metadata body ->\n              Err (Http.BadStatus metadata.statusCode)\n\n            Http.GoodStatus_ metadata body ->\n              case D.decodeString decoder body of\n                Ok value ->\n                  Ok value\n\n                Err err ->\n                  Err (Http.BadBody (D.errorToString err))\n\nThis function is great for fancier error handling and getting response headers.\nFor example, maybe when your sever gives a 404 status code (not found) it also\nprovides a helpful JSON message in the response body. This function lets you\nadd logic to the `BadStatus_` branch so you can parse that JSON and give users\na more helpful message! Or make your own custom error type for your particular\napplication!\n-}\nexpectStringResponse : (Result x a -> msg) -> (Response String -> Result x a) -> Expect msg\nexpectStringResponse toMsg toResult =\n  Elm.Kernel.Http.expect \"\" identity (toResult >> toMsg)\n\n\n{-| Expect a [`Response`](#Response) with a `Bytes` body.\n\nIt works just like [`expectStringResponse`](#expectStringResponse), giving you\nmore access to headers and more leeway in defining your own errors.\n-}\nexpectBytesResponse : (Result x a -> msg) -> (Response Bytes -> Result x a) -> Expect msg\nexpectBytesResponse toMsg toResult =\n  Elm.Kernel.Http.expect \"arraybuffer\" Elm.Kernel.Http.toDataView (toResult >> toMsg)\n\n\n{-| A `Response` can come back a couple different ways:\n\n- `BadUrl_` &mdash; you did not provide a valid URL.\n- `Timeout_` &mdash; it took too long to get a response.\n- `NetworkError_` &mdash; the user turned off their wifi, went in a cave, etc.\n- `BadStatus_` &mdash; a response arrived, but the status code indicates failure.\n- `GoodStatus_` &mdash; a response arrived with a nice status code!\n\nThe type of the `body` depends on whether you use\n[`expectStringResponse`](#expectStringResponse)\nor [`expectBytesResponse`](#expectBytesResponse).\n-}\ntype Response body\n  = BadUrl_ String\n  | Timeout_\n  | NetworkError_\n  | BadStatus_ Metadata body\n  | GoodStatus_ Metadata body\n\n\n{-| Extra information about the response:\n\n- `url` of the server that actually responded (so you can detect redirects)\n- `statusCode` like `200` or `404`\n- `statusText` describing what the `statusCode` means a little\n- `headers` like `Content-Length` and `Expires`\n\n**Note:** It is possible for a response to have the same header multiple times.\nIn that case, all the values end up in a single entry in the `headers`\ndictionary. The values are separated by commas, following the rules outlined\n[here](https://stackoverflow.com/questions/4371328/are-duplicate-http-response-headers-acceptable).\n-}\ntype alias Metadata =\n  { url : String\n  , statusCode : Int\n  , statusText : String\n  , headers : Dict String String\n  }\n\n\n\n-- CANCEL\n\n\n{-| Try to cancel an ongoing request based on a `tracker`.\n-}\ncancel : String -> Cmd msg\ncancel tracker =\n  command (Cancel tracker)\n\n\n\n-- PROGRESS\n\n\n{-| Track the progress of a request. Create a [`request`](#request) where\n`tracker = Just \"form.pdf\"` and you can track it with a subscription like\n`track \"form.pdf\" GotProgress`.\n-}\ntrack : String -> (Progress -> msg) -> Sub msg\ntrack tracker toMsg =\n  subscription (MySub tracker toMsg)\n\n\n{-| There are two phases to HTTP requests. First you **send** a bunch of data,\nthen you **receive** a bunch of data. For example, say you use `fileBody` to\nupload a file of 262144 bytes. From there, progress will go like this:\n\n```\nSending   { sent =      0, size = 262144 }  -- 0.0\nSending   { sent =  65536, size = 262144 }  -- 0.25\nSending   { sent = 131072, size = 262144 }  -- 0.5\nSending   { sent = 196608, size = 262144 }  -- 0.75\nSending   { sent = 262144, size = 262144 }  -- 1.0\nReceiving { received =  0, size = Just 16 } -- 0.0\nReceiving { received = 16, size = Just 16 } -- 1.0\n```\n\nWith file uploads, the **send** phase is expensive. That is what we saw in our\nexample. But with file downloads, the **receive** phase is expensive.\n\nUse [`fractionSent`](#fractionSent) and [`fractionReceived`](#fractionReceived)\nto turn this progress information into specific fractions!\n\n**Note:** The `size` of the response is based on the [`Content-Length`][cl]\nheader, and in rare and annoying cases, a server may not include that header.\nThat is why the `size` is a `Maybe Int` in `Receiving`.\n\n[cl]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Length\n-}\ntype Progress\n  = Sending { sent : Int, size : Int }\n  | Receiving { received : Int, size : Maybe Int }\n\n\n{-| Turn `Sending` progress into a useful fraction.\n\n    fractionSent { sent =   0, size = 1024 } == 0.0\n    fractionSent { sent = 256, size = 1024 } == 0.25\n    fractionSent { sent = 512, size = 1024 } == 0.5\n\n    -- fractionSent { sent = 0, size = 0 } == 1.0\n\nThe result is always between `0.0` and `1.0`, ensuring that any progress bar\nanimations never go out of bounds.\n\nAnd notice that `size` can be zero. That means you are sending a request with\nan empty body. Very common! When `size` is zero, the result is always `1.0`.\n\n**Note:** If you create your own function to compute this fraction, watch out\nfor divide-by-zero errors!\n-}\nfractionSent : { sent : Int, size : Int } -> Float\nfractionSent p =\n  if p.size == 0 then\n    1\n  else\n    clamp 0 1 (toFloat p.sent / toFloat p.size)\n\n\n{-| Turn `Receiving` progress into a useful fraction for progress bars.\n\n    fractionReceived { received =   0, size = Just 1024 } == 0.0\n    fractionReceived { received = 256, size = Just 1024 } == 0.25\n    fractionReceived { received = 512, size = Just 1024 } == 0.5\n\n    -- fractionReceived { received =   0, size = Nothing } == 0.0\n    -- fractionReceived { received = 256, size = Nothing } == 0.0\n    -- fractionReceived { received = 512, size = Nothing } == 0.0\n\nThe `size` here is based on the [`Content-Length`][cl] header which may be\nmissing in some cases. A server may be misconfigured or it may be streaming\ndata and not actually know the final size. Whatever the case, this function\nwill always give `0.0` when the final size is unknown.\n\nFurthermore, the `Content-Length` header may be incorrect! The implementation\nclamps the fraction between `0.0` and `1.0`, so you will just get `1.0` if\nyou ever receive more bytes than promised.\n\n**Note:** If you are streaming something, you can write a custom version of\nthis function that just tracks bytes received. Maybe you show that 22kb or 83kb\nhave been downloaded, without a specific fraction. If you do this, be wary of\ndivide-by-zero errors because `size` can always be zero!\n\n[cl]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Length\n-}\nfractionReceived : { received : Int, size : Maybe Int } -> Float\nfractionReceived p =\n  case p.size of\n    Nothing ->\n      0\n\n    Just n ->\n      if n == 0 then\n        1\n      else\n        clamp 0 1 (toFloat p.received / toFloat n)\n\n\n\n-- CUSTOM REQUESTS\n\n\n{-| Create a request with a risky security policy. Things like:\n\n- Allow responses from other domains to set cookies.\n- Include cookies in requests to other domains.\n\nThis is called [`withCredentials`][wc] in JavaScript, and it allows a couple\nother risky things as well. It can be useful if `www.example.com` needs to\ntalk to `uploads.example.com`, but it should be used very carefully!\n\nFor example, every HTTP request includes a `Origin` header revealing the domain,\nso any request to `facebook.com` reveals the website that sent it. From there,\ncookies can be used to correlate browsing habits with specific users. Oh, it\nlooks like they visited `example.com`. Maybe they want ads about examples!\nThis is why you can get shoe ads for months without saying anything about it\non any social networks. **This risk exists even for people who do not have an\naccount.** Servers can set a new cookie to uniquely identify the browser and\nbuild a profile around that. Same kind of tricks for logged out users.\n\n**Context:** A significantly worse version of this can happen when trying to\nadd integrations with Google, Facebook, Pinterest, Twitter, etc. Add our share\nbutton. It is super easy. Just add this `<script>` tag! But the goal here is\nto get _arbitrary_ access to the executing context. Now they can track clicks,\nread page content, use time zones to approximate location, etc. As of this\nwriting, suggesting that developers just embed `<script>` tags is the default\nfor Google Analytics, Facebook Like Buttons, Twitter Follow Buttons, Pinterest\nSave Buttons, and Instagram Embeds.\n\n[ah]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization\n[wc]: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials\n-}\nriskyRequest\n  : { method : String\n    , headers : List Header\n    , url : String\n    , body : Body\n    , expect : Expect msg\n    , timeout : Maybe Float\n    , tracker : Maybe String\n    }\n  -> Cmd msg\nriskyRequest r =\n  command <| Request <|\n    { method = r.method\n    , headers = r.headers\n    , url = r.url\n    , body = r.body\n    , expect = r.expect\n    , timeout = r.timeout\n    , tracker = r.tracker\n    , allowCookiesFromOtherDomains = True\n    }\n\n\n\n-- TASKS\n\n\n{-| Just like [`request`](#request), but it creates a `Task`. This makes it\npossible to pair your HTTP request with `Time.now` if you need timestamps for\nsome reason. **This should be quite rare.**\n-}\ntask\n  : { method : String\n    , headers : List Header\n    , url : String\n    , body : Body\n    , resolver : Resolver x a\n    , timeout : Maybe Float\n    }\n  -> Task x a\ntask r =\n  Elm.Kernel.Http.toTask () resultToTask\n    { method = r.method\n    , headers = r.headers\n    , url = r.url\n    , body = r.body\n    , expect = r.resolver\n    , timeout = r.timeout\n    , tracker = Nothing\n    , allowCookiesFromOtherDomains = False\n    }\n\n\n{-| Describes how to resolve an HTTP task. You can create a resolver with\n[`stringResolver`](#stringResolver) and [`bytesResolver`](#bytesResolver).\n-}\ntype Resolver x a = Resolver\n\n\n{-| Turn a response with a `String` body into a result.\nSimilar to [`expectStringResponse`](#expectStringResponse).\n-}\nstringResolver : (Response String -> Result x a) -> Resolver x a\nstringResolver =\n  Elm.Kernel.Http.expect \"\" identity\n\n\n{-| Turn a response with a `Bytes` body into a result.\nSimilar to [`expectBytesResponse`](#expectBytesResponse).\n-}\nbytesResolver : (Response Bytes -> Result x a) -> Resolver x a\nbytesResolver =\n  Elm.Kernel.Http.expect \"arraybuffer\" Elm.Kernel.Http.toDataView\n\n\n{-| Just like [`riskyRequest`](#riskyRequest), but it creates a `Task`. **Use\nwith caution!** This has all the same security concerns as `riskyRequest`.\n-}\nriskyTask\n  : { method : String\n    , headers : List Header\n    , url : String\n    , body : Body\n    , resolver : Resolver x a\n    , timeout : Maybe Float\n    }\n  -> Task x a\nriskyTask r =\n  Elm.Kernel.Http.toTask () resultToTask\n    { method = r.method\n    , headers = r.headers\n    , url = r.url\n    , body = r.body\n    , expect = r.resolver\n    , timeout = r.timeout\n    , tracker = Nothing\n    , allowCookiesFromOtherDomains = True\n    }\n\n\nresultToTask : Result x a -> Task x a\nresultToTask result =\n  case result of\n    Ok a -> Task.succeed a\n    Err x -> Task.fail x\n\n\n\n-- COMMANDS and SUBSCRIPTIONS\n\n\ntype MyCmd msg\n  = Cancel String\n  | Request\n      { method : String\n      , headers : List Header\n      , url : String\n      , body : Body\n      , expect : Expect msg\n      , timeout : Maybe Float\n      , tracker : Maybe String\n      , allowCookiesFromOtherDomains : Bool\n      }\n\n\ncmdMap : (a -> b) -> MyCmd a -> MyCmd b\ncmdMap func cmd =\n  case cmd of\n    Cancel tracker ->\n      Cancel tracker\n\n    Request r ->\n      Request\n        { method = r.method\n        , headers = r.headers\n        , url = r.url\n        , body = r.body\n        , expect = Elm.Kernel.Http.mapExpect func r.expect\n        , timeout = r.timeout\n        , tracker = r.tracker\n        , allowCookiesFromOtherDomains = r.allowCookiesFromOtherDomains\n        }\n\n\ntype MySub msg =\n  MySub String (Progress -> msg)\n\n\nsubMap : (a -> b) -> MySub a -> MySub b\nsubMap func (MySub tracker toMsg) =\n  MySub tracker (toMsg >> func)\n\n\n\n-- EFFECT MANAGER\n\n\ntype alias State msg =\n  { reqs : Dict String Process.Id\n  , subs : List (MySub msg)\n  }\n\n\ninit : Task Never (State msg)\ninit =\n  Task.succeed (State Dict.empty [])\n\n\ntype alias MyRouter msg =\n  Platform.Router msg SelfMsg\n\n\n\n-- APP MESSAGES\n\n\nonEffects : MyRouter msg -> List (MyCmd msg) -> List (MySub msg) -> State msg -> Task Never (State msg)\nonEffects router cmds subs state =\n  updateReqs router cmds state.reqs\n    |> Task.andThen (\\reqs -> Task.succeed (State reqs subs))\n\n\nupdateReqs : MyRouter msg -> List (MyCmd msg) -> Dict String Process.Id -> Task x (Dict String Process.Id)\nupdateReqs router cmds reqs =\n  case cmds of\n    [] ->\n      Task.succeed reqs\n\n    cmd :: otherCmds ->\n      case cmd of\n        Cancel tracker ->\n          case Dict.get tracker reqs of\n            Nothing ->\n              updateReqs router otherCmds reqs\n\n            Just pid ->\n              Process.kill pid\n                |> Task.andThen (\\_ -> updateReqs router otherCmds (Dict.remove tracker reqs))\n\n        Request req ->\n          Process.spawn (Elm.Kernel.Http.toTask router (Platform.sendToApp router) req)\n            |> Task.andThen (\\pid ->\n                  case req.tracker of\n                    Nothing ->\n                      updateReqs router otherCmds reqs\n\n                    Just tracker ->\n                      updateReqs router otherCmds (Dict.insert tracker pid reqs)\n              )\n\n\n\n-- SELF MESSAGES\n\n\ntype alias SelfMsg =\n  (String, Progress)\n\n\nonSelfMsg : MyRouter msg -> SelfMsg -> State msg -> Task Never (State msg)\nonSelfMsg router (tracker, progress) state =\n  Task.sequence (List.filterMap (maybeSend router tracker progress) state.subs)\n    |> Task.andThen (\\_ -> Task.succeed state)\n\n\nmaybeSend : MyRouter msg -> String -> Progress -> MySub msg -> Maybe (Task x ())\nmaybeSend router desiredTracker progress (MySub actualTracker toMsg) =\n  if desiredTracker == actualTracker then\n    Just (Platform.sendToApp router (toMsg progress))\n  else\n    Nothing\n" })
        )]

file_tree_node_elm_kernel_modules_json_src =
    TreeNode
        [( "Json"
        , TreeNode
            [( "Decode.elm"
            , BlobNode ({ utf8 = "module Json.Decode exposing\n  ( Decoder, string, bool, int, float\n  , nullable, list, array, dict, keyValuePairs, oneOrMore\n  , field, at, index\n  , maybe, oneOf\n  , decodeString, decodeValue, Value, Error(..), errorToString\n  , map, map2, map3, map4, map5, map6, map7, map8\n  , lazy, value, null, succeed, fail, andThen\n  )\n\n{-| Turn JSON values into Elm values. Definitely check out this [intro to\nJSON decoders][guide] to get a feel for how this library works!\n\n[guide]: https://guide.elm-lang.org/effects/json.html\n\n# Primitives\n@docs Decoder, string, bool, int, float\n\n# Data Structures\n@docs nullable, list, array, dict, keyValuePairs, oneOrMore\n\n# Object Primitives\n@docs field, at, index\n\n# Inconsistent Structure\n@docs maybe, oneOf\n\n# Run Decoders\n@docs decodeString, decodeValue, Value, Error, errorToString\n\n# Mapping\n\n**Note:** If you run out of map functions, take a look at [elm-json-decode-pipeline][pipe]\nwhich makes it easier to handle large objects, but produces lower quality type\nerrors.\n\n[pipe]: /packages/NoRedInk/elm-json-decode-pipeline/latest\n\n@docs map, map2, map3, map4, map5, map6, map7, map8\n\n# Fancy Decoding\n@docs lazy, value, null, succeed, fail, andThen\n-}\n\n\nimport Array exposing (Array)\nimport Dict exposing (Dict)\nimport Json.Encode\nimport Elm.Kernel.Json\n\n\n\n-- PRIMITIVES\n\n\n{-| A value that knows how to decode JSON values.\n\nThere is a whole section in `guide.elm-lang.org` about decoders, so [check it\nout](https://guide.elm-lang.org/interop/json.html) for a more comprehensive\nintroduction!\n-}\ntype Decoder a = Decoder\n\n\n{-| Decode a JSON string into an Elm `String`.\n\n    decodeString string \"true\"              == Err ...\n    decodeString string \"42\"                == Err ...\n    decodeString string \"3.14\"              == Err ...\n    decodeString string \"\\\"hello\\\"\"         == Ok \"hello\"\n    decodeString string \"{ \\\"hello\\\": 42 }\" == Err ...\n-}\nstring : Decoder String\nstring =\n  Elm.Kernel.Json.decodeString\n\n\n{-| Decode a JSON boolean into an Elm `Bool`.\n\n    decodeString bool \"true\"              == Ok True\n    decodeString bool \"42\"                == Err ...\n    decodeString bool \"3.14\"              == Err ...\n    decodeString bool \"\\\"hello\\\"\"         == Err ...\n    decodeString bool \"{ \\\"hello\\\": 42 }\" == Err ...\n-}\nbool : Decoder Bool\nbool =\n  Elm.Kernel.Json.decodeBool\n\n\n{-| Decode a JSON number into an Elm `Int`.\n\n    decodeString int \"true\"              == Err ...\n    decodeString int \"42\"                == Ok 42\n    decodeString int \"3.14\"              == Err ...\n    decodeString int \"\\\"hello\\\"\"         == Err ...\n    decodeString int \"{ \\\"hello\\\": 42 }\" == Err ...\n-}\nint : Decoder Int\nint =\n  Elm.Kernel.Json.decodeInt\n\n\n{-| Decode a JSON number into an Elm `Float`.\n\n    decodeString float \"true\"              == Err ..\n    decodeString float \"42\"                == Ok 42\n    decodeString float \"3.14\"              == Ok 3.14\n    decodeString float \"\\\"hello\\\"\"         == Err ...\n    decodeString float \"{ \\\"hello\\\": 42 }\" == Err ...\n-}\nfloat : Decoder Float\nfloat =\n  Elm.Kernel.Json.decodeFloat\n\n\n\n-- DATA STRUCTURES\n\n\n{-| Decode a nullable JSON value into an Elm value.\n\n    decodeString (nullable int) \"13\"    == Ok (Just 13)\n    decodeString (nullable int) \"42\"    == Ok (Just 42)\n    decodeString (nullable int) \"null\"  == Ok Nothing\n    decodeString (nullable int) \"true\"  == Err ..\n-}\nnullable : Decoder a -> Decoder (Maybe a)\nnullable decoder =\n  oneOf\n    [ null Nothing\n    , map Just decoder\n    ]\n\n\n{-| Decode a JSON array into an Elm `List`.\n\n    decodeString (list int) \"[1,2,3]\"       == Ok [1,2,3]\n    decodeString (list bool) \"[true,false]\" == Ok [True,False]\n-}\nlist : Decoder a -> Decoder (List a)\nlist =\n  Elm.Kernel.Json.decodeList\n\n\n{-| Decode a JSON array into an Elm `Array`.\n\n    decodeString (array int) \"[1,2,3]\"       == Ok (Array.fromList [1,2,3])\n    decodeString (array bool) \"[true,false]\" == Ok (Array.fromList [True,False])\n-}\narray : Decoder a -> Decoder (Array a)\narray =\n  Elm.Kernel.Json.decodeArray\n\n\n{-| Decode a JSON object into an Elm `Dict`.\n\n    decodeString (dict int) \"{ \\\"alice\\\": 42, \\\"bob\\\": 99 }\"\n      == Ok (Dict.fromList [(\"alice\", 42), (\"bob\", 99)])\n\nIf you need the keys (like `\"alice\"` and `\"bob\"`) available in the `Dict`\nvalues as well, I recommend using a (private) intermediate data structure like\n`Info` in this example:\n\n    module User exposing (User, decoder)\n\n    import Dict\n    import Json.Decode exposing (..)\n\n    type alias User =\n      { name : String\n      , height : Float\n      , age : Int\n      }\n\n    decoder : Decoder (Dict.Dict String User)\n    decoder =\n      map (Dict.map infoToUser) (dict infoDecoder)\n\n    type alias Info =\n      { height : Float\n      , age : Int\n      }\n\n    infoDecoder : Decoder Info\n    infoDecoder =\n      map2 Info\n        (field \"height\" float)\n        (field \"age\" int)\n\n    infoToUser : String -> Info -> User\n    infoToUser name { height, age } =\n      User name height age\n\nSo now JSON like `{ \"alice\": { height: 1.6, age: 33 }}` are turned into\ndictionary values like `Dict.singleton \"alice\" (User \"alice\" 1.6 33)` if\nyou need that.\n-}\ndict : Decoder a -> Decoder (Dict String a)\ndict decoder =\n  map Dict.fromList (keyValuePairs decoder)\n\n\n{-| Decode a JSON object into an Elm `List` of pairs.\n\n    decodeString (keyValuePairs int) \"{ \\\"alice\\\": 42, \\\"bob\\\": 99 }\"\n      == Ok [(\"alice\", 42), (\"bob\", 99)]\n-}\nkeyValuePairs : Decoder a -> Decoder (List (String, a))\nkeyValuePairs =\n  Elm.Kernel.Json.decodeKeyValuePairs\n\n\n{-| Decode a JSON array that has one or more elements. This comes up if you\nwant to enable drag-and-drop of files into your application. You would pair\nthis function with [`elm/file`]() to write a `dropDecoder` like this:\n\n    import File exposing (File)\n    import Json.Decoder as D\n\n    type Msg\n      = GotFiles File (List Files)\n\n    inputDecoder : D.Decoder Msg\n    inputDecoder =\n      D.at [\"dataTransfer\",\"files\"] (D.oneOrMore GotFiles File.decoder)\n\nThis captures the fact that you can never drag-and-drop zero files.\n-}\noneOrMore : (a -> List a -> value) -> Decoder a -> Decoder value\noneOrMore toValue decoder =\n  list decoder\n    |> andThen (oneOrMoreHelp toValue)\n\n\noneOrMoreHelp : (a -> List a -> value) -> List a -> Decoder value\noneOrMoreHelp toValue xs =\n  case xs of\n    [] ->\n      fail \"a ARRAY with at least ONE element\"\n\n    y :: ys ->\n      succeed (toValue y ys)\n\n\n\n-- OBJECT PRIMITIVES\n\n\n{-| Decode a JSON object, requiring a particular field.\n\n    decodeString (field \"x\" int) \"{ \\\"x\\\": 3 }\"            == Ok 3\n    decodeString (field \"x\" int) \"{ \\\"x\\\": 3, \\\"y\\\": 4 }\"  == Ok 3\n    decodeString (field \"x\" int) \"{ \\\"x\\\": true }\"         == Err ...\n    decodeString (field \"x\" int) \"{ \\\"y\\\": 4 }\"            == Err ...\n\n    decodeString (field \"name\" string) \"{ \\\"name\\\": \\\"tom\\\" }\" == Ok \"tom\"\n\nThe object *can* have other fields. Lots of them! The only thing this decoder\ncares about is if `x` is present and that the value there is an `Int`.\n\nCheck out [`map2`](#map2) to see how to decode multiple fields!\n-}\nfield : String -> Decoder a -> Decoder a\nfield =\n    Elm.Kernel.Json.decodeField\n\n\n{-| Decode a nested JSON object, requiring certain fields.\n\n    json = \"\"\"{ \"person\": { \"name\": \"tom\", \"age\": 42 } }\"\"\"\n\n    decodeString (at [\"person\", \"name\"] string) json  == Ok \"tom\"\n    decodeString (at [\"person\", \"age\" ] int   ) json  == Ok 42\n\nThis is really just a shorthand for saying things like:\n\n    field \"person\" (field \"name\" string) == at [\"person\",\"name\"] string\n-}\nat : List String -> Decoder a -> Decoder a\nat fields decoder =\n    List.foldr field decoder fields\n\n\n{-| Decode a JSON array, requiring a particular index.\n\n    json = \"\"\"[ \"alice\", \"bob\", \"chuck\" ]\"\"\"\n\n    decodeString (index 0 string) json  == Ok \"alice\"\n    decodeString (index 1 string) json  == Ok \"bob\"\n    decodeString (index 2 string) json  == Ok \"chuck\"\n    decodeString (index 3 string) json  == Err ...\n-}\nindex : Int -> Decoder a -> Decoder a\nindex =\n    Elm.Kernel.Json.decodeIndex\n\n\n\n-- WEIRD STRUCTURE\n\n\n{-| Helpful for dealing with optional fields. Here are a few slightly different\nexamples:\n\n    json = \"\"\"{ \"name\": \"tom\", \"age\": 42 }\"\"\"\n\n    decodeString (maybe (field \"age\"    int  )) json == Ok (Just 42)\n    decodeString (maybe (field \"name\"   int  )) json == Ok Nothing\n    decodeString (maybe (field \"height\" float)) json == Ok Nothing\n\n    decodeString (field \"age\"    (maybe int  )) json == Ok (Just 42)\n    decodeString (field \"name\"   (maybe int  )) json == Ok Nothing\n    decodeString (field \"height\" (maybe float)) json == Err ...\n\nNotice the last example! It is saying we *must* have a field named `height` and\nthe content *may* be a float. There is no `height` field, so the decoder fails.\n\nPoint is, `maybe` will make exactly what it contains conditional. For optional\nfields, this means you probably want it *outside* a use of `field` or `at`.\n-}\nmaybe : Decoder a -> Decoder (Maybe a)\nmaybe decoder =\n  oneOf\n    [ map Just decoder\n    , succeed Nothing\n    ]\n\n\n{-| Try a bunch of different decoders. This can be useful if the JSON may come\nin a couple different formats. For example, say you want to read an array of\nnumbers, but some of them are `null`.\n\n    import String\n\n    badInt : Decoder Int\n    badInt =\n      oneOf [ int, null 0 ]\n\n    -- decodeString (list badInt) \"[1,2,null,4]\" == Ok [1,2,0,4]\n\nWhy would someone generate JSON like this? Questions like this are not good\nfor your health. The point is that you can use `oneOf` to handle situations\nlike this!\n\nYou could also use `oneOf` to help version your data. Try the latest format,\nthen a few older ones that you still support. You could use `andThen` to be\neven more particular if you wanted.\n-}\noneOf : List (Decoder a) -> Decoder a\noneOf =\n    Elm.Kernel.Json.oneOf\n\n\n\n-- MAPPING\n\n\n{-| Transform a decoder. Maybe you just want to know the length of a string:\n\n    import String\n\n    stringLength : Decoder Int\n    stringLength =\n      map String.length string\n\nIt is often helpful to use `map` with `oneOf`, like when defining `nullable`:\n\n    nullable : Decoder a -> Decoder (Maybe a)\n    nullable decoder =\n      oneOf\n        [ null Nothing\n        , map Just decoder\n        ]\n-}\nmap : (a -> value) -> Decoder a -> Decoder value\nmap =\n    Elm.Kernel.Json.map1\n\n\n{-| Try two decoders and then combine the result. We can use this to decode\nobjects with many fields:\n\n    type alias Point = { x : Float, y : Float }\n\n    point : Decoder Point\n    point =\n      map2 Point\n        (field \"x\" float)\n        (field \"y\" float)\n\n    -- decodeString point \"\"\"{ \"x\": 3, \"y\": 4 }\"\"\" == Ok { x = 3, y = 4 }\n\nIt tries each individual decoder and puts the result together with the `Point`\nconstructor.\n-}\nmap2 : (a -> b -> value) -> Decoder a -> Decoder b -> Decoder value\nmap2 =\n    Elm.Kernel.Json.map2\n\n\n{-| Try three decoders and then combine the result. We can use this to decode\nobjects with many fields:\n\n    type alias Person = { name : String, age : Int, height : Float }\n\n    person : Decoder Person\n    person =\n      map3 Person\n        (at [\"name\"] string)\n        (at [\"info\",\"age\"] int)\n        (at [\"info\",\"height\"] float)\n\n    -- json = \"\"\"{ \"name\": \"tom\", \"info\": { \"age\": 42, \"height\": 1.8 } }\"\"\"\n    -- decodeString person json == Ok { name = \"tom\", age = 42, height = 1.8 }\n\nLike `map2` it tries each decoder in order and then give the results to the\n`Person` constructor. That can be any function though!\n-}\nmap3 : (a -> b -> c -> value) -> Decoder a -> Decoder b -> Decoder c -> Decoder value\nmap3 =\n    Elm.Kernel.Json.map3\n\n\n{-|-}\nmap4 : (a -> b -> c -> d -> value) -> Decoder a -> Decoder b -> Decoder c -> Decoder d -> Decoder value\nmap4 =\n    Elm.Kernel.Json.map4\n\n\n{-|-}\nmap5 : (a -> b -> c -> d -> e -> value) -> Decoder a -> Decoder b -> Decoder c -> Decoder d -> Decoder e -> Decoder value\nmap5 =\n    Elm.Kernel.Json.map5\n\n\n{-|-}\nmap6 : (a -> b -> c -> d -> e -> f -> value) -> Decoder a -> Decoder b -> Decoder c -> Decoder d -> Decoder e -> Decoder f -> Decoder value\nmap6 =\n    Elm.Kernel.Json.map6\n\n\n{-|-}\nmap7 : (a -> b -> c -> d -> e -> f -> g -> value) -> Decoder a -> Decoder b -> Decoder c -> Decoder d -> Decoder e -> Decoder f -> Decoder g -> Decoder value\nmap7 =\n    Elm.Kernel.Json.map7\n\n\n{-|-}\nmap8 : (a -> b -> c -> d -> e -> f -> g -> h -> value) -> Decoder a -> Decoder b -> Decoder c -> Decoder d -> Decoder e -> Decoder f -> Decoder g -> Decoder h -> Decoder value\nmap8 =\n    Elm.Kernel.Json.map8\n\n\n\n-- RUN DECODERS\n\n\n{-| Parse the given string into a JSON value and then run the `Decoder` on it.\nThis will fail if the string is not well-formed JSON or if the `Decoder`\nfails for some reason.\n\n    decodeString int \"4\"     == Ok 4\n    decodeString int \"1 + 2\" == Err ...\n-}\ndecodeString : Decoder a -> String -> Result Error a\ndecodeString =\n  Elm.Kernel.Json.runOnString\n\n\n{-| Run a `Decoder` on some JSON `Value`. You can send these JSON values\nthrough ports, so that is probably the main time you would use this function.\n-}\ndecodeValue : Decoder a -> Value -> Result Error a\ndecodeValue =\n  Elm.Kernel.Json.run\n\n\n{-| Represents a JavaScript value.\n-}\ntype alias Value = Json.Encode.Value\n\n\n{-| A structured error describing exactly how the decoder failed. You can use\nthis to create more elaborate visualizations of a decoder problem. For example,\nyou could show the entire JSON object and show the part causing the failure in\nred.\n-}\ntype Error\n  = Field String Error\n  | Index Int Error\n  | OneOf (List Error)\n  | Failure String Value\n\n\n{-| Convert a decoding error into a `String` that is nice for debugging.\n\nIt produces multiple lines of output, so you may want to peek at it with\nsomething like this:\n\n    import Html\n    import Json.Decode as Decode\n\n    errorToHtml : Decode.Error -> Html.Html msg\n    errorToHtml error =\n      Html.pre [] [ Html.text (Decode.errorToString error) ]\n\n**Note:** It would be cool to do nicer coloring and fancier HTML, but I wanted\nto avoid having an `elm/html` dependency for now. It is totally possible to\ncrawl the `Error` structure and create this separately though!\n-}\nerrorToString : Error -> String\nerrorToString error =\n  errorToStringHelp error []\n\n\nerrorToStringHelp : Error -> List String -> String\nerrorToStringHelp error context =\n  case error of\n    Field f err ->\n      let\n        isSimple =\n          case String.uncons f of\n            Nothing ->\n              False\n\n            Just (char, rest) ->\n              Char.isAlpha char && String.all Char.isAlphaNum rest\n\n        fieldName =\n          if isSimple then \".\" ++ f else \"['\" ++ f ++ \"']\"\n      in\n        errorToStringHelp err (fieldName :: context)\n\n    Index i err ->\n      let\n        indexName =\n          \"[\" ++ String.fromInt i ++ \"]\"\n      in\n        errorToStringHelp err (indexName :: context)\n\n    OneOf errors ->\n      case errors of\n        [] ->\n          \"Ran into a Json.Decode.oneOf with no possibilities\" ++\n            case context of\n              [] ->\n                \"!\"\n              _ ->\n                \" at json\" ++ String.join \"\" (List.reverse context)\n\n        [err] ->\n          errorToStringHelp err context\n\n        _ ->\n          let\n            starter =\n              case context of\n                [] ->\n                  \"Json.Decode.oneOf\"\n                _ ->\n                  \"The Json.Decode.oneOf at json\" ++ String.join \"\" (List.reverse context)\n\n            introduction =\n              starter ++ \" failed in the following \" ++ String.fromInt (List.length errors) ++ \" ways:\"\n          in\n            String.join \"\\n\\n\" (introduction :: List.indexedMap errorOneOf errors)\n\n    Failure msg json ->\n      let\n        introduction =\n          case context of\n            [] ->\n              \"Problem with the given value:\\n\\n\"\n            _ ->\n              \"Problem with the value at json\" ++ String.join \"\" (List.reverse context) ++ \":\\n\\n    \"\n      in\n        introduction ++ indent (Json.Encode.encode 4 json) ++ \"\\n\\n\" ++ msg\n\n\nerrorOneOf : Int -> Error -> String\nerrorOneOf i error =\n  \"\\n\\n(\" ++ String.fromInt (i + 1) ++ \") \" ++ indent (errorToString error)\n\n\nindent : String -> String\nindent str =\n  String.join \"\\n    \" (String.split \"\\n\" str)\n\n\n\n-- FANCY PRIMITIVES\n\n\n{-| Ignore the JSON and produce a certain Elm value.\n\n    decodeString (succeed 42) \"true\"    == Ok 42\n    decodeString (succeed 42) \"[1,2,3]\" == Ok 42\n    decodeString (succeed 42) \"hello\"   == Err ... -- this is not a valid JSON string\n\nThis is handy when used with `oneOf` or `andThen`.\n-}\nsucceed : a -> Decoder a\nsucceed =\n  Elm.Kernel.Json.succeed\n\n\n{-| Ignore the JSON and make the decoder fail. This is handy when used with\n`oneOf` or `andThen` where you want to give a custom error message in some\ncase.\n\nSee the [`andThen`](#andThen) docs for an example.\n-}\nfail : String -> Decoder a\nfail =\n  Elm.Kernel.Json.fail\n\n\n{-| Create decoders that depend on previous results. If you are creating\nversioned data, you might do something like this:\n\n    info : Decoder Info\n    info =\n      field \"version\" int\n        |> andThen infoHelp\n\n    infoHelp : Int -> Decoder Info\n    infoHelp version =\n      case version of\n        4 ->\n          infoDecoder4\n\n        3 ->\n          infoDecoder3\n\n        _ ->\n          fail <|\n            \"Trying to decode info, but version \"\n            ++ toString version ++ \" is not supported.\"\n\n    -- infoDecoder4 : Decoder Info\n    -- infoDecoder3 : Decoder Info\n-}\nandThen : (a -> Decoder b) -> Decoder a -> Decoder b\nandThen =\n  Elm.Kernel.Json.andThen\n\n\n{-| Sometimes you have JSON with recursive structure, like nested comments.\nYou can use `lazy` to make sure your decoder unrolls lazily.\n\n    type alias Comment =\n      { message : String\n      , responses : Responses\n      }\n\n    type Responses = Responses (List Comment)\n\n    comment : Decoder Comment\n    comment =\n      map2 Comment\n        (field \"message\" string)\n        (field \"responses\" (map Responses (list (lazy (\\_ -> comment)))))\n\nIf we had said `list comment` instead, we would start expanding the value\ninfinitely. What is a `comment`? It is a decoder for objects where the\n`responses` field contains comments. What is a `comment` though? Etc.\n\nBy using `list (lazy (\\_ -> comment))` we make sure the decoder only expands\nto be as deep as the JSON we are given. You can read more about recursive data\nstructures [here][].\n\n[here]: https://github.com/elm/compiler/blob/master/hints/recursive-alias.md\n-}\nlazy : (() -> Decoder a) -> Decoder a\nlazy thunk =\n  andThen thunk (succeed ())\n\n\n{-| Do not do anything with a JSON value, just bring it into Elm as a `Value`.\nThis can be useful if you have particularly complex data that you would like to\ndeal with later. Or if you are going to send it out a port and do not care\nabout its structure.\n-}\nvalue : Decoder Value\nvalue =\n  Elm.Kernel.Json.decodeValue\n\n\n{-| Decode a `null` value into some Elm value.\n\n    decodeString (null False) \"null\" == Ok False\n    decodeString (null 42) \"null\"    == Ok 42\n    decodeString (null 42) \"42\"      == Err ..\n    decodeString (null 42) \"false\"   == Err ..\n\nSo if you ever see a `null`, this will return whatever value you specified.\n-}\nnull : a -> Decoder a\nnull =\n  Elm.Kernel.Json.decodeNull\n" })
            )
            ,( "Encode.elm"
            , BlobNode ({ utf8 = "module Json.Encode exposing\n  ( Value\n  , encode\n  , string, int, float, bool, null\n  , list, array, set\n  , object, dict\n  )\n\n{-| Library for turning Elm values into Json values.\n\n# Encoding\n@docs encode, Value\n\n# Primitives\n@docs string, int, float, bool, null\n\n# Arrays\n@docs list, array, set\n\n# Objects\n@docs object, dict\n-}\n\n\nimport Array exposing (Array)\nimport Dict exposing (Dict)\nimport Set exposing (Set)\nimport Elm.Kernel.Json\n\n\n\n-- ENCODE\n\n\n{-| Represents a JavaScript value.\n-}\ntype Value = Value\n\n\n{-| Convert a `Value` into a prettified string. The first argument specifies\nthe amount of indentation in the resulting string.\n\n    import Json.Encode as Encode\n\n    tom : Encode.Value\n    tom =\n        Encode.object\n            [ ( \"name\", Encode.string \"Tom\" )\n            , ( \"age\", Encode.int 42 )\n            ]\n\n    compact = Encode.encode 0 tom\n    -- {\"name\":\"Tom\",\"age\":42}\n\n    readable = Encode.encode 4 tom\n    -- {\n    --     \"name\": \"Tom\",\n    --     \"age\": 42\n    -- }\n-}\nencode : Int -> Value -> String\nencode =\n    Elm.Kernel.Json.encode\n\n\n\n-- PRIMITIVES\n\n\n{-| Turn a `String` into a JSON string.\n\n    import Json.Encode exposing (encode, string)\n\n    -- encode 0 (string \"\")      == \"\\\"\\\"\"\n    -- encode 0 (string \"abc\")   == \"\\\"abc\\\"\"\n    -- encode 0 (string \"hello\") == \"\\\"hello\\\"\"\n-}\nstring : String -> Value\nstring =\n    Elm.Kernel.Json.wrap\n\n\n{-| Turn an `Int` into a JSON number.\n\n    import Json.Encode exposing (encode, int)\n\n    -- encode 0 (int 42) == \"42\"\n    -- encode 0 (int -7) == \"-7\"\n    -- encode 0 (int 0)  == \"0\"\n-}\nint : Int -> Value\nint =\n    Elm.Kernel.Json.wrap\n\n\n{-| Turn a `Float` into a JSON number.\n\n    import Json.Encode exposing (encode, float)\n\n    -- encode 0 (float 3.14)     == \"3.14\"\n    -- encode 0 (float 1.618)    == \"1.618\"\n    -- encode 0 (float -42)      == \"-42\"\n    -- encode 0 (float NaN)      == \"null\"\n    -- encode 0 (float Infinity) == \"null\"\n\n**Note:** Floating point numbers are defined in the [IEEE 754 standard][ieee]\nwhich is hardcoded into almost all CPUs. This standard allows `Infinity` and\n`NaN`. [The JSON spec][json] does not include these values, so we encode them\nboth as `null`.\n\n[ieee]: https://en.wikipedia.org/wiki/IEEE_754\n[json]: https://www.json.org/\n-}\nfloat : Float -> Value\nfloat =\n    Elm.Kernel.Json.wrap\n\n\n{-| Turn a `Bool` into a JSON boolean.\n\n    import Json.Encode exposing (encode, bool)\n\n    -- encode 0 (bool True)  == \"true\"\n    -- encode 0 (bool False) == \"false\"\n-}\nbool : Bool -> Value\nbool =\n    Elm.Kernel.Json.wrap\n\n\n\n-- NULLS\n\n\n{-| Create a JSON `null` value.\n\n    import Json.Encode exposing (encode, null)\n\n    -- encode 0 null == \"null\"\n-}\nnull : Value\nnull =\n    Elm.Kernel.Json.encodeNull\n\n\n\n-- ARRAYS\n\n\n{-| Turn a `List` into a JSON array.\n\n    import Json.Encode as Encode exposing (bool, encode, int, list, string)\n\n    -- encode 0 (list int [1,3,4])       == \"[1,3,4]\"\n    -- encode 0 (list bool [True,False]) == \"[true,false]\"\n    -- encode 0 (list string [\"a\",\"b\"])  == \"\"\"[\"a\",\"b\"]\"\"\"\n\n-}\nlist : (a -> Value) -> List a -> Value\nlist func entries =\n    Elm.Kernel.Json.wrap\n        (List.foldl (Elm.Kernel.Json.addEntry func) (Elm.Kernel.Json.emptyArray ()) entries)\n\n\n{-| Turn an `Array` into a JSON array.\n-}\narray : (a -> Value) -> Array a -> Value\narray func entries =\n    Elm.Kernel.Json.wrap\n        (Array.foldl (Elm.Kernel.Json.addEntry func) (Elm.Kernel.Json.emptyArray ()) entries)\n\n\n{-| Turn an `Set` into a JSON array.\n-}\nset : (a -> Value) -> Set a -> Value\nset func entries =\n    Elm.Kernel.Json.wrap\n        (Set.foldl (Elm.Kernel.Json.addEntry func) (Elm.Kernel.Json.emptyArray ()) entries)\n\n\n\n-- OBJECTS\n\n\n{-| Create a JSON object.\n\n    import Json.Encode as Encode\n\n    tom : Encode.Value\n    tom =\n        Encode.object\n            [ ( \"name\", Encode.string \"Tom\" )\n            , ( \"age\", Encode.int 42 )\n            ]\n\n    -- Encode.encode 0 tom == \"\"\"{\"name\":\"Tom\",\"age\":42}\"\"\"\n-}\nobject : List (String, Value) -> Value\nobject pairs =\n    Elm.Kernel.Json.wrap (\n        List.foldl\n            (\\(k,v) obj -> Elm.Kernel.Json.addField k v obj)\n            (Elm.Kernel.Json.emptyObject ())\n            pairs\n    )\n\n\n{-| Turn a `Dict` into a JSON object.\n\n    import Dict exposing (Dict)\n    import Json.Encode as Encode\n\n    people : Dict String Int\n    people =\n      Dict.fromList [ (\"Tom\",42), (\"Sue\", 38) ]\n\n    -- Encode.encode 0 (Encode.dict identity Encode.int people)\n    --   == \"\"\"{\"Tom\":42,\"Sue\":38}\"\"\"\n-}\ndict : (k -> String) -> (v -> Value) -> Dict k v -> Value\ndict toKey toValue dictionary =\n    Elm.Kernel.Json.wrap (\n        Dict.foldl\n            (\\key value obj -> Elm.Kernel.Json.addField (toKey key) (toValue value) obj)\n            (Elm.Kernel.Json.emptyObject ())\n            dictionary\n    )\n" })
            )]
        )]

file_tree_node_elm_kernel_modules_time_src =
    TreeNode
        [( "Time.elm"
        , BlobNode ({ utf8 = "effect module Time where { subscription = MySub } exposing\n  ( Posix\n  , now\n  , every\n  , posixToMillis\n  , millisToPosix\n  , Zone\n  , utc\n  , here\n  , toYear\n  , toMonth\n  , toDay\n  , toWeekday\n  , toHour\n  , toMinute\n  , toSecond\n  , toMillis\n  , Month(..)\n  , Weekday(..)\n  , customZone\n  , getZoneName\n  , ZoneName(..)\n  )\n\n\n{-| Library for working with time and time zones.\n\n# Time\n@docs Posix, now, every, posixToMillis, millisToPosix\n\n# Time Zones\n@docs Zone, utc, here\n\n# Human Times\n@docs toYear, toMonth, toDay, toWeekday, toHour, toMinute, toSecond, toMillis\n\n# Weeks and Months\n@docs Weekday, Month\n\n# For Package Authors\n@docs customZone, getZoneName, ZoneName\n\n-}\n\n\nimport Basics exposing (..)\nimport Dict\nimport Elm.Kernel.Time\nimport List exposing ((::))\nimport Maybe exposing (Maybe(..))\nimport Platform\nimport Platform.Sub exposing (Sub)\nimport Process\nimport String exposing (String)\nimport Task exposing (Task)\n\n\n\n-- POSIX\n\n\n{-| A computer representation of time. It is the same all over Earth, so if we\nhave a phone call or meeting at a certain POSIX time, there is no ambiguity.\n\nIt is very hard for humans to _read_ a POSIX time though, so we use functions\nlike [`toHour`](#toHour) and [`toMinute`](#toMinute) to `view` them.\n-}\ntype Posix = Posix Int\n\n\n{-| Get the POSIX time at the moment when this task is run.\n-}\nnow : Task x Posix\nnow =\n  Elm.Kernel.Time.now millisToPosix\n\n\n{-| Turn a `Posix` time into the number of milliseconds since 1970 January 1\nat 00:00:00 UTC. It was a Thursday.\n-}\nposixToMillis : Posix -> Int\nposixToMillis (Posix millis) =\n  millis\n\n\n{-| Turn milliseconds into a `Posix` time.\n-}\nmillisToPosix : Int -> Posix\nmillisToPosix =\n  Posix\n\n\n\n-- TIME ZONES\n\n\n{-| Information about a particular time zone.\n\nThe [IANA Time Zone Database][iana] tracks things like UTC offsets and\ndaylight-saving rules so that you can turn a `Posix` time into local times\nwithin a time zone.\n\nSee [`utc`](#utc), [`here`](#here), and [`Browser.Env`][env] to learn how to\nobtain `Zone` values.\n\n[iana]: https://www.iana.org/time-zones\n[env]: /packages/elm/browser/latest/Browser#Env\n-}\ntype Zone =\n  Zone Int (List Era)\n\n\n-- TODO: add this note back to `Zone` docs when it is true\n--\n-- Did you know that in California the times change from 3pm PST to 3pm PDT to\n-- capture whether it is daylight-saving time? The database tracks those\n-- abbreviation changes too. (Tons of time zones do that actually.)\n--\n\n\n{-| Currently the public API only needs:\n\n- `start` is the beginning of this `Era` in \"minutes since the Unix Epoch\"\n- `offset` is the UTC offset of this `Era` in minutes\n\nBut eventually, it will make sense to have `abbr : String` for `PST` vs `PDT`\n-}\ntype alias Era =\n  { start : Int\n  , offset : Int\n  }\n\n\n{-| The time zone for Coordinated Universal Time ([UTC][])\n\nThe `utc` zone has no time adjustments. It never observes daylight-saving\ntime and it never shifts around based on political restructuring.\n\n[UTC]: https://en.wikipedia.org/wiki/Coordinated_Universal_Time\n-}\nutc : Zone\nutc =\n  Zone 0 []\n\n\n{-| Produce a `Zone` based on the current UTC offset. You can use this to figure\nout what day it is where you are:\n\n    import Task exposing (Task)\n    import Time\n\n    whatDayIsIt : Task x Int\n    whatDayIsIt =\n      Task.map2 Time.toDay Time.here Time.now\n\n**Accuracy Note:** This function can only give time zones like `Etc/GMT+9` or\n`Etc/GMT-6`. It cannot give you `Europe/Stockholm`, `Asia/Tokyo`, or any other\nnormal time zone from the [full list][tz] due to limitations in JavaScript.\nFor example, if you run `here` in New York City, the resulting `Zone` will\nnever be `America/New_York`. Instead you get `Etc/GMT-5` or `Etc/GMT-4`\ndepending on Daylight Saving Time. So even though browsers must have internal\naccess to `America/New_York` to figure out that offset, there is no public API\nto get the full information. This means the `Zone` you get from this function\nwill act weird if (1) an application stays open across a Daylight Saving Time\nboundary or (2) you try to use it on historical data.\n\n**Future Note:** We can improve `here` when there is good browser support for\nJavaScript functions that (1) expose the IANA time zone database and (2) let\nyou ask the time zone of the computer. The committee that reviews additions to\nJavaScript is called TC39, and I encourage you to push for these capabilities! I\ncannot do it myself unfortunately.\n\n**Alternatives:** See the `customZone` docs to learn how to implement stopgaps.\n\n[tz]: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\n-}\nhere : Task x Zone\nhere =\n  Elm.Kernel.Time.here ()\n\n\n\n-- DATES\n\n\n{-| What year is it?!\n\n    import Time exposing (toYear, utc, millisToPosix)\n\n    toYear utc (millisToPosix 0) == 1970\n    toYear nyc (millisToPosix 0) == 1969\n\n    -- pretend `nyc` is the `Zone` for America/New_York.\n-}\ntoYear : Zone -> Posix -> Int\ntoYear zone time =\n  (toCivil (toAdjustedMinutes zone time)).year\n\n\n{-| What month is it?!\n\n    import Time exposing (toMonth, utc, millisToPosix)\n\n    toMonth utc (millisToPosix 0) == Jan\n    toMonth nyc (millisToPosix 0) == Dec\n\n    -- pretend `nyc` is the `Zone` for America/New_York.\n-}\ntoMonth : Zone -> Posix -> Month\ntoMonth zone time =\n  case (toCivil (toAdjustedMinutes zone time)).month of\n    1  -> Jan\n    2  -> Feb\n    3  -> Mar\n    4  -> Apr\n    5  -> May\n    6  -> Jun\n    7  -> Jul\n    8  -> Aug\n    9  -> Sep\n    10 -> Oct\n    11 -> Nov\n    _  -> Dec\n\n\n{-| What day is it?! (Days go from 1 to 31)\n\n    import Time exposing (toDay, utc, millisToPosix)\n\n    toDay utc (millisToPosix 0) == 1\n    toDay nyc (millisToPosix 0) == 31\n\n    -- pretend `nyc` is the `Zone` for America/New_York.\n\n-}\ntoDay : Zone -> Posix -> Int\ntoDay zone time =\n  (toCivil (toAdjustedMinutes zone time)).day\n\n\n{-| What day of the week is it?\n\n    import Time exposing (toWeekday, utc, millisToPosix)\n\n    toWeekday utc (millisToPosix 0) == Thu\n    toWeekday nyc (millisToPosix 0) == Wed\n\n    -- pretend `nyc` is the `Zone` for America/New_York.\n-}\ntoWeekday : Zone -> Posix -> Weekday\ntoWeekday zone time =\n  case modBy 7 (flooredDiv (toAdjustedMinutes zone time) (60 * 24)) of\n    0 -> Thu\n    1 -> Fri\n    2 -> Sat\n    3 -> Sun\n    4 -> Mon\n    5 -> Tue\n    _ -> Wed\n\n\n{-| What hour is it? (From 0 to 23)\n\n    import Time exposing (toHour, utc, millisToPosix)\n\n    toHour utc (millisToPosix 0) == 0  -- 12am\n    toHour nyc (millisToPosix 0) == 19 -- 7pm\n\n    -- pretend `nyc` is the `Zone` for America/New_York.\n-}\ntoHour : Zone -> Posix -> Int\ntoHour zone time =\n  modBy 24 (flooredDiv (toAdjustedMinutes zone time) 60)\n\n\n{-| What minute is it? (From 0 to 59)\n\n    import Time exposing (toMinute, utc, millisToPosix)\n\n    toMinute utc (millisToPosix 0) == 0\n\nThis can be different in different time zones. Some time zones are offset\nby 30 or 45 minutes!\n-}\ntoMinute : Zone -> Posix -> Int\ntoMinute zone time =\n  modBy 60 (toAdjustedMinutes zone time)\n\n\n{-| What second is it?\n\n    import Time exposing (toSecond, utc, millisToPosix)\n\n    toSecond utc (millisToPosix    0) == 0\n    toSecond utc (millisToPosix 1234) == 1\n    toSecond utc (millisToPosix 5678) == 5\n-}\ntoSecond : Zone -> Posix -> Int\ntoSecond _ time =\n  modBy 60 (flooredDiv (posixToMillis time) 1000)\n\n\n{-|\n    import Time exposing (toMillis, utc, millisToPosix)\n\n    toMillis utc (millisToPosix    0) == 0\n    toMillis utc (millisToPosix 1234) == 234\n    toMillis utc (millisToPosix 5678) == 678\n-}\ntoMillis : Zone -> Posix -> Int\ntoMillis _ time =\n  modBy 1000 (posixToMillis time)\n\n\n\n-- DATE HELPERS\n\n\ntoAdjustedMinutes : Zone -> Posix -> Int\ntoAdjustedMinutes (Zone defaultOffset eras) time =\n  toAdjustedMinutesHelp defaultOffset (flooredDiv (posixToMillis time) 60000) eras\n\n\ntoAdjustedMinutesHelp : Int -> Int -> List Era -> Int\ntoAdjustedMinutesHelp defaultOffset posixMinutes eras =\n  case eras of\n    [] ->\n      posixMinutes + defaultOffset\n\n    era :: olderEras ->\n      if era.start < posixMinutes then\n        posixMinutes + era.offset\n      else\n        toAdjustedMinutesHelp defaultOffset posixMinutes olderEras\n\n\ntoCivil : Int -> { year : Int, month : Int, day : Int }\ntoCivil minutes =\n  let\n    rawDay    = flooredDiv minutes (60 * 24) + 719468\n    era       = (if rawDay >= 0 then rawDay else rawDay - 146096) // 146097\n    dayOfEra  = rawDay - era * 146097 -- [0, 146096]\n    yearOfEra = (dayOfEra - dayOfEra // 1460 + dayOfEra // 36524 - dayOfEra // 146096) // 365 -- [0, 399]\n    year      = yearOfEra + era * 400\n    dayOfYear = dayOfEra - (365 * yearOfEra + yearOfEra // 4 - yearOfEra // 100) -- [0, 365]\n    mp        = (5 * dayOfYear + 2) // 153 -- [0, 11]\n    month     = mp + (if mp < 10 then 3 else -9) -- [1, 12]\n  in\n  { year = year + (if month <= 2 then 1 else 0)\n  , month = month\n  , day = dayOfYear - (153 * mp + 2) // 5 + 1 -- [1, 31]\n  }\n\n\nflooredDiv : Int -> Float -> Int\nflooredDiv numerator denominator =\n  floor (toFloat numerator / denominator)\n\n\n\n-- WEEKDAYS AND MONTHS\n\n\n{-| Represents a `Weekday` so that you can convert it to a `String` or `Int`\nhowever you please. For example, if you need the Japanese representation, you\ncan say:\n\n    toJapaneseWeekday : Weekday -> String\n    toJapaneseWeekday weekday =\n      case weekday of\n        Mon -> \"\"\n        Tue -> \"\"\n        Wed -> \"\"\n        Thu -> \"\"\n        Fri -> \"\"\n        Sat -> \"\"\n        Sun -> \"\"\n-}\ntype Weekday = Mon | Tue | Wed | Thu | Fri | Sat | Sun\n\n\n{-| Represents a `Month` so that you can convert it to a `String` or `Int`\nhowever you please. For example, if you need the Danish representation, you\ncan say:\n\n    toDanishMonth : Month -> String\n    toDanishMonth month =\n      case month of\n        Jan -> \"januar\"\n        Feb -> \"februar\"\n        Mar -> \"marts\"\n        Apr -> \"april\"\n        May -> \"maj\"\n        Jun -> \"juni\"\n        Jul -> \"juli\"\n        Aug -> \"august\"\n        Sep -> \"september\"\n        Oct -> \"oktober\"\n        Nov -> \"november\"\n        Dec -> \"december\"\n-}\ntype Month = Jan | Feb | Mar | Apr | May | Jun | Jul | Aug | Sep | Oct | Nov | Dec\n\n\n\n-- SUBSCRIPTIONS\n\n\n{-| Get the current time periodically. How often though? Well, you provide an\ninterval in milliseconds (like `1000` for a second or `60 * 1000` for a minute\nor `60 * 60 * 1000` for an hour) and that is how often you get a new time!\n\nCheck out [this example](https://elm-lang.org/examples/time) to see how to use\nit in an application.\n\n**This function is not for animation.** Use the [`elm/animation-frame`][af]\npackage for that sort of thing! It syncs up with repaints and will end up\nbeing much smoother for any moving visuals.\n\n[af]: /packages/elm/animation-frame/latest\n-}\nevery : Float -> (Posix -> msg) -> Sub msg\nevery interval tagger =\n  subscription (Every interval tagger)\n\n\ntype MySub msg =\n  Every Float (Posix -> msg)\n\n\nsubMap : (a -> b) -> MySub a -> MySub b\nsubMap f (Every interval tagger) =\n  Every interval (f << tagger)\n\n\n\n-- EFFECT MANAGER\n\n\ntype alias State msg =\n  { taggers : Taggers msg\n  , processes : Processes\n  }\n\n\ntype alias Processes =\n  Dict.Dict Float Platform.ProcessId\n\n\ntype alias Taggers msg =\n  Dict.Dict Float (List (Posix -> msg))\n\n\ninit : Task Never (State msg)\ninit =\n  Task.succeed (State Dict.empty Dict.empty)\n\n\nonEffects : Platform.Router msg Float -> List (MySub msg) -> State msg -> Task Never (State msg)\nonEffects router subs {processes} =\n  let\n    newTaggers =\n      List.foldl addMySub Dict.empty subs\n\n    leftStep interval taggers (spawns, existing, kills) =\n      ( interval :: spawns, existing, kills )\n\n    bothStep interval taggers id (spawns, existing, kills) =\n      ( spawns, Dict.insert interval id existing, kills )\n\n    rightStep _ id (spawns, existing, kills) =\n      ( spawns, existing, Task.andThen (\\_ -> kills) (Process.kill id) )\n\n    (spawnList, existingDict, killTask) =\n      Dict.merge\n        leftStep\n        bothStep\n        rightStep\n        newTaggers\n        processes\n        ([], Dict.empty, Task.succeed ())\n  in\n    killTask\n      |> Task.andThen (\\_ -> spawnHelp router spawnList existingDict)\n      |> Task.andThen (\\newProcesses -> Task.succeed (State newTaggers newProcesses))\n\n\naddMySub : MySub msg -> Taggers msg -> Taggers msg\naddMySub (Every interval tagger) state =\n  case Dict.get interval state of\n    Nothing ->\n      Dict.insert interval [tagger] state\n\n    Just taggers ->\n      Dict.insert interval (tagger :: taggers) state\n\n\nspawnHelp : Platform.Router msg Float -> List Float -> Processes -> Task.Task x Processes\nspawnHelp router intervals processes =\n  case intervals of\n    [] ->\n      Task.succeed processes\n\n    interval :: rest ->\n      let\n        spawnTimer =\n          Process.spawn (setInterval interval (Platform.sendToSelf router interval))\n\n        spawnRest id =\n          spawnHelp router rest (Dict.insert interval id processes)\n      in\n        spawnTimer\n          |> Task.andThen spawnRest\n\n\nonSelfMsg : Platform.Router msg Float -> Float -> State msg -> Task Never (State msg)\nonSelfMsg router interval state =\n  case Dict.get interval state.taggers of\n    Nothing ->\n      Task.succeed state\n\n    Just taggers ->\n      let\n        tellTaggers time =\n          Task.sequence (List.map (\\tagger -> Platform.sendToApp router (tagger time)) taggers)\n      in\n        now\n          |> Task.andThen tellTaggers\n          |> Task.andThen (\\_ -> Task.succeed state)\n\n\nsetInterval : Float -> Task Never () -> Task x Never\nsetInterval =\n  Elm.Kernel.Time.setInterval\n\n\n\n-- FOR PACKAGE AUTHORS\n\n\n\n{-| **Intended for package authors.**\n\nThe documentation of [`here`](#here) explains that it has certain accuracy\nlimitations that block on adding new APIs to JavaScript. The `customZone`\nfunction is a stopgap that takes:\n\n1. A default offset in minutes. So `Etc/GMT-5` is `customZone (-5 * 60) []`\nand `Etc/GMT+9` is `customZone (9 * 60) []`.\n2. A list of exceptions containing their `start` time in \"minutes since the Unix\nepoch\" and their `offset` in \"minutes from UTC\"\n\nHuman times will be based on the nearest `start`, falling back on the default\noffset if the time is older than all of the exceptions.\n\nWhen paired with `getZoneName`, this allows you to load the real IANA time zone\ndatabase however you want: HTTP, cache, hardcode, etc.\n\n**Note:** If you use this, please share your work in an Elm community forum!\nI am sure others would like to hear about it, and more experience reports will\nhelp me and the any potential TC39 proposal.\n-}\ncustomZone : Int -> List { start : Int, offset : Int } -> Zone\ncustomZone =\n  Zone\n\n\n{-| **Intended for package authors.**\n\nUse `Intl.DateTimeFormat().resolvedOptions().timeZone` to try to get names\nlike `Europe/Moscow` or `America/Havana`. From there you can look it up in any\nIANA data you loaded yourself.\n-}\ngetZoneName : Task x ZoneName\ngetZoneName =\n  Elm.Kernel.Time.getZoneName ()\n\n\n{-| **Intended for package authors.**\n\nThe `getZoneName` function relies on a JavaScript API that is not supported\nin all browsers yet, so it can return the following:\n\n    -- in more recent browsers\n    Name \"Europe/Moscow\"\n    Name \"America/Havana\"\n\n    -- in older browsers\n    Offset 180\n    Offset -300\n\nSo if the real info is not available, it will tell you the current UTC offset\nin minutes, just like what `here` uses to make zones like `customZone -60 []`.\n-}\ntype ZoneName\n  = Name String\n  | Offset Int\n" })
        )]

file_tree_node_static =
    TreeNode
        [( "favicon.svg"
        , BlobNode ({ base64 = "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+DQo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPg0KPHN2ZyB2ZXJzaW9uPSIxLjEiDQogICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIg0KICAgIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgMTAwIDEwMCI+DQogICAgPHBhdGggZD0iTTEgOTlMMSAxTDk5IDFMOTkgOTlMMSA5OVoiIGZpbGw9IiMxQTJCMEMiPjwvcGF0aD4NCiAgICA8cGF0aCBkPSJNIDQyLjkwMSA2OC41NjUgTCA0Mi45MDEgNzYuMzk2IEwgMTEgNzYuMzk2IEwgMTEgMjAgTCA0Mi45MDEgMjAgTCA0Mi45MDEgMjcuNzkyIEwgMjAuMjE5IDI3Ljc5MiBMIDIwLjIxOSA0My4xNDUgTCA0MS40NzQgNDMuMTQ1IEwgNDEuNDc0IDUwLjg1OSBMIDIwLjIxOSA1MC44NTkgTCAyMC4yMTkgNjguNTY1IEwgNDIuOTAxIDY4LjU2NSBaIiBmaWxsPSIjN0JDQTM5Ij48L3BhdGg+DQogICAgPHBhdGggZD0iTSA4OS4zNDQgNTIuMjA5IEwgODkuMzQ0IDU3LjEwOCBMIDYwLjkxNSA1Ny4xMDggUSA2MS4xMDggNjMuMzE5IDY0LjI3MSA2Ni42NTYgQSAxMS42ODkgMTEuNjg5IDAgMCAwIDczLjE4MiA2OS45OTIgUSA3Ni45NjIgNjkuOTkyIDgwLjIyMSA2OS4yNzkgQSAzNi45MDEgMzYuOTAxIDAgMCAwIDg3LjIyMyA2Ni45MDYgTCA4Ny4yMjMgNzQuMjc0IEEgMjcuODMyIDI3LjgzMiAwIDAgMSA4MC41MTEgNzYuNTExIEEgNDEuMTU3IDQxLjE1NyAwIDAgMSA3Mi43NTcgNzcuMTY3IEEgMjAuNjM4IDIwLjYzOCAwIDAgMSA1Ny4xOTMgNzEuMzYyIFEgNTEuNTggNjUuNTU2IDUxLjU4IDU1LjM3MyBBIDI0LjMyNiAyNC4zMjYgMCAwIDEgNTYuNjI2IDM5LjEyOCBBIDE4LjMxNCAxOC4zMTQgMCAwIDEgNTYuNzg4IDM4Ljk0IEEgMTcuOTg3IDE3Ljk4NyAwIDAgMSA3MS4wOTkgMzIuOTYxIEEgMTcuNTggMTcuNTggMCAwIDEgODQuNDQ1IDM4LjA5MSBBIDE5LjYwNCAxOS42MDQgMCAwIDEgODkuMzQ0IDUyLjIwOSBaIE0gNjEuMDY5IDUwLjU1MSBMIDgwLjQzNCA1MC41NTEgQSAxMS44MDkgMTEuODA5IDAgMCAwIDc3Ljg4OCA0Mi41NDcgQSA4LjcwOCA4LjcwOCAwIDAgMCA3MS4wOTkgMzkuODI3IFEgNjYuNzc4IDM5LjgyNyA2NC4xNzUgNDIuNTY2IFEgNjEuNTcxIDQ1LjMwNSA2MS4wNjkgNTAuNTUxIFoiIGZpbGw9IiM3QkNBMzkiPjwvcGF0aD4NCiAgICA8cGF0aCBkPSJNMCAxMDBMMCAwTDEwMCAwTDEwMCAxMDBMMCAxMDBaTTQgOTdMOTcgOTdMOTcgM0wzIDNMMyA5N1oiIGZpbGw9IiM3QkNBMzkiPjwvcGF0aD4NCjwvc3ZnPg==" })
        )
        ,( "monarch.js"
        , BlobNode ({ base64 = "dmFyIGVsbV9tb25hcmNoID0gewogICAgLy8gU2V0IGRlZmF1bHRUb2tlbiB0byBpbnZhbGlkIHRvIHNlZSB3aGF0IHlvdSBkbyBub3QgdG9rZW5pemUgeWV0CiAgICAvLyBkZWZhdWx0VG9rZW46ICdpbnZhbGlkJywKCiAgICBrZXl3b3JkczogWwogICAgICAgICdpZicsICd0aGVuJywgJ2Vsc2UnLAogICAgICAgICdjYXNlJywgJ29mJywKICAgICAgICAnbGV0JywgJ2luJywKICAgICAgICAnbW9kdWxlJywgJ2ltcG9ydCcsICdleHBvc2luZycsCiAgICAgICAgJ3BvcnQnLAogICAgICAgICdhcycsCiAgICAgICAgJ18nCiAgICBdLAoKICAgIHR5cGVLZXl3b3JkczogWwogICAgICAgICd0eXBlJywgJ2FsaWFzJwogICAgXSwKCiAgICBvcGVyYXRvcnM6IFsKICAgICAgICAnPScsICc+JywgJzwnLCAnPT0nLCAnPD0nLCAnPj0nLCAnLz0nLAogICAgICAgICcmJicsICd8fCcsICcrKycsICcrJywgJy0nLCAnKicsICcvJywgJy8vJywKICAgICAgICAnPDwnLCAnPj4nCiAgICBdLAoKICAgIC8vIHdlIGluY2x1ZGUgdGhlc2UgY29tbW9uIHJlZ3VsYXIgZXhwcmVzc2lvbnMKICAgIHN5bWJvbHM6IC9bPT48IX4/OiZ8K1wtKlwvXF4lXSsvLAoKICAgIC8vIEMjIHN0eWxlIHN0cmluZ3MKICAgIGVzY2FwZXM6IC9cXCg/OlthYmZucnR2XFwiJ118eFswLTlBLUZhLWZdezEsNH18dVswLTlBLUZhLWZdezR9fFVbMC05QS1GYS1mXXs4fSkvLAoKICAgIC8vIFRoZSBtYWluIHRva2VuaXplciBmb3Igb3VyIGxhbmd1YWdlcwogICAgdG9rZW5pemVyOiB7CiAgICAgICAgcm9vdDogWwogICAgICAgICAgICBbL15bYS16XyRdW1x3JF0qLywgewogICAgICAgICAgICAgICAgY2FzZXM6IHsKICAgICAgICAgICAgICAgICAgICAnQHR5cGVLZXl3b3Jkcyc6ICd0eXBlJywKICAgICAgICAgICAgICAgICAgICAnQGtleXdvcmRzJzogJ2tleXdvcmQnLAogICAgICAgICAgICAgICAgICAgICdAZGVmYXVsdCc6ICdmdW5jdGlvbi5uYW1lJwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIF0sCgogICAgICAgICAgICBbL1thLXpfJF1bXHckXSovLCB7CiAgICAgICAgICAgICAgICBjYXNlczogewogICAgICAgICAgICAgICAgICAgICdleHBvc2luZyc6IHsgdG9rZW46ICdrZXl3b3JkJywgbmV4dDogJ0BhZnRlcl9rZXl3b3JkX2V4cG9zaW5nJyB9LAogICAgICAgICAgICAgICAgICAgICdAdHlwZUtleXdvcmRzJzogJ3R5cGUnLAogICAgICAgICAgICAgICAgICAgICdAa2V5d29yZHMnOiAna2V5d29yZCcsCiAgICAgICAgICAgICAgICAgICAgJ0BkZWZhdWx0JzogJ2lkZW50aWZpZXInCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH1dLAoKCiAgICAgICAgICAgIFsvW0EtWl1bXHdcJF0qLywgJ3R5cGUuaWRlbnRpZmllciddLCAgLy8gdG8gc2hvdyBjbGFzcyBuYW1lcyBuaWNlbHkKCiAgICAgICAgICAgIC8vIHdoaXRlc3BhY2UKICAgICAgICAgICAgeyBpbmNsdWRlOiAnQHdoaXRlc3BhY2UnIH0sCgogICAgICAgICAgICAvLyBkZWxpbWl0ZXJzIGFuZCBvcGVyYXRvcnMKICAgICAgICAgICAgWy9be30oKVxbXF1dLywgJ0BicmFja2V0cyddLAogICAgICAgICAgICBbL1s8Pl0oPyFAc3ltYm9scykvLCAnQGJyYWNrZXRzJ10sCiAgICAgICAgICAgIFsvQHN5bWJvbHMvLCB7CiAgICAgICAgICAgICAgICBjYXNlczogewogICAgICAgICAgICAgICAgICAgICdAb3BlcmF0b3JzJzogJ29wZXJhdG9yJywKICAgICAgICAgICAgICAgICAgICAnQGRlZmF1bHQnOiAnJwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9XSwKCiAgICAgICAgICAgIC8vIEAgYW5ub3RhdGlvbnMuCiAgICAgICAgICAgIC8vIEFzIGFuIGV4YW1wbGUsIHdlIGVtaXQgYSBkZWJ1Z2dpbmcgbG9nIG1lc3NhZ2Ugb24gdGhlc2UgdG9rZW5zLgogICAgICAgICAgICAvLyBOb3RlOiBtZXNzYWdlIGFyZSBzdXByZXNzZWQgZHVyaW5nIHRoZSBmaXJzdCBsb2FkIC0tIGNoYW5nZSBzb21lIGxpbmVzIHRvIHNlZSB0aGVtLgogICAgICAgICAgICBbL0BccypbYS16QS1aX1wkXVtcd1wkXSovLCB7IHRva2VuOiAnYW5ub3RhdGlvbicsIGxvZzogJ2Fubm90YXRpb24gdG9rZW46ICQwJyB9XSwKCiAgICAgICAgICAgIC8vIG51bWJlcnMKICAgICAgICAgICAgWy9cZCpcLlxkKyhbZUVdW1wtK10/XGQrKT8vLCAnbnVtYmVyLmZsb2F0J10sCiAgICAgICAgICAgIFsvMFt4WF1bMC05YS1mQS1GXSsvLCAnbnVtYmVyLmhleCddLAogICAgICAgICAgICBbL1xkKy8sICdudW1iZXInXSwKCiAgICAgICAgICAgIC8vIGRlbGltaXRlcjogYWZ0ZXIgbnVtYmVyIGJlY2F1c2Ugb2YgLlxkIGZsb2F0cwogICAgICAgICAgICBbL1s7LC5dLywgJ2RlbGltaXRlciddLAoKICAgICAgICAgICAgLy8gc3RyaW5ncwogICAgICAgICAgICBbLyIoW14iXFxdfFxcLikqJC8sICdzdHJpbmcuaW52YWxpZCddLCAgLy8gbm9uLXRlbWluYXRlZCBzdHJpbmcKICAgICAgICAgICAgWy8iLywgeyB0b2tlbjogJ3N0cmluZy5xdW90ZScsIGJyYWNrZXQ6ICdAb3BlbicsIG5leHQ6ICdAc3RyaW5nJyB9XSwKCiAgICAgICAgICAgIC8vIGNoYXJhY3RlcnMKICAgICAgICAgICAgWy8nW15cXCddJy8sICdzdHJpbmcnXSwKICAgICAgICAgICAgWy8oJykoQGVzY2FwZXMpKCcpLywgWydzdHJpbmcnLCAnc3RyaW5nLmVzY2FwZScsICdzdHJpbmcnXV0sCiAgICAgICAgICAgIFsvJy8sICdzdHJpbmcuaW52YWxpZCddCiAgICAgICAgXSwKCiAgICAgICAgY29tbWVudDogWwogICAgICAgICAgICBbL3stLywgJ2NvbW1lbnQnLCAnQHB1c2gnXSwgICAgLy8gbmVzdGVkIGNvbW1lbnQKICAgICAgICAgICAgWy8tfS8sICdjb21tZW50JywgJ0Bwb3AnXSwKICAgICAgICAgICAgWy8uLywgJ2NvbW1lbnQuY29udGVudCddCiAgICAgICAgXSwKCiAgICAgICAgYWZ0ZXJfa2V5d29yZF9leHBvc2luZzoKICAgICAgICAgICAgWwogICAgICAgICAgICAgICAgWy9cKC8sIHsgdG9rZW46ICdkZWxpbWl0ZXInLCBzd2l0Y2hUbzogJ2V4cG9zaW5nJyB9XSwKICAgICAgICAgICAgICAgIFsvJC8sIHsgdG9rZW46ICd3aGl0ZXNwYWNlJywgbmV4dDogJ0Bwb3BhbGwnIH1dLAogICAgICAgICAgICAgICAgWy9eW2Etel0vLCB7IHRva2VuOiAnd2hpdGVzcGFjZScsIG5leHQ6ICdAcG9wYWxsJyB9XSwKICAgICAgICAgICAgICAgIFsvXCkvLCB7IHRva2VuOiAnZGVsaW1pdGVyJywgbmV4dDogJ0Bwb3AnIH1dLAogICAgICAgICAgICBdLAoKICAgICAgICBleHBvc2luZzoKICAgICAgICAgICAgWwogICAgICAgICAgICAgICAgWy9cKS8sIHsgdG9rZW46ICdkZWxpbWl0ZXInLCBuZXh0OiAnQHBvcCcgfV0sCiAgICAgICAgICAgICAgICBbLyQvLCB7IHRva2VuOiAnd2hpdGVzcGFjZScsIG5leHQ6ICdAcG9wYWxsJyB9XSwKICAgICAgICAgICAgICAgIFsvXlthLXpdLywgeyB0b2tlbjogJ3doaXRlc3BhY2UnLCBuZXh0OiAnQHBvcGFsbCcgfV0sCiAgICAgICAgICAgICAgICBbL1tBLVpfJF1bXHckXSovLCB7IHRva2VuOiAndHlwZScgfV0sCiAgICAgICAgICAgICAgICBbL1thLXpfJF1bXHckXSovLCB7IHRva2VuOiAnZnVuY3Rpb24ubmFtZScgfV0sCiAgICAgICAgICAgICAgICBbL1woLywgeyB0b2tlbjogJ2RlbGltaXRlcicsIG5leHQ6ICdAcHVzaCcgfV0sCiAgICAgICAgICAgIF0sCgogICAgICAgIHN0cmluZzogWwogICAgICAgICAgICBbL1teXFwiXSsvLCAnc3RyaW5nJ10sCiAgICAgICAgICAgIFsvQGVzY2FwZXMvLCAnc3RyaW5nLmVzY2FwZSddLAogICAgICAgICAgICBbL1xcLi8sICdzdHJpbmcuZXNjYXBlLmludmFsaWQnXSwKICAgICAgICAgICAgWy8iLywgeyB0b2tlbjogJ3N0cmluZy5xdW90ZScsIGJyYWNrZXQ6ICdAY2xvc2UnLCBuZXh0OiAnQHBvcCcgfV0KICAgICAgICBdLAoKICAgICAgICBzdHJpbmdfdHJpcGxlX3F1b3RlOiBbCiAgICAgICAgICAgIFsvIiIiLywgJ3N0cmluZycsICdAcG9wJ10sCiAgICAgICAgICAgIFsvLi8sICdzdHJpbmcnXQogICAgICAgIF0sCgogICAgICAgIHdoaXRlc3BhY2U6IFsKICAgICAgICAgICAgWy9bIFx0XHJcbl0rLywgJ3doaXRlJ10sCiAgICAgICAgICAgIFsvey0vLCAnY29tbWVudCcsICdAY29tbWVudCddLAogICAgICAgICAgICBbLy0tLiokLywgJ2NvbW1lbnQnXSwKICAgICAgICAgICAgWy8iIiIvLCAnc3RyaW5nJywgJ0BzdHJpbmdfdHJpcGxlX3F1b3RlJ10sCiAgICAgICAgXSwKICAgIH0sCn07Cgp3aW5kb3cuZWxtX21vbmFyY2ggPSBlbG1fbW9uYXJjaDsKCg==" })
        )
        ,( "robots.txt"
        , BlobNode ({ base64 = "dXNlci1hZ2VudDogKgphbGxvdzogLwo=" })
        )]